#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Okcoin : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "okcoin",
            "name": "OKCoin",
            "countries": [
                "CN",
                "US"
            ],
            "enableRateLimit": true,
            "rateLimit": 20,
            "certified": false,
            "pro": true,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": true,
                "margin": false,
                "future": true,
                "cancelOrder": true,
                "createLimitOrder": true,
                "createMarketOrder": true,
                "createOrder": true,
                "editOrder": "emulated",
                "fetchBalance": true,
                "fetchClosedOrders": true,
                "fetchCurrencies": true,
                "fetchDepositAddress": true,
                "fetchDeposits": true,
                "fetchL2OrderBook": true,
                "fetchLedger": true,
                "fetchMarkets": true,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrderTrades": true,
                "fetchPosition": true,
                "fetchPositions": true,
                "fetchStatus": "emulated",
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTime": true,
                "fetchTrades": true,
                "fetchWithdrawals": true,
                "transfer": true,
                "withdraw": true
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/51840849/87295551-102fbf00-c50e-11ea-90a9-462eebba5829.jpg",
                "api": {
                    "rest": "https://www.{hostname}"
                },
                "www": "https://www.okcoin.com",
                "doc": "https://www.okcoin.com/docs/en/",
                "fees": "https://www.okcoin.com/coin-fees",
                "referral": "https://www.okcoin.com/account/register?flag=activity&channelId=600001513",
                "test": {
                    "rest": "https://testnet.okex.com"
                }
            },
            "api": {
                "general": {
                    "get": {
                        "time": 8.3334
                    }
                },
                "account": {
                    "get": {
                        "wallet": 8.3334,
                        "sub-account": 1000,
                        "asset-valuation": 1000,
                        "wallet/{currency}": 8.3334,
                        "withdrawal/history": 8.3334,
                        "withdrawal/history/{currency}": 8.3334,
                        "ledger": 5,
                        "deposit/address": 8.3334,
                        "deposit/history": 8.3334,
                        "deposit/history/{currency}": 8.3334,
                        "currencies": 8.3334,
                        "withdrawal/fee": 8.3334,
                        "deposit-lightning": 50,
                        "withdrawal-lightning": 50,
                        "fiat/deposit/detail": 5,
                        "fiat/deposit/details": 8.3334,
                        "fiat/withdraw/detail": 5,
                        "fiat/withdraw/details": 8.3334,
                        "fiat/channel": 8.3334
                    },
                    "post": {
                        "transfer": 100,
                        "withdrawal": 8.3334,
                        "fiat/cancel_deposit": 1,
                        "fiat/deposit": 8.3334,
                        "fiat/withdraw": 8.3334,
                        "fiat/cancel_withdrawal": 1
                    }
                },
                "otc": {
                    "get": {
                        "rfq/instruments": 50,
                        "rfq/trade": 50,
                        "rfq/history": 50
                    },
                    "post": {
                        "rfq/quote": 50,
                        "rfq/trade": 50
                    }
                },
                "users": {
                    "get": {
                        "subaccount-info": 20,
                        "account-info": 20,
                        "subaccount/apikey": 20
                    },
                    "post": {
                        "create-subaccount": 5,
                        "delete-subaccount": 5,
                        "subaccount/apikey": 50,
                        "subacount/delete-apikey": 20,
                        "subacount/modify-apikey": 20
                    }
                },
                "earning": {
                    "get": {
                        "offers": 5,
                        "orders": 5,
                        "positions": 8.3334
                    },
                    "post": {
                        "purchase": 5,
                        "redeem": 5,
                        "cancel": 5
                    }
                },
                "spot": {
                    "get": {
                        "accounts": 5,
                        "accounts/{currency}": 5,
                        "accounts/{currency}/ledger": 5,
                        "orders": 10,
                        "orders_pending": 5,
                        "orders/{order_id}": 5,
                        "orders/{client_oid}": 5,
                        "trade_fee": 5,
                        "fills": 10,
                        "algo": 5,
                        "instruments": 5,
                        "instruments/{instrument_id}/book": 5,
                        "instruments/ticker": 5,
                        "instruments/{instrument_id}/ticker": 5,
                        "instruments/{instrument_id}/trades": 5,
                        "instruments/{instrument_id}/candles": 5
                    },
                    "post": {
                        "order_algo": 2.5,
                        "orders": 1,
                        "batch_orders": 2,
                        "cancel_orders/{order_id}": 1,
                        "cancel_orders/{client_oid}": 1,
                        "cancel_batch_algos": 5,
                        "cancel_batch_orders": 5,
                        "amend_order/{instrument_id}": 2.5,
                        "amend_batch_orders": 5
                    }
                },
                "margin": {
                    "get": {
                        "accounts": 5,
                        "accounts/{instrument_id}": 5,
                        "accounts/{instrument_id}/ledger": 5,
                        "accounts/availability": 5,
                        "accounts/{instrument_id}/availability": 5,
                        "accounts/borrowed": 5,
                        "accounts/{instrument_id}/borrowed": 5,
                        "orders": 10,
                        "accounts/{instrument_id}/leverage": 1,
                        "orders/{order_id}": 5,
                        "orders/{client_oid}": 5,
                        "orders_pending": 5,
                        "fills": 10,
                        "instruments/{instrument_id}/mark_price": 5
                    },
                    "post": {
                        "accounts/borrow": 1,
                        "accounts/repayment": 1,
                        "orders": 1,
                        "batch_orders": 2,
                        "cancel_orders": 1,
                        "cancel_orders/{order_id}": 1,
                        "cancel_orders/{client_oid}": 1,
                        "cancel_batch_orders": 2,
                        "amend_order/{instrument_id}": 2.5,
                        "amend_batch_orders": 5,
                        "accounts/{instrument_id}/leverage": 1
                    }
                },
                "system": {
                    "get": {
                        "status": 250
                    }
                },
                "market": {
                    "get": {
                        "oracle": 250
                    }
                },
                "futures": {
                    "get": [
                        "position",
                        "{instrument_id}/position",
                        "accounts",
                        "accounts/{underlying}",
                        "accounts/{underlying}/leverage",
                        "accounts/{underlying}/ledger",
                        "order_algo/{instrument_id}",
                        "orders/{instrument_id}",
                        "orders/{instrument_id}/{order_id}",
                        "orders/{instrument_id}/{client_oid}",
                        "fills",
                        "trade_fee",
                        "accounts/{instrument_id}/holds",
                        "order_algo/{instrument_id}",
                        "instruments",
                        "instruments/{instrument_id}/book",
                        "instruments/ticker",
                        "instruments/{instrument_id}/ticker",
                        "instruments/{instrument_id}/trades",
                        "instruments/{instrument_id}/candles",
                        "instruments/{instrument_id}/history/candles",
                        "instruments/{instrument_id}/index",
                        "rate",
                        "instruments/{instrument_id}/estimated_price",
                        "instruments/{instrument_id}/open_interest",
                        "instruments/{instrument_id}/price_limit",
                        "instruments/{instrument_id}/mark_price",
                        "instruments/{instrument_id}/liquidation"
                    ],
                    "post": [
                        "accounts/{underlying}/leverage",
                        "order",
                        "amend_order/{instrument_id}",
                        "orders",
                        "cancel_order/{instrument_id}/{order_id}",
                        "cancel_order/{instrument_id}/{client_oid}",
                        "cancel_batch_orders/{instrument_id}",
                        "accounts/margin_mode",
                        "close_position",
                        "cancel_all",
                        "order_algo",
                        "cancel_algos"
                    ]
                },
                "swap": {
                    "get": [
                        "position",
                        "{instrument_id}/position",
                        "accounts",
                        "{instrument_id}/accounts",
                        "accounts/{instrument_id}/settings",
                        "accounts/{instrument_id}/ledger",
                        "orders/{instrument_id}",
                        "orders/{instrument_id}/{order_id}",
                        "orders/{instrument_id}/{client_oid}",
                        "fills",
                        "accounts/{instrument_id}/holds",
                        "trade_fee",
                        "order_algo/{instrument_id}",
                        "instruments",
                        "instruments/{instrument_id}/depth",
                        "instruments/ticker",
                        "instruments/{instrument_id}/ticker",
                        "instruments/{instrument_id}/trades",
                        "instruments/{instrument_id}/candles",
                        "instruments/{instrument_id}/history/candles",
                        "instruments/{instrument_id}/index",
                        "rate",
                        "instruments/{instrument_id}/open_interest",
                        "instruments/{instrument_id}/price_limit",
                        "instruments/{instrument_id}/liquidation",
                        "instruments/{instrument_id}/funding_time",
                        "instruments/{instrument_id}/mark_price",
                        "instruments/{instrument_id}/historical_funding_rate"
                    ],
                    "post": [
                        "accounts/{instrument_id}/leverage",
                        "order",
                        "amend_order/{instrument_id}",
                        "orders",
                        "cancel_order/{instrument_id}/{order_id}",
                        "cancel_order/{instrument_id}/{client_oid}",
                        "cancel_batch_orders/{instrument_id}",
                        "order_algo",
                        "cancel_algos",
                        "close_position",
                        "cancel_all",
                        "order_algo",
                        "cancel_algos"
                    ]
                },
                "option": {
                    "get": [
                        "accounts",
                        "position",
                        "{underlying}/position",
                        "accounts/{underlying}",
                        "orders/{underlying}",
                        "fills/{underlying}",
                        "accounts/{underlying}/ledger",
                        "trade_fee",
                        "orders/{underlying}/{order_id}",
                        "orders/{underlying}/{client_oid}",
                        "underlying",
                        "instruments/{underlying}",
                        "instruments/{underlying}/summary",
                        "instruments/{underlying}/summary/{instrument_id}",
                        "instruments/{instrument_id}/book",
                        "instruments/{instrument_id}/trades",
                        "instruments/{instrument_id}/ticker",
                        "instruments/{instrument_id}/candles"
                    ],
                    "post": [
                        "order",
                        "orders",
                        "cancel_order/{underlying}/{order_id}",
                        "cancel_order/{underlying}/{client_oid}",
                        "cancel_batch_orders/{underlying}",
                        "amend_order/{underlying}",
                        "amend_batch_orders/{underlying}"
                    ]
                },
                "information": {
                    "get": [
                        "{currency}/long_short_ratio",
                        "{currency}/volume",
                        "{currency}/taker",
                        "{currency}/sentiment",
                        "{currency}/margin"
                    ]
                },
                "index": {
                    "get": [
                        "{instrument_id}/constituents"
                    ]
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": true,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "60",
                "3m": "180",
                "5m": "300",
                "15m": "900",
                "30m": "1800",
                "1h": "3600",
                "2h": "7200",
                "4h": "14400",
                "6h": "21600",
                "12h": "43200",
                "1d": "86400",
                "1w": "604800",
                "1M": "2678400",
                "3M": "8035200",
                "6M": "16070400",
                "1y": "31536000"
            },
            "fees": {
                "trading": {
                    "taker": 0.002,
                    "maker": 0.001
                },
                "funding": {
                    "withdraw": {},
                    "deposit": {}
                },
                "spot": {
                    "taker": 0.0015,
                    "maker": 0.001
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "exact": {},
                "broad": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCH",
                "BCHSV": "BSV",
                "AE": "AET",
                "BOX": "DefiBox",
                "HOT": "Hydro Protocol",
                "HSR": "HC",
                "MAG": "Maggie",
                "SBTC": "Super Bitcoin",
                "TRADE": "Unitrade",
                "YOYO": "YOYOW",
                "WIN": "WinToken"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "version": "v3",
            "hostname": "okcoin.com",
            "options": {
                "fetchOHLCV": {
                    "type": "Candles"
                },
                "createMarketBuyOrderRequiresPrice": true,
                "fetchMarkets": [
                    "spot"
                ],
                "defaultType": "spot",
                "accountsByType": {
                    "spot": "1",
                    "funding": "6"
                },
                "accountsById": {
                    "1": "spot",
                    "6": "funding"
                },
                "auth": {
                    "time": "public",
                    "currencies": "private",
                    "instruments": "public",
                    "rate": "public",
                    "{instrument_id}/constituents": "public"
                },
                "warnOnFetchCurrenciesWithoutAuthorization": false
            }
        }"###).unwrap())
    }

    /// Returns the current integer timestamp in milliseconds from the exchange server
    ///
    /// Fetches the current integer timestamp in milliseconds from the exchange server
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_time(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Okcoin::dispatch(self, "generalGetTime".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "iso": "2015-01-07T23:47:25.201Z",
        //         "epoch": 1420674445.201
        //     }
        //
        return self.parse8601(self.safe_string(response.clone(), Value::from("iso"), Value::Undefined));
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for okcoin
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut types: Value = self.safe_value(self.get("options".into()), Value::from("fetchMarkets"), Value::Undefined);
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < types.len() {
            let mut markets: Value = Okcoin::fetch_markets_by_type(self, types.get(i.into()), params.clone()).await;
            result = self.array_concat(result.clone(), markets.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_markets(&self, mut markets: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < markets.len() {
            result.push(Okcoin::parse_market(self, markets.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_market(&self, mut market: Value) -> Value {
        //
        // spot markets
        //
        //     {
        //         base_currency: "EOS",
        //         instrument_id: "EOS-OKB",
        //         min_size: "0.01",
        //         quote_currency: "OKB",
        //         size_increment: "0.000001",
        //         tick_size: "0.0001"
        //     }
        //
        // futures markets
        //
        //     {
        //         instrument_id: "XRP-USD-200320",
        //         underlying_index: "XRP",
        //         quote_currency: "USD",
        //         tick_size: "0.0001",
        //         contract_val: "10",
        //         listing: "2020-03-06",
        //         delivery: "2020-03-20",
        //         trade_increment: "1",
        //         alias: "this_week",
        //         underlying: "XRP-USD",
        //         base_currency: "XRP",
        //         settlement_currency: "XRP",
        //         is_inverse: "true",
        //         contract_val_currency: "USD",
        //     }
        //
        // swap markets
        //
        //     {
        //         instrument_id: "BSV-USD-SWAP",
        //         underlying_index: "BSV",
        //         quote_currency: "USD",
        //         coin: "BSV",
        //         contract_val: "10",
        //         listing: "2018-12-21T07:53:47.000Z",
        //         delivery: "2020-03-14T08:00:00.000Z",
        //         size_increment: "1",
        //         tick_size: "0.01",
        //         base_currency: "BSV",
        //         underlying: "BSV-USD",
        //         settlement_currency: "BSV",
        //         is_inverse: "true",
        //         contract_val_currency: "USD"
        //     }
        //
        // options markets
        //
        //     {
        //         instrument_id: 'BTC-USD-200327-4000-C',
        //         underlying: 'BTC-USD',
        //         settlement_currency: 'BTC',
        //         contract_val: '0.1000',
        //         option_type: 'C',
        //         strike: '4000',
        //         tick_size: '0.0005',
        //         lot_size: '1.0000',
        //         listing: '2019-12-25T08:30:36.302Z',
        //         delivery: '2020-03-27T08:00:00.000Z',
        //         state: '2',
        //         trading_start_time: '2019-12-25T08:30:36.302Z',
        //         timestamp: '2020-03-13T08:05:09.456Z',
        //     }
        //
        let mut id: Value = self.safe_string(market.clone(), Value::from("instrument_id"), Value::Undefined);
        let mut option_type: Value = self.safe_value(market.clone(), Value::from("option_type"), Value::Undefined);
        let mut contract_val: Value = Okcoin::safe_number(self, market.clone(), Value::from("contract_val"), Value::Undefined);
        let mut contract: Value = (contract_val.clone().is_nonnullish()).into();
        let mut futures_alias: Value = self.safe_string(market.clone(), Value::from("alias"), Value::Undefined);
        let mut market_type: Value = Value::from("spot");
        let mut spot: Value = (!contract.is_truthy()).into();
        let mut option: Value = (option_type.clone().is_nonnullish()).into();
        let mut future: Value = (!option.is_truthy() && futures_alias.clone().is_nonnullish()).into();
        let mut swap: Value = (contract.is_truthy() && !future.is_truthy() && !option.is_truthy()).into();
        let mut base_id: Value = self.safe_string(market.clone(), Value::from("base_currency"), Value::Undefined);
        let mut quote_id: Value = self.safe_string(market.clone(), Value::from("quote_currency"), Value::Undefined);
        let mut settle_id: Value = self.safe_string(market.clone(), Value::from("settlement_currency"), Value::Undefined);
        if option.is_truthy() {
            let mut underlying: Value = self.safe_string(market.clone(), Value::from("underlying"), Value::Undefined);
            let mut parts: Value = underlying.split(Value::from("-"));
            base_id = self.safe_string(parts.clone(), Value::from(0), Value::Undefined);
            quote_id = self.safe_string(parts.clone(), Value::from(1), Value::Undefined);
            market_type = Value::from("option");
        } else if future.is_truthy() {
            base_id = self.safe_string(market.clone(), Value::from("underlying_index"), Value::Undefined);
            market_type = Value::from("futures");
        } else if swap.is_truthy() {
            market_type = Value::from("swap");
        };
        let mut base: Value = Okcoin::safe_currency_code(self, base_id.clone(), Value::Undefined);
        let mut quote: Value = Okcoin::safe_currency_code(self, quote_id.clone(), Value::Undefined);
        let mut settle: Value = Okcoin::safe_currency_code(self, settle_id.clone(), Value::Undefined);
        let mut symbol: Value = base.clone() + Value::from("/") + quote.clone();
        let mut expiry_datetime: Value = self.safe_string(market.clone(), Value::from("delivery"), Value::Undefined);
        let mut expiry: Value = Value::Undefined;
        let mut strike: Value = self.safe_value(market.clone(), Value::from("strike"), Value::Undefined);
        if contract.is_truthy() {
            symbol = symbol.clone() + Value::from(":") + settle.clone();
            if future.is_truthy() || option.is_truthy() {
                if future.is_truthy() {
                    expiry_datetime = expiry_datetime +  Value::from("T00:00:00Z");
                };
                expiry = self.parse8601(expiry_datetime.clone());
                symbol = symbol.clone() + Value::from("-") + self.yymmdd(expiry.clone(), Value::Undefined);
                if option.is_truthy() {
                    symbol = symbol.clone() + Value::from(":") + strike.clone() + Value::from(":") + option_type.clone();
                    option_type = if option_type.clone() == Value::from("C") { Value::from("call") } else { Value::from("put") };
                };
            };
        };
        let mut lot_size: Value = Okcoin::safe_number_2(self, market.clone(), Value::from("lot_size"), Value::from("trade_increment"), Value::Undefined);
        let mut min_price: Value = self.safe_string(market.clone(), Value::from("tick_size"), Value::Undefined);
        let mut min_amount_string: Value = self.safe_string_2(market.clone(), Value::from("min_size"), Value::from("base_min_size"), Value::Undefined);
        let mut min_amount: Value = self.parse_number(min_amount_string.clone(), Value::Undefined);
        let mut min_cost: Value = Value::Undefined;
        if min_amount.clone().is_nonnullish() && min_price.clone().is_nonnullish() {
            min_cost = self.parse_number(Precise::string_mul(min_price.clone(), min_amount_string.clone()), Value::Undefined);
        };
        let mut fees: Value = self.safe_value_2(self.get("fees".into()), market_type.clone(), Value::from("trading"), Value::new_object());
        let mut max_leverage_string: Value = self.safe_string(market.clone(), Value::from("max_leverage"), Value::from("1"));
        let mut max_leverage: Value = self.parse_number(Precise::string_max(max_leverage_string.clone(), Value::from("1")), Value::Undefined);
        let mut precision_price: Value = self.parse_number(min_price.clone(), Value::Undefined);
        return extend_2(fees.clone(), Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "symbol": symbol,
            "base": base,
            "quote": quote,
            "settle": settle,
            "baseId": base_id,
            "quoteId": quote_id,
            "settleId": settle_id,
            "type": market_type,
            "spot": spot,
            "margin": false,
            "swap": swap,
            "future": future,
            "futures": future,
            "option": option,
            "active": true,
            "contract": contract,
            "linear": if contract.is_truthy() { (quote.clone() == settle.clone()).into() } else { Value::Undefined },
            "inverse": if contract.is_truthy() { (base.clone() == settle.clone()).into() } else { Value::Undefined },
            "contractSize": contract_val,
            "expiry": expiry,
            "expiryDatetime": self.iso8601(expiry.clone()),
            "strike": strike,
            "optionType": option_type,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Okcoin::safe_number(self, market.clone(), Value::from("size_increment"), lot_size.clone()),
                "price": precision_price
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "leverage": Value::Json(normalize(&Value::Json(json!({
                    "min": self.parse_number(Value::from("1"), Value::Undefined),
                    "max": self.parse_number(max_leverage.clone(), Value::Undefined)
                }))).unwrap()),
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": min_amount,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": precision_price,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": min_cost,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": market
        }))).unwrap()));
    }

    async fn fetch_markets_by_type(&mut self, mut r#type: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if r#type.clone() == Value::from("option") {
            let mut underlying: Value = Okcoin::dispatch(self, "optionGetUnderlying".into(), params.clone(), Value::Undefined).await;
            let mut result: Value = Value::new_array();
            let mut i: usize = 0;
            while i < underlying.len() {
                let mut response: Value = Okcoin::dispatch(self, "optionGetInstrumentsUnderlying".into(), Value::Json(normalize(&Value::Json(json!({
                    "underlying": underlying.get(i.into())
                }))).unwrap()), Value::Undefined).await;
                //
                // options markets
                //
                //     [
                //         {
                //             instrument_id: 'BTC-USD-200327-4000-C',
                //             underlying: 'BTC-USD',
                //             settlement_currency: 'BTC',
                //             contract_val: '0.1000',
                //             option_type: 'C',
                //             strike: '4000',
                //             tick_size: '0.0005',
                //             lot_size: '1.0000',
                //             listing: '2019-12-25T08:30:36.302Z',
                //             delivery: '2020-03-27T08:00:00.000Z',
                //             state: '2',
                //             trading_start_time: '2019-12-25T08:30:36.302Z',
                //             timestamp: '2020-03-13T08:05:09.456Z',
                //         },
                //     ]
                //
                result = self.array_concat(result.clone(), response.clone());
                i += 1;
            };
            return Okcoin::parse_markets(self, result.clone());
        } else if r#type.clone() == Value::from("spot") || r#type.clone() == Value::from("futures") || r#type.clone() == Value::from("swap") {
            let mut method: Value = r#type.clone() + Value::from("GetInstruments");
            let mut response: Value = Okcoin::dispatch(self, method, params.clone(), Value::Undefined).await;
            //
            // spot markets
            //
            //     [
            //         {
            //             base_currency: "EOS",
            //             instrument_id: "EOS-OKB",
            //             min_size: "0.01",
            //             quote_currency: "OKB",
            //             size_increment: "0.000001",
            //             tick_size: "0.0001"
            //         }
            //     ]
            //
            // futures markets
            //
            //     [
            //         {
            //             instrument_id: "XRP-USD-200320",
            //             underlying_index: "XRP",
            //             quote_currency: "USD",
            //             tick_size: "0.0001",
            //             contract_val: "10",
            //             listing: "2020-03-06",
            //             delivery: "2020-03-20",
            //             trade_increment: "1",
            //             alias: "this_week",
            //             underlying: "XRP-USD",
            //             base_currency: "XRP",
            //             settlement_currency: "XRP",
            //             is_inverse: "true",
            //             contract_val_currency: "USD",
            //         }
            //     ]
            //
            // swap markets
            //
            //     [
            //         {
            //             instrument_id: "BSV-USD-SWAP",
            //             underlying_index: "BSV",
            //             quote_currency: "USD",
            //             coin: "BSV",
            //             contract_val: "10",
            //             listing: "2018-12-21T07:53:47.000Z",
            //             delivery: "2020-03-14T08:00:00.000Z",
            //             size_increment: "1",
            //             tick_size: "0.01",
            //             base_currency: "BSV",
            //             underlying: "BSV-USD",
            //             settlement_currency: "BSV",
            //             is_inverse: "true",
            //             contract_val_currency: "USD"
            //         }
            //     ]
            //
            return Okcoin::parse_markets(self, response.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketsByType() does not support market type ") + r#type.clone())"###);
        };
        Value::Undefined
    }

    /// Returns an associative dictionary of currencies
    ///
    /// Fetches all available currencies on an exchange
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // despite that their docs say these endpoints are public:
        //     https://www.okex.com/api/account/v3/withdrawal/fee
        //     https://www.okex.com/api/account/v3/currencies
        // it will still reply with { "code":30001, "message": "OK-ACCESS-KEY header is required" }
        // if you attempt to access it without authentication
        if !Okcoin::check_required_credentials(self, false.into()).is_truthy() {
            if self.get("options".into()).get(Value::from("warnOnFetchCurrenciesWithoutAuthorization")).is_truthy() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" fetchCurrencies() is a private API endpoint that requires authentication with API keys. Set the API keys on the exchange instance or exchange.options["warnOnFetchCurrenciesWithoutAuthorization"] = false to suppress this warning message."#))"###);
            };
            return Value::Undefined;
        } else {
            let mut response: Value = Okcoin::dispatch(self, "accountGetCurrencies".into(), params.clone(), Value::Undefined).await;
            //
            //     [
            //         {
            //             name: '',
            //             currency: 'BTC',
            //             can_withdraw: '1',
            //             can_deposit: '1',
            //             min_withdrawal: '0.0100000000000000'
            //         },
            //     ]
            //
            let mut result: Value = Value::new_object();
            let mut i: usize = 0;
            while i < response.len() {
                let mut currency: Value = response.get(i.into());
                let mut id: Value = self.safe_string(currency.clone(), Value::from("currency"), Value::Undefined);
                let mut code: Value = Okcoin::safe_currency_code(self, id.clone(), Value::Undefined);
                let mut name: Value = self.safe_string(currency.clone(), Value::from("name"), Value::Undefined);
                let mut can_deposit: Value = self.safe_integer(currency.clone(), Value::from("can_deposit"), Value::Undefined);
                let mut can_withdraw: Value = self.safe_integer(currency.clone(), Value::from("can_withdraw"), Value::Undefined);
                let mut deposit_enabled: Value = (can_deposit.clone() == Value::from(1)).into();
                let mut withdraw_enabled: Value = (can_withdraw.clone() == Value::from(1)).into();
                let mut active: Value = if can_deposit.is_truthy() && can_withdraw.is_truthy() { true.into() } else { false.into() };
                result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                    "id": id,
                    "code": code,
                    "info": currency,
                    "type": Value::Undefined,
                    "name": name,
                    "active": active,
                    "deposit": deposit_enabled,
                    "withdraw": withdraw_enabled,
                    "fee": Value::Undefined,
                    "precision": self.parse_number(Value::from("0.00000001"), Value::Undefined),
                    "limits": Value::Json(normalize(&Value::Json(json!({
                        "amount": Value::Json(normalize(&Value::Json(json!({
                            "min": Value::Undefined,
                            "max": Value::Undefined
                        }))).unwrap()),
                        "withdraw": Value::Json(normalize(&Value::Json(json!({
                            "min": Okcoin::safe_number(self, currency.clone(), Value::from("min_withdrawal"), Value::Undefined),
                            "max": Value::Undefined
                        }))).unwrap())
                    }))).unwrap())
                }))).unwrap()));
                i += 1;
            };
            // todo: redesign
            return result.clone();
        };
        Value::Undefined
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okcoin::market(self, symbol.clone());
        let mut method: Value = market.get(Value::from("type")) + Value::from("GetInstrumentsInstrumentId");
        method = method +  if market.get(Value::from("type")) == Value::from("swap") { Value::from("Depth") } else { Value::from("Book") };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instrument_id": market.get(Value::from("id"))
        }))).unwrap());
        if limit.clone().is_nonnullish() {
            request.set("size".into(), limit.clone());
        };
        // max 200
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {      asks: [ ["0.02685268", "0.242571", "1"],
        //                    ["0.02685493", "0.164085", "1"],
        //                    ...
        //                    ["0.02779", "1.039", "1"],
        //                    ["0.027813", "0.0876", "1"]        ],
        //            bids: [ ["0.02684052", "10.371849", "1"],
        //                    ["0.02684051", "3.707", "4"],
        //                    ...
        //                    ["0.02634963", "0.132934", "1"],
        //                    ["0.02634962", "0.264838", "2"]    ],
        //       timestamp:   "2018-12-17T20:24:16.159Z"            }
        //
        // swap
        //
        //     {
        //         "asks":[
        //             ["916.21","94","0","1"]
        //         ],
        //         "bids":[
        //             ["916.1","15","0","1"]
        //         ],
        //         "time":"2021-04-16T02:04:48.282Z"
        //     }
        //
        let mut timestamp: Value = self.parse8601(self.safe_string_2(response.clone(), Value::from("timestamp"), Value::from("time"), Value::Undefined));
        return Okcoin::parse_order_book(self, response.clone(), symbol.clone(), timestamp.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        //
        //     {         best_ask: "0.02665472",
        //               best_bid: "0.02665221",
        //          instrument_id: "ETH-BTC",
        //             product_id: "ETH-BTC",
        //                   last: "0.02665472",
        //                    ask: "0.02665472", // missing in the docs
        //                    bid: "0.02665221", // not mentioned in the docs
        //               open_24h: "0.02645482",
        //               high_24h: "0.02714633",
        //                low_24h: "0.02614109",
        //        base_volume_24h: "572298.901923",
        //              timestamp: "2018-12-17T21:20:07.856Z",
        //       quote_volume_24h: "15094.86831261"            }
        //
        let mut timestamp: Value = self.parse8601(self.safe_string(ticker.clone(), Value::from("timestamp"), Value::Undefined));
        let mut market_id: Value = self.safe_string(ticker.clone(), Value::from("instrument_id"), Value::Undefined);
        market = Okcoin::safe_market(self, market_id.clone(), market.clone(), Value::from("-"));
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut last: Value = self.safe_string(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut open: Value = self.safe_string(ticker.clone(), Value::from("open_24h"), Value::Undefined);
        return Okcoin::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "high": self.safe_string(ticker.clone(), Value::from("high_24h"), Value::Undefined),
            "low": self.safe_string(ticker.clone(), Value::from("low_24h"), Value::Undefined),
            "bid": self.safe_string(ticker.clone(), Value::from("best_bid"), Value::Undefined),
            "bidVolume": self.safe_string(ticker.clone(), Value::from("best_bid_size"), Value::Undefined),
            "ask": self.safe_string(ticker.clone(), Value::from("best_ask"), Value::Undefined),
            "askVolume": self.safe_string(ticker.clone(), Value::from("best_ask_size"), Value::Undefined),
            "vwap": Value::Undefined,
            "open": open,
            "close": last,
            "last": last,
            "previousClose": Value::Undefined,
            "change": Value::Undefined,
            "percentage": Value::Undefined,
            "average": Value::Undefined,
            "baseVolume": self.safe_string(ticker.clone(), Value::from("base_volume_24h"), Value::Undefined),
            "quoteVolume": self.safe_string(ticker.clone(), Value::from("quote_volume_24h"), Value::Undefined),
            "info": ticker
        }))).unwrap()), market.clone());
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okcoin::market(self, symbol.clone());
        let mut method: Value = market.get(Value::from("type")) + Value::from("GetInstrumentsInstrumentIdTicker");
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instrument_id": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {         best_ask: "0.02665472",
        //               best_bid: "0.02665221",
        //          instrument_id: "ETH-BTC",
        //             product_id: "ETH-BTC",
        //                   last: "0.02665472",
        //                    ask: "0.02665472",
        //                    bid: "0.02665221",
        //               open_24h: "0.02645482",
        //               high_24h: "0.02714633",
        //                low_24h: "0.02614109",
        //        base_volume_24h: "572298.901923",
        //              timestamp: "2018-12-17T21:20:07.856Z",
        //       quote_volume_24h: "15094.86831261"            }
        //
        return Okcoin::parse_ticker(self, response.clone(), Value::Undefined);
    }

    async fn fetch_tickers_by_type(&mut self, mut r#type: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Okcoin::market_symbols(self, symbols.clone());
        let mut method: Value = r#type.clone() + Value::from("GetInstrumentsTicker");
        let mut response: Value = Okcoin::dispatch(self, method, params.clone(), Value::Undefined).await;
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut ticker: Value = Okcoin::parse_ticker(self, response.get(i.into()), Value::Undefined);
            let mut symbol: Value = ticker.get(Value::from("symbol"));
            result.set(symbol.clone(), ticker.clone());
            i += 1;
        };
        return Okcoin::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchTickers"), Value::from("defaultType"), Value::Undefined);
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        symbols = Okcoin::market_symbols(self, symbols.clone());
        return Okcoin::fetch_tickers_by_type(self, r#type.clone(), symbols.clone(), self.omit(params.clone(), Value::from("type"))).await;
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        //
        // fetchTrades (public)
        //
        //     spot trades
        //
        //         {
        //             time: "2018-12-17T23:31:08.268Z",
        //             timestamp: "2018-12-17T23:31:08.268Z",
        //             trade_id: "409687906",
        //             price: "0.02677805",
        //             size: "0.923467",
        //             side: "sell"
        //         }
        //
        //     futures trades, swap trades
        //
        //         {
        //             trade_id: "1989230840021013",
        //             side: "buy",
        //             price: "92.42",
        //             qty: "184", // missing in swap markets
        //             size: "5", // missing in futures markets
        //             timestamp: "2018-12-17T23:26:04.613Z"
        //         }
        //
        // fetchOrderTrades (private)
        //
        //     spot trades
        //
        //         {
        //             "created_at":"2019-03-15T02:52:56.000Z",
        //             "exec_type":"T", // whether the order is taker or maker
        //             "fee":"0.00000082",
        //             "instrument_id":"BTC-USDT",
        //             "ledger_id":"3963052721",
        //             "liquidity":"T", // whether the order is taker or maker
        //             "order_id":"2482659399697408",
        //             "price":"3888.6",
        //             "product_id":"BTC-USDT",
        //             "side":"buy",
        //             "size":"0.00055306",
        //             "timestamp":"2019-03-15T02:52:56.000Z"
        //         },
        //
        //     futures trades, swap trades
        //
        //         {
        //             "trade_id":"197429674631450625",
        //             "instrument_id":"EOS-USD-SWAP",
        //             "order_id":"6a-7-54d663a28-0",
        //             "price":"3.633",
        //             "order_qty":"1.0000",
        //             "fee":"-0.000551",
        //             "created_at":"2019-03-21T04:41:58.0Z", // missing in swap trades
        //             "timestamp":"2019-03-25T05:56:31.287Z", // missing in futures trades
        //             "exec_type":"M", // whether the order is taker or maker
        //             "side":"short", // "buy" in futures trades
        //         }
        //
        let mut symbol: Value = Value::Undefined;
        let mut market_id: Value = self.safe_string(trade.clone(), Value::from("instrument_id"), Value::Undefined);
        let mut base: Value = Value::Undefined;
        let mut quote: Value = Value::Undefined;
        if self.get("markets_by_id".into()).contains_key(market_id.clone()) {
            market = self.get("markets_by_id".into()).get(market_id.clone());
            symbol = market.get(Value::from("symbol"));
            base = market.get(Value::from("base"));
            quote = market.get(Value::from("quote"));
        } else if market_id.clone().is_nonnullish() {
            let mut parts: Value = market_id.split(Value::from("-"));
            let mut num_parts: Value = parts.len().into();
            if num_parts.clone() == Value::from(2) {
                let (mut base_id, mut quote_id) = shift_2(parts.clone());
                base = Okcoin::safe_currency_code(self, base_id.clone(), Value::Undefined);
                quote = Okcoin::safe_currency_code(self, quote_id.clone(), Value::Undefined);
                symbol = base.clone() + Value::from("/") + quote.clone();
            } else {
                symbol = market_id.clone();
            };
        };
        if symbol.clone().is_nullish() && market.clone().is_nonnullish() {
            symbol = market.get(Value::from("symbol"));
            base = market.get(Value::from("base"));
            quote = market.get(Value::from("quote"));
        };
        let mut timestamp: Value = self.parse8601(self.safe_string_2(trade.clone(), Value::from("timestamp"), Value::from("created_at"), Value::Undefined));
        let mut price_string: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut amount_string: Value = self.safe_string_2(trade.clone(), Value::from("size"), Value::from("qty"), Value::Undefined);
        amount_string = self.safe_string(trade.clone(), Value::from("order_qty"), amount_string.clone());
        let mut taker_or_maker: Value = self.safe_string_2(trade.clone(), Value::from("exec_type"), Value::from("liquidity"), Value::Undefined);
        if taker_or_maker.clone() == Value::from("M") {
            taker_or_maker = Value::from("maker");
        } else if taker_or_maker.clone() == Value::from("T") {
            taker_or_maker = Value::from("taker");
        };
        let mut side: Value = self.safe_string(trade.clone(), Value::from("side"), Value::Undefined);
        let mut fee_cost_string: Value = self.safe_string(trade.clone(), Value::from("fee"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        if fee_cost_string.clone().is_nonnullish() {
            let mut fee_currency: Value = if side.clone() == Value::from("buy") { base.clone() } else { quote.clone() };
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": Precise::string_neg(fee_cost_string.clone()),
                "currency": fee_currency
            }))).unwrap());
        };
        // fee is either a positive number (invitation rebate)
        // or a negative number (transaction fee deduction)
        // therefore we need to invert the fee
        // more about it https://github.com/ccxt/ccxt/issues/5909
        let mut order_id: Value = self.safe_string(trade.clone(), Value::from("order_id"), Value::Undefined);
        return Okcoin::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "info": trade,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": symbol,
            "id": self.safe_string_2(trade.clone(), Value::from("trade_id"), Value::from("ledger_id"), Value::Undefined),
            "order": order_id,
            "type": Value::Undefined,
            "takerOrMaker": taker_or_maker,
            "side": side,
            "price": price_string,
            "amount": amount_string,
            "cost": Value::Undefined,
            "fee": fee
        }))).unwrap()), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okcoin::market(self, symbol.clone());
        let mut method: Value = market.get(Value::from("type")) + Value::from("GetInstrumentsInstrumentIdTrades");
        if limit.clone().is_nullish() || limit.clone() > Value::from(100) {
            limit = Value::from(100);
        };
        // maximum = default = 100
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instrument_id": market.get(Value::from("id")),
            "limit": limit
        }))).unwrap());
        // from: 'id',
        // to: 'id',
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot markets
        //
        //     [
        //         {
        //             time: "2018-12-17T23:31:08.268Z",
        //             timestamp: "2018-12-17T23:31:08.268Z",
        //             trade_id: "409687906",
        //             price: "0.02677805",
        //             size: "0.923467",
        //             side: "sell"
        //         }
        //     ]
        //
        // futures markets, swap markets
        //
        //     [
        //         {
        //             trade_id: "1989230840021013",
        //             side: "buy",
        //             price: "92.42",
        //             qty: "184", // missing in swap markets
        //             size: "5", // missing in futures markets
        //             timestamp: "2018-12-17T23:26:04.613Z"
        //         }
        //     ]
        //
        return Okcoin::parse_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        //
        // spot markets
        //
        //     {
        //         close: "0.02684545",
        //         high: "0.02685084",
        //         low: "0.02683312",
        //         open: "0.02683894",
        //         time: "2018-12-17T20:28:00.000Z",
        //         volume: "101.457222"
        //     }
        //
        // futures markets
        //
        //     [
        //         1545072720000,
        //         0.3159,
        //         0.3161,
        //         0.3144,
        //         0.3149,
        //         22886,
        //         725179.26172331,
        //     ]
        //
        if Array::is_array(ohlcv.clone()).is_truthy() {
            let mut num_elements: Value = ohlcv.len().into();
            let mut volume_index: Value = if num_elements.clone() > Value::from(6) { Value::from(6) } else { Value::from(5) };
            let mut timestamp: Value = self.safe_value(ohlcv.clone(), Value::from(0), Value::Undefined);
            if timestamp.typeof_() == Value::from("string") {
                timestamp = self.parse8601(timestamp.clone());
            };
            return Value::Json(serde_json::Value::Array(vec![timestamp.clone().into(), Okcoin::safe_number(self, ohlcv.clone(), Value::from(1), Value::Undefined).into(), Okcoin::safe_number(self, ohlcv.clone(), Value::from(2), Value::Undefined).into(), Okcoin::safe_number(self, ohlcv.clone(), Value::from(3), Value::Undefined).into(), Okcoin::safe_number(self, ohlcv.clone(), Value::from(4), Value::Undefined).into(), Okcoin::safe_number(self, ohlcv.clone(), volume_index.clone(), Value::Undefined).into()]));
        } else {
            // timestamp
            // Open
            // High
            // Low
            // Close
            // this.safeNumber (ohlcv, 5),         // Quote Volume
            // this.safeNumber (ohlcv, 6),         // Base Volume
            // Volume, okex will return base volume in the 7th element for future markets
            return Value::Json(serde_json::Value::Array(vec![self.parse8601(self.safe_string(ohlcv.clone(), Value::from("time"), Value::Undefined)).into(), Okcoin::safe_number(self, ohlcv.clone(), Value::from("open"), Value::Undefined).into(), Okcoin::safe_number(self, ohlcv.clone(), Value::from("high"), Value::Undefined).into(), Okcoin::safe_number(self, ohlcv.clone(), Value::from("low"), Value::Undefined).into(), Okcoin::safe_number(self, ohlcv.clone(), Value::from("close"), Value::Undefined).into(), Okcoin::safe_number(self, ohlcv.clone(), Value::from("volume"), Value::Undefined).into()]));
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okcoin::market(self, symbol.clone());
        let mut duration: Value = self.parse_timeframe(timeframe.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instrument_id": market.get(Value::from("id")),
            "granularity": self.get("timeframes".into()).get(timeframe.clone())
        }))).unwrap());
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchOHLCV"), Value::new_object());
        let mut default_type: Value = self.safe_string(options.clone(), Value::from("type"), Value::from("Candles"));
        // Candles or HistoryCandles
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        params = self.omit(params.clone(), Value::from("type"));
        let mut method: Value = market.get(Value::from("type")) + Value::from("GetInstrumentsInstrumentId") + r#type.clone();
        if r#type.clone() == Value::from("Candles") {
            if since.clone().is_nonnullish() {
                if limit.clone().is_nonnullish() {
                    request.set("end".into(), self.iso8601(self.sum(since.clone(), limit.clone() * duration.clone() * Value::from(1000))));
                };
                request.set("start".into(), self.iso8601(since.clone()));
            } else {
                if limit.clone().is_nonnullish() {
                    let mut now: Value = self.milliseconds();
                    request.set("start".into(), self.iso8601(now.clone() - limit.clone() * duration.clone() * Value::from(1000)));
                    request.set("end".into(), self.iso8601(now.clone()));
                };
            };
        } else if r#type.clone() == Value::from("HistoryCandles") {
            if market.get(Value::from("option")).is_truthy() {
                panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() does not have ") + r#type.clone() + Value::from(" for ") + market.get(Value::from("type")) + Value::from(" markets"))"###);
            };
            if since.clone().is_nonnullish() {
                if limit.clone().is_nullish() {
                    limit = Value::from(300);
                };
                // default
                request.set("start".into(), self.iso8601(self.sum(since.clone(), limit.clone() * duration.clone() * Value::from(1000))));
                request.set("end".into(), self.iso8601(since.clone()));
            } else {
                if limit.clone().is_nonnullish() {
                    let mut now: Value = self.milliseconds();
                    request.set("end".into(), self.iso8601(now.clone() - limit.clone() * duration.clone() * Value::from(1000)));
                    request.set("start".into(), self.iso8601(now.clone()));
                };
            };
        };
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot markets
        //
        //     [
        //         {
        //             close: "0.02683401",
        //             high: "0.02683401",
        //             low: "0.02683401",
        //             open: "0.02683401",
        //             time: "2018-12-17T23:47:00.000Z",
        //             volume: "0"
        //         },
        //         {
        //             close: "0.02684545",
        //             high: "0.02685084",
        //             low: "0.02683312",
        //             open: "0.02683894",
        //             time: "2018-12-17T20:28:00.000Z",
        //             volume: "101.457222"
        //         }
        //     ]
        //
        // futures
        //
        //     [
        //         [
        //             1545090660000,
        //             0.3171,
        //             0.3174,
        //             0.3171,
        //             0.3173,
        //             1648,
        //             51930.38579450868
        //         ],
        //         [
        //             1545072720000,
        //             0.3159,
        //             0.3161,
        //             0.3144,
        //             0.3149,
        //             22886,
        //             725179.26172331
        //         ]
        //     ]
        //
        return Okcoin::parse_ohlcvs(self, response.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_account_balance(&self, mut response: Value) -> Value {
        //
        // account
        //
        //     [
        //         {
        //             balance:  0,
        //             available:  0,
        //             currency: "BTC",
        //             hold:  0
        //         },
        //         {
        //             balance:  0,
        //             available:  0,
        //             currency: "ETH",
        //             hold:  0
        //         }
        //     ]
        //
        // spot
        //
        //     [
        //         {
        //             frozen: "0",
        //             hold: "0",
        //             id: "2149632",
        //             currency: "BTC",
        //             balance: "0.0000000497717339",
        //             available: "0.0000000497717339",
        //             holds: "0"
        //         },
        //         {
        //             frozen: "0",
        //             hold: "0",
        //             id: "2149632",
        //             currency: "ICN",
        //             balance: "0.00000000925",
        //             available: "0.00000000925",
        //             holds: "0"
        //         }
        //     ]
        //
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined
        }))).unwrap());
        let mut i: usize = 0;
        while i < response.len() {
            let mut balance: Value = response.get(i.into());
            let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("currency"), Value::Undefined);
            let mut code: Value = Okcoin::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut account: Value = Okcoin::account(self);
            account.set("total".into(), self.safe_string(balance.clone(), Value::from("balance"), Value::Undefined));
            account.set("used".into(), self.safe_string(balance.clone(), Value::from("hold"), Value::Undefined));
            account.set("free".into(), self.safe_string(balance.clone(), Value::from("available"), Value::Undefined));
            result.set(code.clone(), account.clone());
            i += 1;
        };
        return Okcoin::safe_balance(self, result.clone());
    }

    fn parse_futures_balance(&self, mut response: Value) -> Value {
        //
        //     {
        //         "info":{
        //             "eos":{
        //                 "auto_margin":"0",
        //                 "contracts": [
        //                     {
        //                         "available_qty":"40.37069445",
        //                         "fixed_balance":"0",
        //                         "instrument_id":"EOS-USD-190329",
        //                         "margin_for_unfilled":"0",
        //                         "margin_frozen":"0",
        //                         "realized_pnl":"0",
        //                         "unrealized_pnl":"0"
        //                     },
        //                     {
        //                         "available_qty":"40.37069445",
        //                         "fixed_balance":"14.54895721",
        //                         "instrument_id":"EOS-USD-190628",
        //                         "margin_for_unfilled":"0",
        //                         "margin_frozen":"10.64042157",
        //                         "realized_pnl":"-3.90853564",
        //                         "unrealized_pnl":"-0.259"
        //                     },
        //                 ],
        //                 "equity":"50.75220665",
        //                 "margin_mode":"fixed",
        //                 "total_avail_balance":"40.37069445"
        //             },
        //         }
        //     }
        //
        // their root field name is "info", so our info will contain their info
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined
        }))).unwrap());
        let mut info: Value = self.safe_value(response.clone(), Value::from("info"), Value::new_object());
        let mut ids: Value = Object::keys(info.clone());
        let mut i: usize = 0;
        while i < ids.len() {
            let mut id: Value = ids.get(i.into());
            let mut code: Value = Okcoin::safe_currency_code(self, id.clone(), Value::Undefined);
            let mut balance: Value = self.safe_value(info.clone(), id.clone(), Value::new_object());
            let mut account: Value = Okcoin::account(self);
            let mut total_avail_balance: Value = self.safe_string(balance.clone(), Value::from("total_avail_balance"), Value::Undefined);
            if self.safe_string(balance.clone(), Value::from("margin_mode"), Value::Undefined) == Value::from("fixed") {
                let mut contracts: Value = self.safe_value(balance.clone(), Value::from("contracts"), Value::new_array());
                let mut free: Value = total_avail_balance.clone();
                let mut i: usize = 0;
                while i < contracts.len() {
                    let mut contract: Value = contracts.get(i.into());
                    let mut fixed_balance: Value = self.safe_string(contract.clone(), Value::from("fixed_balance"), Value::Undefined);
                    let mut realized_pnl: Value = self.safe_string(contract.clone(), Value::from("realized_pnl"), Value::Undefined);
                    let mut margin_frozen: Value = self.safe_string(contract.clone(), Value::from("margin_frozen"), Value::Undefined);
                    let mut margin_for_unfilled: Value = self.safe_string(contract.clone(), Value::from("margin_for_unfilled"), Value::Undefined);
                    let mut margin: Value = Precise::string_sub(Precise::string_sub(Precise::string_add(fixed_balance.clone(), realized_pnl.clone()), margin_frozen.clone()), margin_for_unfilled.clone());
                    free = Precise::string_add(free.clone(), margin.clone());
                    i += 1;
                };
                account.set("free".into(), free.clone());
            } else {
                let mut realized_pnl: Value = self.safe_string(balance.clone(), Value::from("realized_pnl"), Value::Undefined);
                let mut unrealized_pnl: Value = self.safe_string(balance.clone(), Value::from("unrealized_pnl"), Value::Undefined);
                let mut margin_frozen: Value = self.safe_string(balance.clone(), Value::from("margin_frozen"), Value::Undefined);
                let mut margin_for_unfilled: Value = self.safe_string(balance.clone(), Value::from("margin_for_unfilled"), Value::Undefined);
                let mut positive: Value = Precise::string_add(Precise::string_add(total_avail_balance.clone(), realized_pnl.clone()), unrealized_pnl.clone());
                account.set("free".into(), Precise::string_sub(Precise::string_sub(positive.clone(), margin_frozen.clone()), margin_for_unfilled.clone()));
            };
            // it may be incorrect to use total, free and used for swap accounts
            account.set("total".into(), self.safe_string(balance.clone(), Value::from("equity"), Value::Undefined));
            result.set(code.clone(), account.clone());
            i += 1;
        };
        return Okcoin::safe_balance(self, result.clone());
    }

    fn parse_swap_balance(&self, mut response: Value) -> Value {
        //
        //     {
        //         "info": [
        //             {
        //                 "equity":"3.0139",
        //                 "fixed_balance":"0.0000",
        //                 "instrument_id":"EOS-USD-SWAP",
        //                 "margin":"0.5523",
        //                 "margin_frozen":"0.0000",
        //                 "margin_mode":"crossed",
        //                 "margin_ratio":"1.0913",
        //                 "realized_pnl":"-0.0006",
        //                 "timestamp":"2019-03-25T03:46:10.336Z",
        //                 "total_avail_balance":"3.0000",
        //                 "unrealized_pnl":"0.0145"
        //             }
        //         ]
        //     }
        //
        // their root field name is "info", so our info will contain their info
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut timestamp: Value = Value::Undefined;
        let mut info: Value = self.safe_value(response.clone(), Value::from("info"), Value::new_array());
        let mut i: usize = 0;
        while i < info.len() {
            let mut balance: Value = info.get(i.into());
            let mut market_id: Value = self.safe_string(balance.clone(), Value::from("instrument_id"), Value::Undefined);
            let mut symbol: Value = market_id.clone();
            if self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                symbol = self.get("markets_by_id".into()).get(market_id.clone()).get(Value::from("symbol"));
            };
            let mut balance_timestamp: Value = self.parse8601(self.safe_string(balance.clone(), Value::from("timestamp"), Value::Undefined));
            timestamp = if timestamp.clone().is_nullish() { balance_timestamp.clone() } else { Math::max(timestamp.clone(), balance_timestamp.clone()) };
            let mut account: Value = Okcoin::account(self);
            // it may be incorrect to use total, free and used for swap accounts
            account.set("total".into(), self.safe_string(balance.clone(), Value::from("equity"), Value::Undefined));
            account.set("free".into(), self.safe_string(balance.clone(), Value::from("total_avail_balance"), Value::Undefined));
            result.set(symbol.clone(), account.clone());
            i += 1;
        };
        result.set("timestamp".into(), timestamp.clone());
        result.set("datetime".into(), self.iso8601(timestamp.clone()));
        return Okcoin::safe_balance(self, result.clone());
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchBalance"), Value::from("defaultType"), Value::Undefined);
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        if r#type.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchBalance() requires a type parameter (one of 'account', 'spot', 'futures', 'swap')"))"###);
        };
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut suffix: Value = if r#type.clone() == Value::from("account") { Value::from("Wallet") } else { Value::from("Accounts") };
        let mut method: Value = r#type.clone() + Value::from("Get") + suffix.clone();
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        let mut response: Value = Okcoin::dispatch(self, method, query.clone(), Value::Undefined).await;
        //
        // account
        //
        //     [
        //         {
        //             balance:  0,
        //             available:  0,
        //             currency: "BTC",
        //             hold:  0
        //         },
        //         {
        //             balance:  0,
        //             available:  0,
        //             currency: "ETH",
        //             hold:  0
        //         }
        //     ]
        //
        // spot
        //
        //     [
        //         {
        //             frozen: "0",
        //             hold: "0",
        //             id: "2149632",
        //             currency: "BTC",
        //             balance: "0.0000000497717339",
        //             available: "0.0000000497717339",
        //             holds: "0"
        //         },
        //         {
        //             frozen: "0",
        //             hold: "0",
        //             id: "2149632",
        //             currency: "ICN",
        //             balance: "0.00000000925",
        //             available: "0.00000000925",
        //             holds: "0"
        //         }
        //     ]
        //
        //
        // futures
        //
        //     {
        //         "info":{
        //             "eos":{
        //                 "auto_margin":"0",
        //                 "contracts": [
        //                     {
        //                         "available_qty":"40.37069445",
        //                         "fixed_balance":"0",
        //                         "instrument_id":"EOS-USD-190329",
        //                         "margin_for_unfilled":"0",
        //                         "margin_frozen":"0",
        //                         "realized_pnl":"0",
        //                         "unrealized_pnl":"0"
        //                     },
        //                     {
        //                         "available_qty":"40.37069445",
        //                         "fixed_balance":"14.54895721",
        //                         "instrument_id":"EOS-USD-190628",
        //                         "margin_for_unfilled":"0",
        //                         "margin_frozen":"10.64042157",
        //                         "realized_pnl":"-3.90853564",
        //                         "unrealized_pnl":"-0.259"
        //                     },
        //                 ],
        //                 "equity":"50.75220665",
        //                 "margin_mode":"fixed",
        //                 "total_avail_balance":"40.37069445"
        //             },
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "info": [
        //             {
        //                 "equity":"3.0139",
        //                 "fixed_balance":"0.0000",
        //                 "instrument_id":"EOS-USD-SWAP",
        //                 "margin":"0.5523",
        //                 "margin_frozen":"0.0000",
        //                 "margin_mode":"crossed",
        //                 "margin_ratio":"1.0913",
        //                 "realized_pnl":"-0.0006",
        //                 "timestamp":"2019-03-25T03:46:10.336Z",
        //                 "total_avail_balance":"3.0000",
        //                 "unrealized_pnl":"0.0145"
        //             }
        //         ]
        //     }
        //
        return Okcoin::parse_balance_by_type(self, r#type.clone(), response.clone());
    }

    fn parse_balance_by_type(&self, mut r#type: Value, mut response: Value) -> Value {
        if r#type.clone() == Value::from("account") || r#type.clone() == Value::from("spot") {
            return Okcoin::parse_account_balance(self, response.clone());
        } else if r#type.clone() == Value::from("futures") {
            return Okcoin::parse_futures_balance(self, response.clone());
        } else if r#type.clone() == Value::from("swap") {
            return Okcoin::parse_swap_balance(self, response.clone());
        };
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBalance does not support the '") + r#type.clone() + Value::from("' type (the type must be one of 'account', 'spot', 'futures', 'swap')"))"###);
        Value::Undefined
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create a trade order
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to create an order in
    /// * `type` {string} - 'market' or 'limit'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - how much of currency you want to trade in units of base currency
    /// * `price` {float|undefined} - the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okcoin::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instrument_id": market.get(Value::from("id"))
        }))).unwrap());
        // 'client_oid': 'abcdef1234567890', // [a-z0-9]{1,32}
        // 'order_type': '0', // 0 = Normal limit order, 1 = Post only, 2 = Fill Or Kill, 3 = Immediatel Or Cancel, 4 = Market for futures only
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("client_oid"), Value::from("clientOrderId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() {
            request.set("client_oid".into(), client_order_id.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("client_oid").into(), Value::from("clientOrderId").into()])));
        };
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("futures")).is_truthy() || market.get(Value::from("swap")).is_truthy() {
            let mut size: Value = if market.get(Value::from("futures")).is_truthy() { self.number_to_string(amount.clone()) } else { Okcoin::amount_to_precision(self, symbol.clone(), amount.clone()) };
            request = extend_2(request.clone(), Value::Json(normalize(&Value::Json(json!({
                "type": r#type,
                "size": size
            }))).unwrap()));
            // 1:open long 2:open short 3:close long 4:close short for futures
            // 'match_price': '0', // Order at best counter party price? (0:no 1:yes). The default is 0. If it is set as 1, the price parameter will be ignored. When posting orders at best bid price, order_type can only be 0 (regular order).
            let mut order_type: Value = self.safe_string(params.clone(), Value::from("order_type"), Value::Undefined);
            // order_type === '4' means a market order
            let mut is_market_order: Value = (r#type.clone() == Value::from("market") || order_type.clone() == Value::from("4")).into();
            if is_market_order.is_truthy() {
                request.set("order_type".into(), Value::from("4"));
            } else {
                request.set("price".into(), Okcoin::price_to_precision(self, symbol.clone(), price.clone()));
            };
            if market.get(Value::from("futures")).is_truthy() {
                request.set("leverage".into(), Value::from("10"));
            };
            // or '20'
            method = market.get(Value::from("type")) + Value::from("PostOrder");
        } else {
            request = extend_2(request.clone(), Value::Json(normalize(&Value::Json(json!({
                "side": side,
                "type": r#type
            }))).unwrap()));
            // limit/market
            if r#type.clone() == Value::from("limit") {
                request.set("price".into(), Okcoin::price_to_precision(self, symbol.clone(), price.clone()));
                request.set("size".into(), Okcoin::amount_to_precision(self, symbol.clone(), amount.clone()));
            } else if r#type.clone() == Value::from("market") {
                // for market buy it requires the amount of quote currency to spend
                if side.clone() == Value::from("buy") {
                    let mut notional: Value = Okcoin::safe_number(self, params.clone(), Value::from("notional"), Value::Undefined);
                    let mut create_market_buy_order_requires_price: Value = self.safe_value(self.get("options".into()), Value::from("createMarketBuyOrderRequiresPrice"), true.into());
                    if create_market_buy_order_requires_price.is_truthy() {
                        if price.clone().is_nonnullish() {
                            if notional.clone().is_nullish() {
                                notional = amount.clone() * price.clone();
                            };
                        } else if notional.clone().is_nullish() {
                            panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'notional' extra parameter (the exchange-specific behaviour)"))"###);
                        };
                    } else {
                        notional = if notional.clone().is_nullish() { amount.clone() } else { notional.clone() };
                    };
                    request.set("notional".into(), Okcoin::cost_to_precision(self, symbol.clone(), notional.clone()));
                } else {
                    request.set("size".into(), Okcoin::amount_to_precision(self, symbol.clone(), amount.clone()));
                };
            };
            method = Value::from("spotPostOrders");
        };
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "client_oid":"oktspot79",
        //         "error_code":"",
        //         "error_message":"",
        //         "order_id":"2510789768709120",
        //         "result":true
        //     }
        //
        let mut order: Value = Okcoin::parse_order(self, response.clone(), market.clone());
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "type": r#type,
            "side": side
        }))).unwrap()));
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelOrder() requires a symbol argument"))"###);
        };
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okcoin::market(self, symbol.clone());
        let mut r#type: Value = Value::Undefined;
        if market.get(Value::from("futures")).is_truthy() || market.get(Value::from("swap")).is_truthy() {
            r#type = market.get(Value::from("type"));
        } else {
            let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("cancelOrder"), Value::from("defaultType"), market.get(Value::from("type")));
            r#type = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        };
        if r#type.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelOrder() requires a type parameter (one of 'spot', 'futures', 'swap')."))"###);
        };
        let mut method: Value = r#type.clone() + Value::from("PostCancelOrder");
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instrument_id": market.get(Value::from("id"))
        }))).unwrap());
        if market.get(Value::from("futures")).is_truthy() || market.get(Value::from("swap")).is_truthy() {
            method = method +  Value::from("InstrumentId");
        } else {
            method = method +  Value::from("s");
        };
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("client_oid"), Value::from("clientOrderId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() {
            method = method +  Value::from("ClientOid");
            request.set("client_oid".into(), client_order_id.clone());
        } else {
            method = method +  Value::from("OrderId");
            request.set("order_id".into(), id.clone());
        };
        let mut query: Value = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("type").into(), Value::from("client_oid").into(), Value::from("clientOrderId").into()])));
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        let mut result: Value = if response.contains_key(Value::from("result")) { response.clone() } else { self.safe_value(response.clone(), market.get(Value::from("id")), Value::new_object()) };
        //
        // spot
        //
        //     {
        //         "btc-usdt": [
        //             {
        //                 "result":true,
        //                 "client_oid":"a123",
        //                 "order_id": "2510832677225473"
        //             }
        //         ]
        //     }
        //
        // futures, swap
        //
        //     {
        //         "result": true,
        //         "client_oid": "oktfuture10", // missing if requested by order_id
        //         "order_id": "2517535534836736",
        //         "instrument_id": "EOS-USD-190628"
        //     }
        //
        return Okcoin::parse_order(self, result.clone(), market.clone());
    }

    fn parse_order_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "-2": "failed",
            "-1": "canceled",
            "0": "open",
            "1": "open",
            "2": "closed",
            "3": "open",
            "4": "canceled"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_order_side(&self, mut side: Value) -> Value {
        let mut sides: Value = Value::Json(normalize(&Value::Json(json!({
            "1": "buy",
            "2": "sell",
            "3": "sell",
            "4": "buy"
        }))).unwrap());
        // open long
        // open short
        // close long
        // close short
        return self.safe_string(sides.clone(), side.clone(), side.clone());
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        //
        // createOrder
        //
        //     {
        //         "client_oid":"oktspot79",
        //         "error_code":"",
        //         "error_message":"",
        //         "order_id":"2510789768709120",
        //         "result":true
        //     }
        //
        // cancelOrder
        //
        //     {
        //         "result": true,
        //         "client_oid": "oktfuture10", // missing if requested by order_id
        //         "order_id": "2517535534836736",
        //         // instrument_id is missing for spot/margin orders
        //         // available in futures and swap orders only
        //         "instrument_id": "EOS-USD-190628",
        //     }
        //
        // fetchOrder, fetchOrdersByState, fetchOpenOrders, fetchClosedOrders
        //
        //     // spot orders
        //
        //     {
        //         "client_oid":"oktspot76",
        //         "created_at":"2019-03-18T07:26:49.000Z",
        //         "filled_notional":"3.9734",
        //         "filled_size":"0.001", // filled_qty in futures and swap orders
        //         "funds":"", // this is most likely the same as notional
        //         "instrument_id":"BTC-USDT",
        //         "notional":"",
        //         "order_id":"2500723297813504",
        //         "order_type":"0",
        //         "price":"4013",
        //         "product_id":"BTC-USDT", // missing in futures and swap orders
        //         "side":"buy",
        //         "size":"0.001",
        //         "status":"filled",
        //         "state": "2",
        //         "timestamp":"2019-03-18T07:26:49.000Z",
        //         "type":"limit"
        //     }
        //
        //     // futures and swap orders
        //
        //     {
        //         "instrument_id":"EOS-USD-190628",
        //         "size":"10",
        //         "timestamp":"2019-03-20T10:04:55.000Z",
        //         "filled_qty":"10", // filled_size in spot orders
        //         "fee":"-0.00841043",
        //         "order_id":"2512669605501952",
        //         "price":"3.668",
        //         "price_avg":"3.567", // missing in spot orders
        //         "status":"2",
        //         "state": "2",
        //         "type":"4",
        //         "contract_val":"10",
        //         "leverage":"10", // missing in swap, spot orders
        //         "client_oid":"",
        //         "pnl":"1.09510794", // missing in swap, spot orders
        //         "order_type":"0"
        //     }
        //
        let mut id: Value = self.safe_string(order.clone(), Value::from("order_id"), Value::Undefined);
        let mut timestamp: Value = self.parse8601(self.safe_string(order.clone(), Value::from("timestamp"), Value::Undefined));
        let mut side: Value = self.safe_string(order.clone(), Value::from("side"), Value::Undefined);
        let mut r#type: Value = self.safe_string(order.clone(), Value::from("type"), Value::Undefined);
        if side.clone() != Value::from("buy") && side.clone() != Value::from("sell") {
            side = Okcoin::parse_order_side(self, r#type.clone());
        };
        let mut market_id: Value = self.safe_string(order.clone(), Value::from("instrument_id"), Value::Undefined);
        market = Okcoin::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut amount: Value = self.safe_string(order.clone(), Value::from("size"), Value::Undefined);
        let mut filled: Value = self.safe_string_2(order.clone(), Value::from("filled_size"), Value::from("filled_qty"), Value::Undefined);
        let mut remaining: Value = Value::Undefined;
        if amount.clone().is_nonnullish() {
            if filled.clone().is_nonnullish() {
                amount = Precise::string_max(amount.clone(), filled.clone());
                remaining = Precise::string_max(Value::from("0"), Precise::string_sub(amount.clone(), filled.clone()));
            };
        };
        if r#type.clone() == Value::from("market") {
            remaining = Value::from("0");
        };
        let mut cost: Value = self.safe_string_2(order.clone(), Value::from("filled_notional"), Value::from("funds"), Value::Undefined);
        let mut price: Value = self.safe_string(order.clone(), Value::from("price"), Value::Undefined);
        let mut average: Value = self.safe_string(order.clone(), Value::from("price_avg"), Value::Undefined);
        if cost.clone().is_nullish() {
            if filled.clone().is_nonnullish() && average.clone().is_nonnullish() {
                cost = Precise::string_mul(average.clone(), filled.clone());
            };
        } else {
            if average.clone().is_nullish() && filled.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        let mut status: Value = Okcoin::parse_order_status(self, self.safe_string(order.clone(), Value::from("state"), Value::Undefined));
        let mut fee_cost: Value = Okcoin::safe_number(self, order.clone(), Value::from("fee"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        if fee_cost.clone().is_nonnullish() {
            let mut fee_currency: Value = Value::Undefined;
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost,
                "currency": fee_currency
            }))).unwrap());
        };
        let mut client_order_id: Value = self.safe_string(order.clone(), Value::from("client_oid"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() && client_order_id.len() < 1 {
            client_order_id = Value::Undefined;
        };
        // fix empty clientOrderId string
        let mut stop_price: Value = Okcoin::safe_number(self, order.clone(), Value::from("trigger_price"), Value::Undefined);
        return Okcoin::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "info": order,
            "id": id,
            "clientOrderId": client_order_id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": Value::Undefined,
            "symbol": market.get(Value::from("symbol")),
            "type": r#type,
            "timeInForce": Value::Undefined,
            "postOnly": Value::Undefined,
            "side": side,
            "price": price,
            "stopPrice": stop_price,
            "average": average,
            "cost": cost,
            "amount": amount,
            "filled": filled,
            "remaining": remaining,
            "status": status,
            "fee": fee,
            "trades": Value::Undefined
        }))).unwrap()), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on an order made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrder() requires a symbol argument"))"###);
        };
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okcoin::market(self, symbol.clone());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchOrder"), Value::from("defaultType"), market.get(Value::from("type")));
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        if r#type.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrder() requires a type parameter (one of 'spot', 'futures', 'swap')."))"###);
        };
        let mut instrument_id: Value = if market.get(Value::from("futures")).is_truthy() || market.get(Value::from("swap")).is_truthy() { Value::from("InstrumentId") } else { Value::from("") };
        let mut method: Value = r#type.clone() + Value::from("GetOrders") + instrument_id.clone();
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instrument_id": market.get(Value::from("id"))
        }))).unwrap());
        // 'client_oid': 'abcdef12345', // optional, [a-z0-9]{1,32}
        // 'order_id': id,
        let mut client_oid: Value = self.safe_string(params.clone(), Value::from("client_oid"), Value::Undefined);
        if client_oid.clone().is_nonnullish() {
            method = method +  Value::from("ClientOid");
            request.set("client_oid".into(), client_oid.clone());
        } else {
            method = method +  Value::from("OrderId");
            request.set("order_id".into(), id.clone());
        };
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "client_oid":"oktspot70",
        //         "created_at":"2019-03-15T02:52:56.000Z",
        //         "filled_notional":"3.8886",
        //         "filled_size":"0.001",
        //         "funds":"",
        //         "instrument_id":"BTC-USDT",
        //         "notional":"",
        //         "order_id":"2482659399697408",
        //         "order_type":"0",
        //         "price":"3927.3",
        //         "product_id":"BTC-USDT",
        //         "side":"buy",
        //         "size":"0.001",
        //         "status":"filled",
        //         "state": "2",
        //         "timestamp":"2019-03-15T02:52:56.000Z",
        //         "type":"limit"
        //     }
        //
        // futures, swap
        //
        //     {
        //         "instrument_id":"EOS-USD-190628",
        //         "size":"10",
        //         "timestamp":"2019-03-20T02:46:38.000Z",
        //         "filled_qty":"10",
        //         "fee":"-0.0080819",
        //         "order_id":"2510946213248000",
        //         "price":"3.712",
        //         "price_avg":"3.712",
        //         "status":"2",
        //         "state": "2",
        //         "type":"2",
        //         "contract_val":"10",
        //         "leverage":"10",
        //         "client_oid":"", // missing in swap orders
        //         "pnl":"0", // missing in swap orders
        //         "order_type":"0"
        //     }
        //
        return Okcoin::parse_order(self, response.clone(), Value::Undefined);
    }

    async fn fetch_orders_by_state(&mut self, mut state: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrdersByState() requires a symbol argument"))"###);
        };
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okcoin::market(self, symbol.clone());
        let mut r#type: Value = Value::Undefined;
        if market.get(Value::from("futures")).is_truthy() || market.get(Value::from("swap")).is_truthy() {
            r#type = market.get(Value::from("type"));
        } else {
            let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchOrder"), Value::from("defaultType"), market.get(Value::from("type")));
            r#type = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        };
        if r#type.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrdersByState() requires a type parameter (one of 'spot', 'futures', 'swap')."))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instrument_id": market.get(Value::from("id")),
            "state": state
        }))).unwrap());
        // '-2': failed,
        // '-1': cancelled,
        //  '0': open ,
        //  '1': partially filled,
        //  '2': fully filled,
        //  '3': submitting,
        //  '4': cancelling,
        //  '6': incompleteopen+partially filled),
        //  '7': completecancelled+fully filled),
        let mut method: Value = r#type.clone() + Value::from("GetOrders");
        if market.get(Value::from("futures")).is_truthy() || market.get(Value::from("swap")).is_truthy() {
            method = method +  Value::from("InstrumentId");
        };
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     [
        //         // in fact, this documented API response does not correspond
        //         // to their actual API response for spot markets
        //         // OKEX v3 API returns a plain array of orders (see below)
        //         [
        //             {
        //                 "client_oid":"oktspot76",
        //                 "created_at":"2019-03-18T07:26:49.000Z",
        //                 "filled_notional":"3.9734",
        //                 "filled_size":"0.001",
        //                 "funds":"",
        //                 "instrument_id":"BTC-USDT",
        //                 "notional":"",
        //                 "order_id":"2500723297813504",
        //                 "order_type":"0",
        //                 "price":"4013",
        //                 "product_id":"BTC-USDT",
        //                 "side":"buy",
        //                 "size":"0.001",
        //                 "status":"filled",
        //                 "state": "2",
        //                 "timestamp":"2019-03-18T07:26:49.000Z",
        //                 "type":"limit"
        //             },
        //         ],
        //         {
        //             "before":"2500723297813504",
        //             "after":"2500650881647616"
        //         }
        //     ]
        //
        // futures, swap
        //
        //     {
        //         "result":true,  // missing in swap orders
        //         "order_info": [
        //             {
        //                 "instrument_id":"EOS-USD-190628",
        //                 "size":"10",
        //                 "timestamp":"2019-03-20T10:04:55.000Z",
        //                 "filled_qty":"10",
        //                 "fee":"-0.00841043",
        //                 "order_id":"2512669605501952",
        //                 "price":"3.668",
        //                 "price_avg":"3.567",
        //                 "status":"2",
        //                 "state": "2",
        //                 "type":"4",
        //                 "contract_val":"10",
        //                 "leverage":"10", // missing in swap orders
        //                 "client_oid":"",
        //                 "pnl":"1.09510794", // missing in swap orders
        //                 "order_type":"0"
        //             },
        //         ]
        //     }
        //
        let mut orders: Value = Value::Undefined;
        if market.get(Value::from("swap")).is_truthy() || market.get(Value::from("futures")).is_truthy() {
            orders = self.safe_value(response.clone(), Value::from("order_info"), Value::new_array());
        } else {
            orders = response.clone();
            let mut response_length: Value = response.len().into();
            if response_length.clone() < Value::from(1) {
                return Value::new_array();
            };
            // in fact, this documented API response does not correspond
            // to their actual API response for spot markets
            // OKEX v3 API returns a plain array of orders
            if response_length.clone() > Value::from(1) {
                let mut before: Value = self.safe_value(response.get(Value::from(1)), Value::from("before"), Value::Undefined);
                if before.clone().is_nonnullish() {
                    orders = response.get(Value::from(0));
                };
            };
        };
        return Okcoin::parse_orders(self, orders.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // '-2': failed,
        // '-1': cancelled,
        //  '0': open ,
        //  '1': partially filled,
        //  '2': fully filled,
        //  '3': submitting,
        //  '4': cancelling,
        //  '6': incompleteopen+partially filled),
        //  '7': completecancelled+fully filled),
        return Okcoin::fetch_orders_by_state(self, Value::from("6"), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // '-2': failed,
        // '-1': cancelled,
        //  '0': open ,
        //  '1': partially filled,
        //  '2': fully filled,
        //  '3': submitting,
        //  '4': cancelling,
        //  '6': incompleteopen+partially filled),
        //  '7': completecancelled+fully filled),
        return Okcoin::fetch_orders_by_state(self, Value::from("7"), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
    }

    fn parse_deposit_address(&self, mut deposit_address: Value, mut currency: Value) -> Value {
        //
        //     {
        //         address: '0x696abb81974a8793352cbd33aadcf78eda3cfdfa',
        //         currency: 'eth'
        //         tag: 'abcde12345', // will be missing if the token does not require a deposit tag
        //         payment_id: 'abcde12345', // will not be returned if the token does not require a payment_id
        //         // can_deposit: 1, // 0 or 1, documented but missing
        //         // can_withdraw: 1, // 0 or 1, documented but missing
        //     }
        //
        let mut address: Value = self.safe_string(deposit_address.clone(), Value::from("address"), Value::Undefined);
        let mut tag: Value = self.safe_string_2(deposit_address.clone(), Value::from("tag"), Value::from("payment_id"), Value::Undefined);
        tag = self.safe_string_2(deposit_address.clone(), Value::from("memo"), Value::from("Memo"), tag.clone());
        let mut currency_id: Value = self.safe_string(deposit_address.clone(), Value::from("currency"), Value::Undefined);
        let mut code: Value = Okcoin::safe_currency_code(self, currency_id.clone(), Value::Undefined);
        self.check_address(address.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "currency": code,
            "address": address,
            "tag": tag,
            "info": deposit_address
        }))).unwrap());
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut parts: Value = code.split(Value::from("-"));
        let mut currency: Value = Okcoin::currency(self, parts.get(Value::from(0)));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Okcoin::dispatch(self, "accountGetDepositAddress".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     [
        //         {
        //             address: '0x696abb81974a8793352cbd33aadcf78eda3cfdfa',
        //             currency: 'eth'
        //         }
        //     ]
        //
        let mut addresses_by_code: Value = Okcoin::parse_deposit_addresses(self, response.clone(), Value::Undefined, Value::Undefined, Value::Undefined);
        let mut address: Value = self.safe_value(addresses_by_code.clone(), code.clone(), Value::Undefined);
        if address.clone().is_nullish() {
            panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchDepositAddress() cannot return nonexistent addresses, you should create withdrawal addresses with the exchange website first"))"###);
        };
        return address.clone();
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Transfer currency internally between wallets on the same account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - amount to transfer
    /// * `fromAccount` {string} - account to transfer from
    /// * `toAccount` {string} - account to transfer to
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn transfer(&mut self, mut code: Value, mut amount: Value, mut from_account: Value, mut to_account: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Okcoin::currency(self, code.clone());
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut from_id: Value = self.safe_string(accounts_by_type.clone(), from_account.clone(), from_account.clone());
        let mut to_id: Value = self.safe_string(accounts_by_type.clone(), to_account.clone(), to_account.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "amount": Okcoin::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined),
            "currency": currency.get(Value::from("id")),
            "from": from_id,
            "to": to_id,
            "type": "0"
        }))).unwrap());
        // 1 spot, 6 funding
        // 1 spot, 6 funding
        // 0 Transfer between accounts in the main account/sub_account, 1 main account to sub_account, 2 sub_account to main account
        if from_id.clone() == Value::from("main") {
            request.set("type".into(), Value::from("1"));
            request.set("sub_account".into(), to_id.clone());
            request.set("to".into(), Value::from("0"));
        } else if to_id.clone() == Value::from("main") {
            request.set("type".into(), Value::from("2"));
            request.set("sub_account".into(), from_id.clone());
            request.set("from".into(), Value::from("0"));
            request.set("to".into(), Value::from("6"));
        };
        let mut response: Value = Okcoin::dispatch(self, "accountPostTransfer".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //      {
        //          "transfer_id": "754147",
        //          "currency": "ETC",
        //          "from": "6",
        //          "amount": "0.1",
        //          "to": "1",
        //          "result": true
        //      }
        //
        return Okcoin::parse_transfer(self, response.clone(), currency.clone());
    }

    fn parse_transfer(&self, mut transfer: Value, mut currency: Value) -> Value {
        //
        //      {
        //          "transfer_id": "754147",
        //          "currency": "ETC",
        //          "from": "6",
        //          "amount": "0.1",
        //          "to": "1",
        //          "result": true
        //      }
        //
        let mut accounts_by_id: Value = self.safe_value(self.get("options".into()), Value::from("accountsById"), Value::new_object());
        return Value::Json(normalize(&Value::Json(json!({
            "info": transfer,
            "id": self.safe_string(transfer.clone(), Value::from("transfer_id"), Value::Undefined),
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "currency": Okcoin::safe_currency_code(self, self.safe_string(transfer.clone(), Value::from("currency"), Value::Undefined), currency.clone()),
            "amount": Okcoin::safe_number(self, transfer.clone(), Value::from("amount"), Value::Undefined),
            "fromAccount": self.safe_string(accounts_by_id.clone(), self.safe_string(transfer.clone(), Value::from("from"), Value::Undefined), Value::Undefined),
            "toAccount": self.safe_string(accounts_by_id.clone(), self.safe_string(transfer.clone(), Value::from("to"), Value::Undefined), Value::Undefined),
            "status": Okcoin::parse_transfer_status(self, self.safe_string(transfer.clone(), Value::from("result"), Value::Undefined))
        }))).unwrap());
    }

    fn parse_transfer_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "true": "ok"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), Value::from("failed"));
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        (tag, params) = shift_2(Okcoin::handle_withdraw_tag_and_params(self, tag.clone(), params.clone()));
        self.check_address(address.clone());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Okcoin::currency(self, code.clone());
        if tag.is_truthy() {
            address = address.clone() + Value::from(":") + tag.clone();
        };
        let mut fee: Value = self.safe_string(params.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" withdraw() requires a 'fee' string parameter, network transaction fee must be  0. Withdrawals to OKCoin or OKEx are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee."))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "to_address": address,
            "destination": "4",
            "amount": self.number_to_string(amount.clone()),
            "fee": fee
        }))).unwrap());
        // 2 = OKCoin International, 3 = OKEx 4 = others
        // String. Network transaction fee  0. Withdrawals to OKCoin or OKEx are fee-free, please set as 0. Withdrawal to external digital asset address requires network transaction fee.
        if params.contains_key(Value::from("password")) {
            request.set("trade_pwd".into(), params.get(Value::from("password")));
        } else if params.contains_key(Value::from("trade_pwd")) {
            request.set("trade_pwd".into(), params.get(Value::from("trade_pwd")));
        } else if self.get("password".into()).is_truthy() {
            request.set("trade_pwd".into(), self.get("password".into()));
        };
        let mut query: Value = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("fee").into(), Value::from("password").into(), Value::from("trade_pwd").into()])));
        if !request.contains_key(Value::from("trade_pwd")) {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" withdraw() requires this.password set on the exchange instance or a password / trade_pwd parameter"))"###);
        };
        let mut response: Value = Okcoin::dispatch(self, "accountPostWithdrawal".into(), extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //     {
        //         "amount":"0.1",
        //         "withdrawal_id":"67485",
        //         "currency":"btc",
        //         "result":true
        //     }
        //
        return Okcoin::parse_transaction(self, response.clone(), currency.clone());
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all deposits made to an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch deposits for
    /// * `limit` {int|undefined} - the maximum number of deposits structures to retrieve
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_deposits(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut method: Value = Value::from("accountGetDepositHistory");
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Okcoin::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
            method = method +  Value::from("Currency");
        };
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Okcoin::parse_transactions(self, response.clone(), currency.clone(), since.clone(), limit.clone(), params.clone());
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all withdrawals made from an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch withdrawals for
    /// * `limit` {int|undefined} - the maximum number of withdrawals structures to retrieve
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_withdrawals(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        let mut method: Value = Value::from("accountGetWithdrawalHistory");
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Okcoin::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
            method = method +  Value::from("Currency");
        };
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Okcoin::parse_transactions(self, response.clone(), currency.clone(), since.clone(), limit.clone(), params.clone());
    }

    fn parse_transaction_status(&self, mut status: Value) -> Value {
        //
        // deposit statuses
        //
        //     {
        //         '0': 'waiting for confirmation',
        //         '1': 'confirmation account',
        //         '2': 'recharge success'
        //     }
        //
        // withdrawal statues
        //
        //     {
        //        '-3': 'pending cancel',
        //        '-2': 'cancelled',
        //        '-1': 'failed',
        //         '0': 'pending',
        //         '1': 'sending',
        //         '2': 'sent',
        //         '3': 'email confirmation',
        //         '4': 'manual confirmation',
        //         '5': 'awaiting identity confirmation'
        //     }
        //
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "-3": "pending",
            "-2": "canceled",
            "-1": "failed",
            "0": "pending",
            "1": "pending",
            "2": "ok",
            "3": "pending",
            "4": "pending",
            "5": "pending"
        }))).unwrap());
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // withdraw
        //
        //     {
        //         "amount":"0.1",
        //         "withdrawal_id":"67485",
        //         "currency":"btc",
        //         "result":true
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         amount: "4.72100000",
        //         withdrawal_id: "1729116",
        //         fee: "0.01000000eth",
        //         txid: "0xf653125bbf090bcfe4b5e8e7b8f586a9d87aa7de94598702758c0802b",
        //         currency: "ETH",
        //         from: "7147338839",
        //         to: "0x26a3CB49578F07000575405a57888681249c35Fd",
        //         timestamp: "2018-08-17T07:03:42.000Z",
        //         status: "2"
        //     }
        //
        // fetchDeposits
        //
        //     {
        //         "amount": "4.19511659",
        //         "txid": "14c9a8c925647cdb7e5b2937ea9aefe2b29b2c273150ad3f44b3b8a4635ed437",
        //         "currency": "XMR",
        //         "from": "",
        //         "to": "48PjH3ksv1fiXniKvKvyH5UtFs5WhfS2Vf7U3TwzdRJtCc7HJWvCQe56dRahyhQyTAViXZ8Nzk4gQg6o4BJBMUoxNy8y8g7",
        //         "tag": "1234567",
        //         "deposit_id": 11571659, <-- we can use this
        //         "timestamp": "2019-10-01T14:54:19.000Z",
        //         "status": "2"
        //     }
        //
        let mut r#type: Value = Value::Undefined;
        let mut id: Value = Value::Undefined;
        let mut address: Value = Value::Undefined;
        let mut withdrawal_id: Value = self.safe_string(transaction.clone(), Value::from("withdrawal_id"), Value::Undefined);
        let mut address_from: Value = self.safe_string(transaction.clone(), Value::from("from"), Value::Undefined);
        let mut address_to: Value = self.safe_string(transaction.clone(), Value::from("to"), Value::Undefined);
        let mut tag_to: Value = self.safe_string(transaction.clone(), Value::from("tag"), Value::Undefined);
        if withdrawal_id.clone().is_nonnullish() {
            r#type = Value::from("withdrawal");
            id = withdrawal_id.clone();
            address = address_to.clone();
        } else {
            // the payment_id will appear on new deposits but appears to be removed from the response after 2 months
            id = self.safe_string_2(transaction.clone(), Value::from("payment_id"), Value::from("deposit_id"), Value::Undefined);
            r#type = Value::from("deposit");
            address = address_to.clone();
        };
        let mut currency_id: Value = self.safe_string(transaction.clone(), Value::from("currency"), Value::Undefined);
        let mut code: Value = Okcoin::safe_currency_code(self, currency_id.clone(), Value::Undefined);
        let mut amount: Value = Okcoin::safe_number(self, transaction.clone(), Value::from("amount"), Value::Undefined);
        let mut status: Value = Okcoin::parse_transaction_status(self, self.safe_string(transaction.clone(), Value::from("status"), Value::Undefined));
        let mut txid: Value = self.safe_string(transaction.clone(), Value::from("txid"), Value::Undefined);
        let mut timestamp: Value = self.parse8601(self.safe_string(transaction.clone(), Value::from("timestamp"), Value::Undefined));
        let mut fee_cost: Value = Value::Undefined;
        if r#type.clone() == Value::from("deposit") {
            fee_cost = Value::from(0);
        } else {
            if currency_id.clone().is_nonnullish() {
                let mut fee_with_currency_id: Value = self.safe_string(transaction.clone(), Value::from("fee"), Value::Undefined);
                if fee_with_currency_id.clone().is_nonnullish() {
                    // https://github.com/ccxt/ccxt/pull/5748
                    let mut lowercase_currency_id: Value = currency_id.to_lower_case();
                    let mut fee_without_currency_id: Value = fee_with_currency_id.replace(lowercase_currency_id.clone(), Value::from(""));
                    fee_cost = parse_float(fee_without_currency_id.clone());
                };
            };
        };
        // todo parse tags
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": id,
            "currency": code,
            "amount": amount,
            "network": Value::Undefined,
            "addressFrom": address_from,
            "addressTo": address_to,
            "address": address,
            "tagFrom": Value::Undefined,
            "tagTo": tag_to,
            "tag": tag_to,
            "status": status,
            "type": r#type,
            "updated": Value::Undefined,
            "txid": txid,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "fee": Value::Json(normalize(&Value::Json(json!({
                "currency": code,
                "cost": fee_cost
            }))).unwrap())
        }))).unwrap());
    }

    fn parse_my_trade(&self, mut pair: Value, mut market: Value) -> Value {
        // check that trading symbols match in both entries
        let mut user_trade: Value = self.safe_value(pair.clone(), Value::from(1), Value::Undefined);
        let mut other_trade: Value = self.safe_value(pair.clone(), Value::from(0), Value::Undefined);
        let mut first_market_id: Value = self.safe_string(other_trade.clone(), Value::from("instrument_id"), Value::Undefined);
        let mut second_market_id: Value = self.safe_string(user_trade.clone(), Value::from("instrument_id"), Value::Undefined);
        if first_market_id.clone() != second_market_id.clone() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseMyTrade() received unrecognized response format, differing instrument_ids in one fill, the exchange API might have changed, paste your verbose output: https://github.com/ccxt/ccxt/wiki/FAQ#what-is-required-to-get-help"))"###);
        };
        let mut market_id: Value = first_market_id.clone();
        market = Okcoin::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut quote_id: Value = market.get(Value::from("quoteId"));
        let mut side: Value = Value::Undefined;
        let mut amount_string: Value = Value::Undefined;
        let mut cost_string: Value = Value::Undefined;
        let mut received_currency_id: Value = self.safe_string(user_trade.clone(), Value::from("currency"), Value::Undefined);
        let mut fee_currency_id: Value = Value::Undefined;
        if received_currency_id.clone() == quote_id.clone() {
            side = self.safe_string(other_trade.clone(), Value::from("side"), Value::Undefined);
            amount_string = self.safe_string(other_trade.clone(), Value::from("size"), Value::Undefined);
            cost_string = self.safe_string(user_trade.clone(), Value::from("size"), Value::Undefined);
            fee_currency_id = self.safe_string(other_trade.clone(), Value::from("currency"), Value::Undefined);
        } else {
            side = self.safe_string(user_trade.clone(), Value::from("side"), Value::Undefined);
            amount_string = self.safe_string(user_trade.clone(), Value::from("size"), Value::Undefined);
            cost_string = self.safe_string(other_trade.clone(), Value::from("size"), Value::Undefined);
            fee_currency_id = self.safe_string(user_trade.clone(), Value::from("currency"), Value::Undefined);
        };
        let mut id: Value = self.safe_string(user_trade.clone(), Value::from("trade_id"), Value::Undefined);
        let mut price_string: Value = self.safe_string(user_trade.clone(), Value::from("price"), Value::Undefined);
        let mut fee_cost_first_string: Value = self.safe_string(other_trade.clone(), Value::from("fee"), Value::Undefined);
        let mut fee_cost_second_string: Value = self.safe_string(user_trade.clone(), Value::from("fee"), Value::Undefined);
        let mut fee_currency_code_first: Value = Okcoin::safe_currency_code(self, self.safe_string(other_trade.clone(), Value::from("currency"), Value::Undefined), Value::Undefined);
        let mut fee_currency_code_second: Value = Okcoin::safe_currency_code(self, self.safe_string(user_trade.clone(), Value::from("currency"), Value::Undefined), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        let mut fees: Value = Value::Undefined;
        // fee is either a positive number (invitation rebate)
        // or a negative number (transaction fee deduction)
        // therefore we need to invert the fee
        // more about it https://github.com/ccxt/ccxt/issues/5909
        if fee_cost_first_string.clone().is_nonnullish() && !Precise::string_equals(fee_cost_first_string.clone(), Value::from("0")) {
            if fee_cost_second_string.clone().is_nonnullish() && !Precise::string_equals(fee_cost_second_string.clone(), Value::from("0")) {
                fees = Value::Json(serde_json::Value::Array(vec![Value::Json(normalize(&Value::Json(json!({
                    "cost": Precise::string_neg(fee_cost_first_string.clone()),
                    "currency": fee_currency_code_first
                }))).unwrap()).into(), Value::Json(normalize(&Value::Json(json!({
                    "cost": Precise::string_neg(fee_cost_second_string.clone()),
                    "currency": fee_currency_code_second
                }))).unwrap()).into()]));
            } else {
                fee = Value::Json(normalize(&Value::Json(json!({
                    "cost": Precise::string_neg(fee_cost_first_string.clone()),
                    "currency": fee_currency_code_first
                }))).unwrap());
            };
        } else if fee_cost_second_string.clone().is_nonnullish() && !Precise::string_equals(fee_cost_second_string.clone(), Value::from("0")) {
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": Precise::string_neg(fee_cost_second_string.clone()),
                "currency": fee_currency_code_second
            }))).unwrap());
        } else {
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": "0",
                "currency": Okcoin::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined)
            }))).unwrap());
        };
        //
        // simplified structures to show the underlying semantics
        //
        //     // market/limit sell
        //
        //     {
        //         "currency":"USDT",
        //         "fee":"-0.04647925", // --- fee in received quote currency
        //         "price":"129.13", // ------ price
        //         "size":"30.98616393", // -- cost
        //     },
        //     {
        //         "currency":"ETH",
        //         "fee":"0",
        //         "price":"129.13",
        //         "size":"0.23996099", // --- amount
        //     },
        //
        //     // market/limit buy
        //
        //     {
        //         "currency":"ETH",
        //         "fee":"-0.00036049", // --- fee in received base currency
        //         "price":"129.16", // ------ price
        //         "size":"0.240322", // ----- amount
        //     },
        //     {
        //         "currency":"USDT",
        //         "fee":"0",
        //         "price":"129.16",
        //         "size":"31.03998952", // -- cost
        //     }
        //
        let mut timestamp: Value = self.parse8601(self.safe_string_2(user_trade.clone(), Value::from("timestamp"), Value::from("created_at"), Value::Undefined));
        let mut taker_or_maker: Value = self.safe_string_2(user_trade.clone(), Value::from("exec_type"), Value::from("liquidity"), Value::Undefined);
        if taker_or_maker.clone() == Value::from("M") {
            taker_or_maker = Value::from("maker");
        } else if taker_or_maker.clone() == Value::from("T") {
            taker_or_maker = Value::from("taker");
        };
        let mut order_id: Value = self.safe_string(user_trade.clone(), Value::from("order_id"), Value::Undefined);
        return Okcoin::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "info": pair,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": symbol,
            "id": id,
            "order": order_id,
            "type": Value::Undefined,
            "takerOrMaker": taker_or_maker,
            "side": side,
            "price": price_string,
            "amount": amount_string,
            "cost": cost_string,
            "fee": fee,
            "fees": fees
        }))).unwrap()), market.clone());
    }

    fn parse_my_trades(&self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut grouped: Value = self.group_by(trades.clone(), Value::from("trade_id"), Value::Undefined);
        let mut trade_ids: Value = Object::keys(grouped.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trade_ids.len() {
            let mut trade_id: Value = trade_ids.get(i.into());
            let mut pair: Value = grouped.get(trade_id.clone());
            // make sure it has exactly 2 trades, no more, no less
            let mut num_trades_in_pair: Value = pair.len().into();
            if num_trades_in_pair.clone() == Value::from(2) {
                let mut trade: Value = Okcoin::parse_my_trade(self, pair.clone(), Value::Undefined);
                result.push(trade.clone());
            };
            i += 1;
        };
        market = Okcoin::safe_market(self, Value::Undefined, market.clone(), Value::Undefined);
        return Okcoin::filter_by_symbol_since_limit(self, result.clone(), market.get(Value::from("symbol")), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // okex actually returns ledger entries instead of fills here, so each fill in the order
        // is represented by two trades with opposite buy/sell sides, not one :\
        // this aspect renders the 'fills' endpoint unusable for fetchOrderTrades
        // until either OKEX fixes the API or we workaround this on our side somehow
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchMyTrades() requires a symbol argument"))"###);
        };
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okcoin::market(self, symbol.clone());
        if limit.clone().is_nonnullish() && limit.clone() > Value::from(100) {
            limit = Value::from(100);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instrument_id": market.get(Value::from("id"))
        }))).unwrap());
        // 'order_id': id, // string
        // 'after': '1', // pagination of data to return records earlier than the requested ledger_id
        // 'before': '1', // P=pagination of data to return records newer than the requested ledger_id
        // 'limit': limit, // optional, number of results per request, default = maximum = 100
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchMyTrades"), Value::from("defaultType"), Value::Undefined);
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        let mut method: Value = r#type.clone() + Value::from("GetFills");
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        //     [
        //         // sell
        //         {
        //             "created_at":"2020-03-29T11:55:25.000Z",
        //             "currency":"USDT",
        //             "exec_type":"T",
        //             "fee":"-0.04647925",
        //             "instrument_id":"ETH-USDT",
        //             "ledger_id":"10562924353",
        //             "liquidity":"T",
        //             "order_id":"4636470489136128",
        //             "price":"129.13",
        //             "product_id":"ETH-USDT",
        //             "side":"buy",
        //             "size":"30.98616393",
        //             "timestamp":"2020-03-29T11:55:25.000Z",
        //             "trade_id":"18551601"
        //         },
        //         {
        //             "created_at":"2020-03-29T11:55:25.000Z",
        //             "currency":"ETH",
        //             "exec_type":"T",
        //             "fee":"0",
        //             "instrument_id":"ETH-USDT",
        //             "ledger_id":"10562924352",
        //             "liquidity":"T",
        //             "order_id":"4636470489136128",
        //             "price":"129.13",
        //             "product_id":"ETH-USDT",
        //             "side":"sell",
        //             "size":"0.23996099",
        //             "timestamp":"2020-03-29T11:55:25.000Z",
        //             "trade_id":"18551601"
        //         },
        //         // buy
        //         {
        //             "created_at":"2020-03-29T11:55:16.000Z",
        //             "currency":"ETH",
        //             "exec_type":"T",
        //             "fee":"-0.00036049",
        //             "instrument_id":"ETH-USDT",
        //             "ledger_id":"10562922669",
        //             "liquidity":"T",
        //             "order_id": "4636469894136832",
        //             "price":"129.16",
        //             "product_id":"ETH-USDT",
        //             "side":"buy",
        //             "size":"0.240322",
        //             "timestamp":"2020-03-29T11:55:16.000Z",
        //             "trade_id":"18551600"
        //         },
        //         {
        //             "created_at":"2020-03-29T11:55:16.000Z",
        //             "currency":"USDT",
        //             "exec_type":"T",
        //             "fee":"0",
        //             "instrument_id":"ETH-USDT",
        //             "ledger_id":"10562922668",
        //             "liquidity":"T",
        //             "order_id":"4636469894136832",
        //             "price":"129.16",
        //             "product_id":"ETH-USDT",
        //             "side":"sell",
        //             "size":"31.03998952",
        //             "timestamp":"2020-03-29T11:55:16.000Z",
        //             "trade_id":"18551600"
        //         }
        //     ]
        //
        return Okcoin::parse_my_trades(self, response.clone(), market.clone(), since.clone(), limit.clone(), params.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all the trades made from a single order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades to retrieve
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_order_trades(&mut self, mut id: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "order_id": id
        }))).unwrap());
        // 'instrument_id': market['id'],
        // 'after': '1', // return the page after the specified page number
        // 'before': '1', // return the page before the specified page number
        // 'limit': limit, // optional, number of results per request, default = maximum = 100
        return Okcoin::fetch_my_trades(self, symbol.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
    }

    /// Returns a [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch data on a single open contract trade position
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market the position is held in, default is undefined
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_position(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Okcoin::market(self, symbol.clone());
        let mut method: Value = Value::Undefined;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "instrument_id": market.get(Value::from("id"))
        }))).unwrap());
        // 'order_id': id, // string
        // 'after': '1', // pagination of data to return records earlier than the requested ledger_id
        // 'before': '1', // P=pagination of data to return records newer than the requested ledger_id
        // 'limit': limit, // optional, number of results per request, default = maximum = 100
        let mut r#type: Value = market.get(Value::from("type"));
        if r#type.clone() == Value::from("futures") || r#type.clone() == Value::from("swap") {
            method = r#type.clone() + Value::from("GetInstrumentIdPosition");
        } else if r#type.clone() == Value::from("option") {
            let mut underlying: Value = self.safe_string(params.clone(), Value::from("underlying"), Value::Undefined);
            if underlying.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchPosition() requires an underlying parameter for ") + r#type.clone() + Value::from(" market ") + symbol.clone())"###);
            };
            method = r#type.clone() + Value::from("GetUnderlyingPosition");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPosition() does not support ") + r#type.clone() + Value::from(" market ") + symbol.clone() + Value::from(", supported market types are futures, swap or option"))"###);
        };
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // futures
        //
        //     crossed margin mode
        //
        //     {
        //         "result": true,
        //         "holding": [
        //             {
        //                 "long_qty": "2",
        //                 "long_avail_qty": "2",
        //                 "long_avg_cost": "8260",
        //                 "long_settlement_price": "8260",
        //                 "realised_pnl": "0.00020928",
        //                 "short_qty": "2",
        //                 "short_avail_qty": "2",
        //                 "short_avg_cost": "8259.99",
        //                 "short_settlement_price": "8259.99",
        //                 "liquidation_price": "113.81",
        //                 "instrument_id": "BTC-USD-191227",
        //                 "leverage": "10",
        //                 "created_at": "2019-09-25T07:58:42.129Z",
        //                 "updated_at": "2019-10-08T14:02:51.029Z",
        //                 "margin_mode": "crossed",
        //                 "short_margin": "0.00242197",
        //                 "short_pnl": "6.63E-6",
        //                 "short_pnl_ratio": "0.002477997",
        //                 "short_unrealised_pnl": "6.63E-6",
        //                 "long_margin": "0.00242197",
        //                 "long_pnl": "-6.65E-6",
        //                 "long_pnl_ratio": "-0.002478",
        //                 "long_unrealised_pnl": "-6.65E-6",
        //                 "long_settled_pnl": "0",
        //                 "short_settled_pnl": "0",
        //                 "last": "8257.57"
        //             }
        //         ],
        //         "margin_mode": "crossed"
        //     }
        //
        //     fixed margin mode
        //
        //     {
        //         "result": true,
        //         "holding": [
        //             {
        //                 "long_qty": "4",
        //                 "long_avail_qty": "4",
        //                 "long_margin": "0.00323844",
        //                 "long_liqui_price": "7762.09",
        //                 "long_pnl_ratio": "0.06052306",
        //                 "long_avg_cost": "8234.43",
        //                 "long_settlement_price": "8234.43",
        //                 "realised_pnl": "-0.00000296",
        //                 "short_qty": "2",
        //                 "short_avail_qty": "2",
        //                 "short_margin": "0.00241105",
        //                 "short_liqui_price": "9166.74",
        //                 "short_pnl_ratio": "0.03318052",
        //                 "short_avg_cost": "8295.13",
        //                 "short_settlement_price": "8295.13",
        //                 "instrument_id": "BTC-USD-191227",
        //                 "long_leverage": "15",
        //                 "short_leverage": "10",
        //                 "created_at": "2019-09-25T07:58:42.129Z",
        //                 "updated_at": "2019-10-08T13:12:09.438Z",
        //                 "margin_mode": "fixed",
        //                 "short_margin_ratio": "0.10292507",
        //                 "short_maint_margin_ratio": "0.005",
        //                 "short_pnl": "7.853E-5",
        //                 "short_unrealised_pnl": "7.853E-5",
        //                 "long_margin_ratio": "0.07103743",
        //                 "long_maint_margin_ratio": "0.005",
        //                 "long_pnl": "1.9841E-4",
        //                 "long_unrealised_pnl": "1.9841E-4",
        //                 "long_settled_pnl": "0",
        //                 "short_settled_pnl": "0",
        //                 "last": "8266.99"
        //             }
        //         ],
        //         "margin_mode": "fixed"
        //     }
        //
        // swap
        //
        //     crossed margin mode
        //
        //     {
        //         "margin_mode": "crossed",
        //         "timestamp": "2019-09-27T03:49:02.018Z",
        //         "holding": [
        //             {
        //                 "avail_position": "3",
        //                 "avg_cost": "59.49",
        //                 "instrument_id": "LTC-USD-SWAP",
        //                 "last": "55.98",
        //                 "leverage": "10.00",
        //                 "liquidation_price": "4.37",
        //                 "maint_margin_ratio": "0.0100",
        //                 "margin": "0.0536",
        //                 "position": "3",
        //                 "realized_pnl": "0.0000",
        //                 "unrealized_pnl": "0",
        //                 "settled_pnl": "-0.0330",
        //                 "settlement_price": "55.84",
        //                 "side": "long",
        //                 "timestamp": "2019-09-27T03:49:02.018Z"
        //             },
        //         ]
        //     }
        //
        //     fixed margin mode
        //
        //     {
        //         "margin_mode": "fixed",
        //         "timestamp": "2019-09-27T03:47:37.230Z",
        //         "holding": [
        //             {
        //                 "avail_position": "20",
        //                 "avg_cost": "8025.0",
        //                 "instrument_id": "BTC-USD-SWAP",
        //                 "last": "8113.1",
        //                 "leverage": "15.00",
        //                 "liquidation_price": "7002.6",
        //                 "maint_margin_ratio": "0.0050",
        //                 "margin": "0.0454",
        //                 "position": "20",
        //                 "realized_pnl": "-0.0001",
        //                 "unrealized_pnl": "0",
        //                 "settled_pnl": "0.0076",
        //                 "settlement_price": "8279.2",
        //                 "side": "long",
        //                 "timestamp": "2019-09-27T03:47:37.230Z"
        //             }
        //         ]
        //     }
        //
        // option
        //
        //     {
        //         "holding":[
        //             {
        //                 "instrument_id":"BTC-USD-190927-12500-C",
        //                 "position":"20",
        //                 "avg_cost":"3.26",
        //                 "avail_position":"20",
        //                 "settlement_price":"0.017",
        //                 "total_pnl":"50",
        //                 "pnl_ratio":"0.3",
        //                 "realized_pnl":"40",
        //                 "unrealized_pnl":"10",
        //                 "pos_margin":"100",
        //                 "option_value":"70",
        //                 "created_at":"2019-08-30T03:09:20.315Z",
        //                 "updated_at":"2019-08-30T03:40:18.318Z"
        //             },
        //             {
        //                 "instrument_id":"BTC-USD-190927-12500-P",
        //                 "position":"20",
        //                 "avg_cost":"3.26",
        //                 "avail_position":"20",
        //                 "settlement_price":"0.019",
        //                 "total_pnl":"50",
        //                 "pnl_ratio":"0.3",
        //                 "realized_pnl":"40",
        //                 "unrealized_pnl":"10",
        //                 "pos_margin":"100",
        //                 "option_value":"70",
        //                 "created_at":"2019-08-30T03:09:20.315Z",
        //                 "updated_at":"2019-08-30T03:40:18.318Z"
        //             }
        //         ]
        //     }
        //
        // todo unify parsePosition/parsePositions
        return response.clone();
    }

    /// Returns a list of [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch all open positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - not used by okcoin fetchPositions
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut method: Value = Value::Undefined;
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchPositions"), Value::from("defaultType"), Value::Undefined);
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        if r#type.clone() == Value::from("futures") || r#type.clone() == Value::from("swap") {
            method = r#type.clone() + Value::from("GetPosition");
        } else if r#type.clone() == Value::from("option") {
            let mut underlying: Value = self.safe_string(params.clone(), Value::from("underlying"), Value::Undefined);
            if underlying.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchPositions() requires an underlying parameter for ") + r#type.clone() + Value::from(" markets"))"###);
            };
            method = r#type.clone() + Value::from("GetUnderlyingPosition");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPositions() does not support ") + r#type.clone() + Value::from(" markets, supported market types are futures, swap or option"))"###);
        };
        params = self.omit(params.clone(), Value::from("type"));
        let mut response: Value = Okcoin::dispatch(self, method, params.clone(), Value::Undefined).await;
        //
        // futures
        //
        //     ...
        //
        //
        // swap
        //
        //     ...
        //
        // option
        //
        //     {
        //         "holding":[
        //             {
        //                 "instrument_id":"BTC-USD-190927-12500-C",
        //                 "position":"20",
        //                 "avg_cost":"3.26",
        //                 "avail_position":"20",
        //                 "settlement_price":"0.017",
        //                 "total_pnl":"50",
        //                 "pnl_ratio":"0.3",
        //                 "realized_pnl":"40",
        //                 "unrealized_pnl":"10",
        //                 "pos_margin":"100",
        //                 "option_value":"70",
        //                 "created_at":"2019-08-30T03:09:20.315Z",
        //                 "updated_at":"2019-08-30T03:40:18.318Z"
        //             },
        //             {
        //                 "instrument_id":"BTC-USD-190927-12500-P",
        //                 "position":"20",
        //                 "avg_cost":"3.26",
        //                 "avail_position":"20",
        //                 "settlement_price":"0.019",
        //                 "total_pnl":"50",
        //                 "pnl_ratio":"0.3",
        //                 "realized_pnl":"40",
        //                 "unrealized_pnl":"10",
        //                 "pos_margin":"100",
        //                 "option_value":"70",
        //                 "created_at":"2019-08-30T03:09:20.315Z",
        //                 "updated_at":"2019-08-30T03:40:18.318Z"
        //             }
        //         ]
        //     }
        //
        // todo unify parsePosition/parsePositions
        return response.clone();
    }

    /// Returns a [ledger structure](https://docs.ccxt.com/en/latest/manual.html#ledger-structure)
    ///
    /// Fetch the history of changes, actions done by the user or operations that altered balance of the user
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code, default is undefined
    /// * `since` {int|undefined} - timestamp in ms of the earliest ledger entry, default is undefined
    /// * `limit` {int|undefined} - max number of ledger entrys to return, default is undefined
    /// * `params` {object} - extra parameters specific to the okcoin api endpoint
    async fn fetch_ledger(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("fetchLedger"), Value::from("defaultType"), Value::Undefined);
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), default_type.clone());
        let mut query: Value = self.omit(params.clone(), Value::from("type"));
        let mut suffix: Value = if r#type.clone() == Value::from("account") { Value::from("") } else { Value::from("Accounts") };
        let mut argument: Value = Value::from("");
        let mut request: Value = Value::new_object();
        // 'from': 'id',
        // 'to': 'id',
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        let mut currency: Value = Value::Undefined;
        if r#type.clone() == Value::from("spot") {
            if code.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchLedger() requires a currency code argument for '") + r#type.clone() + Value::from("' markets"))"###);
            };
            argument = Value::from("Currency");
            currency = Okcoin::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
        } else if r#type.clone() == Value::from("futures") {
            if code.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchLedger() requires an underlying symbol for '") + r#type.clone() + Value::from("' markets"))"###);
            };
            argument = Value::from("Underlying");
            let mut market: Value = Okcoin::market(self, code.clone());
            // we intentionally put a market inside here for the swap ledgers
            let mut market_info: Value = self.safe_value(market.clone(), Value::from("info"), Value::new_object());
            let mut settlement_currency_id: Value = self.safe_string(market_info.clone(), Value::from("settlement_currency"), Value::Undefined);
            let mut settlement_currency_code: Value = Okcoin::safe_currency_code(self, settlement_currency_id.clone(), Value::Undefined);
            currency = Okcoin::currency(self, settlement_currency_code.clone());
            let mut underlying_id: Value = self.safe_string(market_info.clone(), Value::from("underlying"), Value::Undefined);
            request.set("underlying".into(), underlying_id.clone());
        } else if r#type.clone() == Value::from("swap") {
            if code.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchLedger() requires a code argument (a market symbol) for '") + r#type.clone() + Value::from("' markets"))"###);
            };
            argument = Value::from("InstrumentId");
            let mut market: Value = Okcoin::market(self, code.clone());
            // we intentionally put a market inside here for the swap ledgers
            currency = Okcoin::currency(self, market.get(Value::from("base")));
            request.set("instrument_id".into(), market.get(Value::from("id")));
        } else if r#type.clone() == Value::from("account") {
            //
            //     if (type === 'margin') {
            //         //
            //         //      3. Borrow
            //         //      4. Repayment
            //         //      5. Interest
            //         //      7. Buy
            //         //      8. Sell
            //         //      9. From capital account
            //         //     10. From C2C
            //         //     11. From Futures
            //         //     12. From Spot
            //         //     13. From ETT
            //         //     14. To capital account
            //         //     15. To C2C
            //         //     16. To Spot
            //         //     17. To Futures
            //         //     18. To ETT
            //         //     19. Mandatory Repayment
            //         //     20. From Piggybank
            //         //     21. To Piggybank
            //         //     22. From Perpetual
            //         //     23. To Perpetual
            //         //     24. Liquidation Fee
            //         //     54. Clawback
            //         //     59. Airdrop Return.
            //         //
            //         request['type'] = 'number'; // All types will be returned if this filed is left blank
            //     }
            //
            if code.clone().is_nonnullish() {
                currency = Okcoin::currency(self, code.clone());
                request.set("currency".into(), currency.get(Value::from("id")));
            };
        } else {
            //
            //     //
            //     //      1. deposit
            //     //      2. withdrawal
            //     //     13. cancel withdrawal
            //     //     18. into futures account
            //     //     19. out of futures account
            //     //     20. into sub account
            //     //     21. out of sub account
            //     //     28. claim
            //     //     29. into ETT account
            //     //     30. out of ETT account
            //     //     31. into C2C account
            //     //     32. out of C2C account
            //     //     33. into margin account
            //     //     34. out of margin account
            //     //     37. into spot account
            //     //     38. out of spot account
            //     //
            //     request['type'] = 'number';
            //
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchLedger does not support the '") + r#type.clone() + Value::from("' type (the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')"))"###);
        };
        let mut method: Value = r#type.clone() + Value::from("Get") + suffix.clone() + argument.clone() + Value::from("Ledger");
        let mut response: Value = Okcoin::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // transfer     funds transfer in/out
        // trade        funds moved as a result of a trade, spot accounts only
        // rebate       fee rebate as per fee schedule, spot accounts only
        // match        open long/open short/close long/close short (futures) or a change in the amount because of trades (swap)
        // fee          fee, futures only
        // settlement   settlement/clawback/settle long/settle short
        // liquidation  force close long/force close short/deliver close long/deliver close short
        // funding      funding fee, swap only
        // margin       a change in the amount after adjusting margin, swap only
        //
        // account
        //
        //     [
        //         {
        //             "amount":0.00051843,
        //             "balance":0.00100941,
        //             "currency":"BTC",
        //             "fee":0,
        //             "ledger_id":8987285,
        //             "timestamp":"2018-10-12T11:01:14.000Z",
        //             "typename":"Get from activity"
        //         }
        //     ]
        //
        // spot
        //
        //     [
        //         {
        //             "timestamp":"2019-03-18T07:08:25.000Z",
        //             "ledger_id":"3995334780",
        //             "created_at":"2019-03-18T07:08:25.000Z",
        //             "currency":"BTC",
        //             "amount":"0.0009985",
        //             "balance":"0.0029955",
        //             "type":"trade",
        //             "details":{
        //                 "instrument_id":"BTC-USDT",
        //                 "order_id":"2500650881647616",
        //                 "product_id":"BTC-USDT"
        //             }
        //         }
        //     ]
        //
        // futures
        //
        //     [
        //         {
        //             "ledger_id":"2508090544914461",
        //             "timestamp":"2019-03-19T14:40:24.000Z",
        //             "amount":"-0.00529521",
        //             "balance":"0",
        //             "currency":"EOS",
        //             "type":"fee",
        //             "details":{
        //                 "order_id":"2506982456445952",
        //                 "instrument_id":"EOS-USD-190628"
        //             }
        //         }
        //     ]
        //
        // swap
        //
        //     [
        //         {
        //             "amount":"0.004742",
        //             "fee":"-0.000551",
        //             "type":"match",
        //             "instrument_id":"EOS-USD-SWAP",
        //             "ledger_id":"197429674941902848",
        //             "timestamp":"2019-03-25T05:56:31.286Z"
        //         },
        //     ]
        //
        let mut response_length: Value = response.len().into();
        if response_length.clone() < Value::from(1) {
            return Value::new_array();
        };
        if r#type.clone() == Value::from("swap") {
            let mut ledger_entries: Value = Okcoin::parse_ledger(self, response.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
            return Okcoin::filter_by_symbol_since_limit(self, ledger_entries.clone(), code.clone(), since.clone(), limit.clone(), Value::Undefined);
        };
        return Okcoin::parse_ledger(self, response.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_ledger_entry_type(&self, mut r#type: Value) -> Value {
        let mut types: Value = Value::Json(normalize(&Value::Json(json!({
            "transfer": "transfer",
            "trade": "trade",
            "rebate": "rebate",
            "match": "trade",
            "fee": "fee",
            "settlement": "trade",
            "liquidation": "trade",
            "funding": "fee",
            "margin": "margin"
        }))).unwrap());
        // // funds transfer in/out
        // funds moved as a result of a trade, spot accounts only
        // fee rebate as per fee schedule, spot accounts only
        // open long/open short/close long/close short (futures) or a change in the amount because of trades (swap)
        // fee, futures only
        // settlement/clawback/settle long/settle short
        // force close long/force close short/deliver close long/deliver close short
        // funding fee, swap only
        // a change in the amount after adjusting margin, swap only
        return self.safe_string(types.clone(), r#type.clone(), r#type.clone());
    }

    fn parse_ledger_entry(&self, mut item: Value, mut currency: Value) -> Value {
        //
        //
        // account
        //
        //     {
        //         "amount":0.00051843,
        //         "balance":0.00100941,
        //         "currency":"BTC",
        //         "fee":0,
        //         "ledger_id":8987285,
        //         "timestamp":"2018-10-12T11:01:14.000Z",
        //         "typename":"Get from activity"
        //     }
        //
        // spot
        //
        //     {
        //         "timestamp":"2019-03-18T07:08:25.000Z",
        //         "ledger_id":"3995334780",
        //         "created_at":"2019-03-18T07:08:25.000Z",
        //         "currency":"BTC",
        //         "amount":"0.0009985",
        //         "balance":"0.0029955",
        //         "type":"trade",
        //         "details":{
        //             "instrument_id":"BTC-USDT",
        //             "order_id":"2500650881647616",
        //             "product_id":"BTC-USDT"
        //         }
        //     }
        //
        // futures
        //
        //     {
        //         "ledger_id":"2508090544914461",
        //         "timestamp":"2019-03-19T14:40:24.000Z",
        //         "amount":"-0.00529521",
        //         "balance":"0",
        //         "currency":"EOS",
        //         "type":"fee",
        //         "details":{
        //             "order_id":"2506982456445952",
        //             "instrument_id":"EOS-USD-190628"
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "amount":"0.004742",
        //         "fee":"-0.000551",
        //         "type":"match",
        //         "instrument_id":"EOS-USD-SWAP",
        //         "ledger_id":"197429674941902848",
        //         "timestamp":"2019-03-25T05:56:31.286Z"
        //     },
        //
        let mut id: Value = self.safe_string(item.clone(), Value::from("ledger_id"), Value::Undefined);
        let mut account: Value = Value::Undefined;
        let mut details: Value = self.safe_value(item.clone(), Value::from("details"), Value::new_object());
        let mut reference_id: Value = self.safe_string(details.clone(), Value::from("order_id"), Value::Undefined);
        let mut reference_account: Value = Value::Undefined;
        let mut r#type: Value = Okcoin::parse_ledger_entry_type(self, self.safe_string(item.clone(), Value::from("type"), Value::Undefined));
        let mut code: Value = Okcoin::safe_currency_code(self, self.safe_string(item.clone(), Value::from("currency"), Value::Undefined), currency.clone());
        let mut amount: Value = Okcoin::safe_number(self, item.clone(), Value::from("amount"), Value::Undefined);
        let mut timestamp: Value = self.parse8601(self.safe_string(item.clone(), Value::from("timestamp"), Value::Undefined));
        let mut fee: Value = Value::Json(normalize(&Value::Json(json!({
            "cost": Okcoin::safe_number(self, item.clone(), Value::from("fee"), Value::Undefined),
            "currency": code
        }))).unwrap());
        let mut before: Value = Value::Undefined;
        let mut after: Value = Okcoin::safe_number(self, item.clone(), Value::from("balance"), Value::Undefined);
        let mut status: Value = Value::from("ok");
        let mut market_id: Value = self.safe_string(item.clone(), Value::from("instrument_id"), Value::Undefined);
        let mut symbol: Value = Value::Undefined;
        if self.get("markets_by_id".into()).contains_key(market_id.clone()) {
            let mut market: Value = self.get("markets_by_id".into()).get(market_id.clone());
            symbol = market.get(Value::from("symbol"));
        };
        return Value::Json(normalize(&Value::Json(json!({
            "info": item,
            "id": id,
            "account": account,
            "referenceId": reference_id,
            "referenceAccount": reference_account,
            "type": r#type,
            "currency": code,
            "symbol": symbol,
            "amount": amount,
            "before": before,
            "after": after,
            "status": status,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "fee": fee
        }))).unwrap());
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        let mut is_array: Value = Array::is_array(params.clone());
        let mut request: Value = Value::from("/api/") + api.clone() + Value::from("/") + self.get("version".into()) + Value::from("/");
        request = request +  if is_array.is_truthy() { path.clone() } else { self.implode_params(path.clone(), params.clone()) };
        let mut query: Value = if is_array.is_truthy() { params.clone() } else { self.omit(params.clone(), self.extract_params(path.clone())) };
        let mut url: Value = Okcoin::implode_hostname(self, self.get("urls".into()).get(Value::from("api")).get(Value::from("rest"))) + request.clone();
        let mut r#type: Value = Okcoin::get_path_authentication_type(self, path.clone());
        if r#type.clone() == Value::from("public") || r#type.clone() == Value::from("information") {
            if Object::keys(query.clone()).len() > 0 {
                url = url +  Value::from("?") + self.urlencode(query.clone());
            };
        } else if r#type.clone() == Value::from("private") {
            Okcoin::check_required_credentials(self, Value::Undefined);
            let mut timestamp: Value = self.iso8601(self.milliseconds());
            headers = Value::Json(normalize(&Value::Json(json!({
                "OK-ACCESS-KEY": self.get("apiKey".into()),
                "OK-ACCESS-PASSPHRASE": self.get("password".into()),
                "OK-ACCESS-TIMESTAMP": timestamp
            }))).unwrap());
            // 'OK-FROM': '',
            // 'OK-TO': '',
            // 'OK-LIMIT': '',
            let mut auth: Value = timestamp.clone() + method.clone() + request.clone();
            if method.clone() == Value::from("GET") {
                if Object::keys(query.clone()).len() > 0 {
                    let mut urlencoded_query: Value = Value::from("?") + self.urlencode(query.clone());
                    url = url +  urlencoded_query.clone();
                    auth = auth +  urlencoded_query.clone();
                };
            } else {
                if is_array.is_truthy() || Object::keys(query.clone()).len() > 0 {
                    body = self.json(query.clone(), Value::Undefined);
                    auth = auth +  body.clone();
                };
                headers.set("Content-Type".into(), Value::from("application/json"));
            };
            let mut signature: Value = self.hmac(self.encode(auth.clone()), self.encode(self.get("secret".into())), Value::from("sha256"), Value::from("base64"));
            headers.set("OK-ACCESS-SIGN".into(), signature.clone());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn get_path_authentication_type(&mut self, mut path: Value) -> Value {
        // https://github.com/ccxt/ccxt/issues/6651
        // a special case to handle the optionGetUnderlying interefering with
        // other endpoints containing this keyword
        if path.clone() == Value::from("underlying") {
            return Value::from("public");
        };
        let mut auth: Value = self.safe_value(self.get("options".into()), Value::from("auth"), Value::new_object());
        let mut key: Value = Okcoin::find_broadly_matched_key(self, auth.clone(), path.clone());
        return self.safe_string(auth.clone(), key.clone(), Value::from("private"));
    }

    fn handle_errors(&mut self, mut code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if !response.is_truthy() {
            return Value::Undefined;
        };
        // fallback to default error handler
        let mut feedback: Value = self.get("id".into()) + Value::from(" ") + body.clone();
        if code.clone() == Value::from(503) {
            // {"message":"name resolution failed"}
            panic!(r###"ExchangeNotAvailable::new(feedback)"###);
        };
        //
        //     {"error_message":"Order does not exist","result":"true","error_code":"35029","order_id":"-1"}
        //
        let mut message: Value = self.safe_string(response.clone(), Value::from("message"), Value::Undefined);
        let mut error_code: Value = self.safe_string_2(response.clone(), Value::from("code"), Value::from("error_code"), Value::Undefined);
        let mut non_empty_message: Value = (message.clone().is_nonnullish() && message.clone() != Value::from("")).into();
        let mut non_zero_error_code: Value = (error_code.clone().is_nonnullish() && error_code.clone() != Value::from("0")).into();
        if non_empty_message.is_truthy() {
            Okcoin::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), message.clone(), feedback.clone());
            Okcoin::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), message.clone(), feedback.clone());
        };
        if non_zero_error_code.is_truthy() {
            Okcoin::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), error_code.clone(), feedback.clone());
        };
        if non_zero_error_code.is_truthy() || non_empty_message.is_truthy() {
            panic!(r###"ExchangeError::new(feedback)"###);
        };
        Value::Undefined
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Okcoin::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Okcoin::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Okcoin::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Okcoin::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Okcoin::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Okcoin::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Okcoin::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Okcoin::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Okcoin::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Okcoin::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Okcoin::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Okcoin::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Okcoin::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Okcoin::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Okcoin::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Okcoin::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Okcoin::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Okcoin::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Okcoin::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Okcoin::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Okcoin::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Okcoin::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Okcoin::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Okcoin::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Okcoin::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Okcoin::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Okcoin::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Okcoin::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Okcoin::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Okcoin::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Okcoin::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Okcoin::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Okcoin::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Okcoin::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Okcoin::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut bids: Value = Okcoin::parse_bids_asks(self, self.safe_value(orderbook.clone(), bids_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        let mut asks: Value = Okcoin::parse_bids_asks(self, self.safe_value(orderbook.clone(), asks_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Okcoin::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = Okcoin::market_symbols(self, symbols.clone());
        let mut tiers: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut market: Value = Okcoin::safe_market(self, id.clone(), Value::Undefined, Value::Undefined);
            let mut symbol: Value = market.get(Value::from("symbol"));
            let mut contract: Value = self.safe_value(market.clone(), Value::from("contract"), false.into());
            if contract.is_truthy() && symbols.clone().is_nullish() || self.in_array(symbol.clone(), symbols.clone()).is_truthy() {
                tiers.set(symbol.clone(), self.parse_market_leverage_tiers(item.clone(), market.clone()));
            };
            i += 1;
        };
        return tiers.clone();
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = self.fetch_trading_limits(symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Okcoin::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(self.parse_position(positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Okcoin::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Okcoin::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Okcoin::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Okcoin::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Okcoin::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Okcoin::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(Okcoin::parse_transfer(self, transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Okcoin::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = Okcoin::parse_ledger_entry(self, array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Okcoin::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn nonce(&self) -> Value {
        return self.seconds();
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Okcoin::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Okcoin::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Okcoin::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Okcoin::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Okcoin::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), self.fetch_accounts(params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Okcoin::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Okcoin::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Okcoin::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::cancel_order(self, id.clone(), symbol.clone(), Value::Undefined).await;
        return Okcoin::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Okcoin::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Okcoin::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Okcoin::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Okcoin::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Okcoin::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Okcoin::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTime")).is_truthy() {
            let mut time: Value = Okcoin::fetch_time(self, params.clone()).await;
            self.set("status".into(), extend_2(self.get("status".into()), Value::Json(normalize(&Value::Json(json!({
                "updated": time
            }))).unwrap())));
        };
        return self.get("status".into());
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Okcoin::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Okcoin::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Okcoin::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
        if !self.get("has".into()).get(Value::from("fetchBorrowRates")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBorrowRate() is not supported yet"))"###);
        };
        let mut borrow_rates: Value = self.fetch_borrow_rates(params.clone()).await;
        let mut rate: Value = self.safe_value(borrow_rates.clone(), code.clone(), Value::Undefined);
        if rate.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchBorrowRate() could not find the borrow rate for currency code ") + code.clone())"###);
        };
        return rate.clone();
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Okcoin::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Okcoin::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrders() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Okcoin::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        let mut market: Value = Okcoin::market(self, symbol.clone());
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Okcoin::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Okcoin::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Okcoin::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = Okcoin::fetch_time(self, params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchLeverageTiers")).is_truthy() {
            let mut market: Value = Okcoin::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() supports contract markets only"))"###);
            };
            let mut tiers: Value = self.fetch_leverage_tiers(Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::Undefined).await;
            return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() is not supported yet"))"###);
        };
        Value::Undefined
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Okcoin::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Okcoin::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Okcoin::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Okcoin::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Okcoin::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Okcoin::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Okcoin::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Okcoin::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Okcoin::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Okcoin::market_symbols(self, symbols.clone());
        return Okcoin::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(Okcoin::parse_deposit_address(self, addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Okcoin::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(self.parse_borrow_interest(row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Okcoin::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Okcoin::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseFundingRate() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Okcoin::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFees() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTradingFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFee() is not supported yet"))"###);
        };
        return Okcoin::fetch_trading_fees(self, params.clone()).await;
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" parseOpenInterest () is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Okcoin::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Okcoin::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchFundingRates")).is_truthy() {
            Okcoin::load_markets(self, Value::Undefined, Value::Undefined).await;
            let mut market: Value = Okcoin::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchFundingRate() supports contract markets only"))"###);
            };
            let mut rates: Value = self.fetch_funding_rates(Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), params.clone()).await;
            let mut rate: Value = self.safe_value(rates.clone(), symbol.clone(), Value::Undefined);
            if rate.clone().is_nullish() {
                panic!(r###"NullResponse::new(self.get("id".into()) + Value::from(" fetchFundingRate () returned no data for ") + symbol.clone())"###);
            } else {
                return rate.clone();
            };
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingRate () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Okcoin::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Okcoin::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Okcoin::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns the exchange specific account name or the isolated margin id for transfers
    ///
    /// @ignore
    /// * Must add accountsByType to this.options to use this method
    ///
    /// # Arguments
    ///
    /// * `account` {string} - key for account name in this.options['accountsByType']
    fn parse_account(&self, mut account: Value) -> Value {
        let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
        let mut symbols: Value = self.get("symbols".into());
        if accounts_by_type.contains_key(account.clone()) {
            return accounts_by_type.get(account.clone());
        } else if self.in_array(account.clone(), symbols.clone()).is_truthy() {
            let mut market: Value = Okcoin::market(self, account.clone());
            return market.get(Value::from("id"));
        } else {
            return account.clone();
        };
        Value::Undefined
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Okcoin::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Okcoin::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Okcoin::fetch_markets(self, params.clone()).await;
        return Okcoin::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Okcoin::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "generalGetTime" => Okcoin::request(self, "time".into(), "general".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetWallet" => Okcoin::request(self, "wallet".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetSubAccount" => Okcoin::request(self, "sub-account".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetAssetValuation" => Okcoin::request(self, "asset-valuation".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetWalletCurrency" => Okcoin::request(self, "wallet/{currency}".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetWithdrawalHistory" => Okcoin::request(self, "withdrawal/history".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetWithdrawalHistoryCurrency" => Okcoin::request(self, "withdrawal/history/{currency}".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetLedger" => Okcoin::request(self, "ledger".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetDepositAddress" => Okcoin::request(self, "deposit/address".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetDepositHistory" => Okcoin::request(self, "deposit/history".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetDepositHistoryCurrency" => Okcoin::request(self, "deposit/history/{currency}".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetCurrencies" => Okcoin::request(self, "currencies".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetWithdrawalFee" => Okcoin::request(self, "withdrawal/fee".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetDepositLightning" => Okcoin::request(self, "deposit-lightning".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetWithdrawalLightning" => Okcoin::request(self, "withdrawal-lightning".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetFiatDepositDetail" => Okcoin::request(self, "fiat/deposit/detail".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetFiatDepositDetails" => Okcoin::request(self, "fiat/deposit/details".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetFiatWithdrawDetail" => Okcoin::request(self, "fiat/withdraw/detail".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetFiatWithdrawDetails" => Okcoin::request(self, "fiat/withdraw/details".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountGetFiatChannel" => Okcoin::request(self, "fiat/channel".into(), "account".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountPostTransfer" => Okcoin::request(self, "transfer".into(), "account".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountPostWithdrawal" => Okcoin::request(self, "withdrawal".into(), "account".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountPostFiatCancelDeposit" => Okcoin::request(self, "fiat/cancel_deposit".into(), "account".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountPostFiatDeposit" => Okcoin::request(self, "fiat/deposit".into(), "account".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountPostFiatWithdraw" => Okcoin::request(self, "fiat/withdraw".into(), "account".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "accountPostFiatCancelWithdrawal" => Okcoin::request(self, "fiat/cancel_withdrawal".into(), "account".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "otcGetRfqInstruments" => Okcoin::request(self, "rfq/instruments".into(), "otc".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "otcGetRfqTrade" => Okcoin::request(self, "rfq/trade".into(), "otc".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "otcGetRfqHistory" => Okcoin::request(self, "rfq/history".into(), "otc".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "otcPostRfqQuote" => Okcoin::request(self, "rfq/quote".into(), "otc".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "otcPostRfqTrade" => Okcoin::request(self, "rfq/trade".into(), "otc".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "usersGetSubaccountInfo" => Okcoin::request(self, "subaccount-info".into(), "users".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "usersGetAccountInfo" => Okcoin::request(self, "account-info".into(), "users".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "usersGetSubaccountApikey" => Okcoin::request(self, "subaccount/apikey".into(), "users".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "usersPostCreateSubaccount" => Okcoin::request(self, "create-subaccount".into(), "users".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "usersPostDeleteSubaccount" => Okcoin::request(self, "delete-subaccount".into(), "users".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "usersPostSubaccountApikey" => Okcoin::request(self, "subaccount/apikey".into(), "users".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "usersPostSubacountDeleteApikey" => Okcoin::request(self, "subacount/delete-apikey".into(), "users".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "usersPostSubacountModifyApikey" => Okcoin::request(self, "subacount/modify-apikey".into(), "users".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "earningGetOffers" => Okcoin::request(self, "offers".into(), "earning".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "earningGetOrders" => Okcoin::request(self, "orders".into(), "earning".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "earningGetPositions" => Okcoin::request(self, "positions".into(), "earning".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "earningPostPurchase" => Okcoin::request(self, "purchase".into(), "earning".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "earningPostRedeem" => Okcoin::request(self, "redeem".into(), "earning".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "earningPostCancel" => Okcoin::request(self, "cancel".into(), "earning".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetAccounts" => Okcoin::request(self, "accounts".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetAccountsCurrency" => Okcoin::request(self, "accounts/{currency}".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetAccountsCurrencyLedger" => Okcoin::request(self, "accounts/{currency}/ledger".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetOrders" => Okcoin::request(self, "orders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetOrdersPending" => Okcoin::request(self, "orders_pending".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetOrdersOrderId" => Okcoin::request(self, "orders/{order_id}".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetOrdersClientOid" => Okcoin::request(self, "orders/{client_oid}".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetTradeFee" => Okcoin::request(self, "trade_fee".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetFills" => Okcoin::request(self, "fills".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetAlgo" => Okcoin::request(self, "algo".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetInstruments" => Okcoin::request(self, "instruments".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetInstrumentsInstrumentIdBook" => Okcoin::request(self, "instruments/{instrument_id}/book".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetInstrumentsTicker" => Okcoin::request(self, "instruments/ticker".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetInstrumentsInstrumentIdTicker" => Okcoin::request(self, "instruments/{instrument_id}/ticker".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetInstrumentsInstrumentIdTrades" => Okcoin::request(self, "instruments/{instrument_id}/trades".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotGetInstrumentsInstrumentIdCandles" => Okcoin::request(self, "instruments/{instrument_id}/candles".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPostOrderAlgo" => Okcoin::request(self, "order_algo".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPostOrders" => Okcoin::request(self, "orders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPostBatchOrders" => Okcoin::request(self, "batch_orders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPostCancelOrdersOrderId" => Okcoin::request(self, "cancel_orders/{order_id}".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPostCancelOrdersClientOid" => Okcoin::request(self, "cancel_orders/{client_oid}".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPostCancelBatchAlgos" => Okcoin::request(self, "cancel_batch_algos".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPostCancelBatchOrders" => Okcoin::request(self, "cancel_batch_orders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPostAmendOrderInstrumentId" => Okcoin::request(self, "amend_order/{instrument_id}".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPostAmendBatchOrders" => Okcoin::request(self, "amend_batch_orders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetAccounts" => Okcoin::request(self, "accounts".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetAccountsInstrumentId" => Okcoin::request(self, "accounts/{instrument_id}".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetAccountsInstrumentIdLedger" => Okcoin::request(self, "accounts/{instrument_id}/ledger".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetAccountsAvailability" => Okcoin::request(self, "accounts/availability".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetAccountsInstrumentIdAvailability" => Okcoin::request(self, "accounts/{instrument_id}/availability".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetAccountsBorrowed" => Okcoin::request(self, "accounts/borrowed".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetAccountsInstrumentIdBorrowed" => Okcoin::request(self, "accounts/{instrument_id}/borrowed".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetOrders" => Okcoin::request(self, "orders".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetAccountsInstrumentIdLeverage" => Okcoin::request(self, "accounts/{instrument_id}/leverage".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetOrdersOrderId" => Okcoin::request(self, "orders/{order_id}".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetOrdersClientOid" => Okcoin::request(self, "orders/{client_oid}".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetOrdersPending" => Okcoin::request(self, "orders_pending".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetFills" => Okcoin::request(self, "fills".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginGetInstrumentsInstrumentIdMarkPrice" => Okcoin::request(self, "instruments/{instrument_id}/mark_price".into(), "margin".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginPostAccountsBorrow" => Okcoin::request(self, "accounts/borrow".into(), "margin".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginPostAccountsRepayment" => Okcoin::request(self, "accounts/repayment".into(), "margin".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginPostOrders" => Okcoin::request(self, "orders".into(), "margin".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginPostBatchOrders" => Okcoin::request(self, "batch_orders".into(), "margin".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginPostCancelOrders" => Okcoin::request(self, "cancel_orders".into(), "margin".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginPostCancelOrdersOrderId" => Okcoin::request(self, "cancel_orders/{order_id}".into(), "margin".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginPostCancelOrdersClientOid" => Okcoin::request(self, "cancel_orders/{client_oid}".into(), "margin".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginPostCancelBatchOrders" => Okcoin::request(self, "cancel_batch_orders".into(), "margin".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginPostAmendOrderInstrumentId" => Okcoin::request(self, "amend_order/{instrument_id}".into(), "margin".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginPostAmendBatchOrders" => Okcoin::request(self, "amend_batch_orders".into(), "margin".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marginPostAccountsInstrumentIdLeverage" => Okcoin::request(self, "accounts/{instrument_id}/leverage".into(), "margin".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "systemGetStatus" => Okcoin::request(self, "status".into(), "system".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetOracle" => Okcoin::request(self, "oracle".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetPosition" => Okcoin::request(self, "position".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentIdPosition" => Okcoin::request(self, "{instrument_id}/position".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetAccounts" => Okcoin::request(self, "accounts".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetAccountsUnderlying" => Okcoin::request(self, "accounts/{underlying}".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetAccountsUnderlyingLeverage" => Okcoin::request(self, "accounts/{underlying}/leverage".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetAccountsUnderlyingLedger" => Okcoin::request(self, "accounts/{underlying}/ledger".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetOrderAlgoInstrumentId" => Okcoin::request(self, "order_algo/{instrument_id}".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetOrdersInstrumentId" => Okcoin::request(self, "orders/{instrument_id}".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetOrdersInstrumentIdOrderId" => Okcoin::request(self, "orders/{instrument_id}/{order_id}".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetOrdersInstrumentIdClientOid" => Okcoin::request(self, "orders/{instrument_id}/{client_oid}".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetFills" => Okcoin::request(self, "fills".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetTradeFee" => Okcoin::request(self, "trade_fee".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetAccountsInstrumentIdHolds" => Okcoin::request(self, "accounts/{instrument_id}/holds".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstruments" => Okcoin::request(self, "instruments".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentsInstrumentIdBook" => Okcoin::request(self, "instruments/{instrument_id}/book".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentsTicker" => Okcoin::request(self, "instruments/ticker".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentsInstrumentIdTicker" => Okcoin::request(self, "instruments/{instrument_id}/ticker".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentsInstrumentIdTrades" => Okcoin::request(self, "instruments/{instrument_id}/trades".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentsInstrumentIdCandles" => Okcoin::request(self, "instruments/{instrument_id}/candles".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentsInstrumentIdHistoryCandles" => Okcoin::request(self, "instruments/{instrument_id}/history/candles".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentsInstrumentIdIndex" => Okcoin::request(self, "instruments/{instrument_id}/index".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetRate" => Okcoin::request(self, "rate".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentsInstrumentIdEstimatedPrice" => Okcoin::request(self, "instruments/{instrument_id}/estimated_price".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentsInstrumentIdOpenInterest" => Okcoin::request(self, "instruments/{instrument_id}/open_interest".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentsInstrumentIdPriceLimit" => Okcoin::request(self, "instruments/{instrument_id}/price_limit".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentsInstrumentIdMarkPrice" => Okcoin::request(self, "instruments/{instrument_id}/mark_price".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresGetInstrumentsInstrumentIdLiquidation" => Okcoin::request(self, "instruments/{instrument_id}/liquidation".into(), "futures".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPostAccountsUnderlyingLeverage" => Okcoin::request(self, "accounts/{underlying}/leverage".into(), "futures".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPostOrder" => Okcoin::request(self, "order".into(), "futures".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPostAmendOrderInstrumentId" => Okcoin::request(self, "amend_order/{instrument_id}".into(), "futures".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPostOrders" => Okcoin::request(self, "orders".into(), "futures".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPostCancelOrderInstrumentIdOrderId" => Okcoin::request(self, "cancel_order/{instrument_id}/{order_id}".into(), "futures".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPostCancelOrderInstrumentIdClientOid" => Okcoin::request(self, "cancel_order/{instrument_id}/{client_oid}".into(), "futures".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPostCancelBatchOrdersInstrumentId" => Okcoin::request(self, "cancel_batch_orders/{instrument_id}".into(), "futures".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPostAccountsMarginMode" => Okcoin::request(self, "accounts/margin_mode".into(), "futures".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPostClosePosition" => Okcoin::request(self, "close_position".into(), "futures".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPostCancelAll" => Okcoin::request(self, "cancel_all".into(), "futures".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPostOrderAlgo" => Okcoin::request(self, "order_algo".into(), "futures".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "futuresPostCancelAlgos" => Okcoin::request(self, "cancel_algos".into(), "futures".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetPosition" => Okcoin::request(self, "position".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentIdPosition" => Okcoin::request(self, "{instrument_id}/position".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetAccounts" => Okcoin::request(self, "accounts".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentIdAccounts" => Okcoin::request(self, "{instrument_id}/accounts".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetAccountsInstrumentIdSettings" => Okcoin::request(self, "accounts/{instrument_id}/settings".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetAccountsInstrumentIdLedger" => Okcoin::request(self, "accounts/{instrument_id}/ledger".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetOrdersInstrumentId" => Okcoin::request(self, "orders/{instrument_id}".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetOrdersInstrumentIdOrderId" => Okcoin::request(self, "orders/{instrument_id}/{order_id}".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetOrdersInstrumentIdClientOid" => Okcoin::request(self, "orders/{instrument_id}/{client_oid}".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetFills" => Okcoin::request(self, "fills".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetAccountsInstrumentIdHolds" => Okcoin::request(self, "accounts/{instrument_id}/holds".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetTradeFee" => Okcoin::request(self, "trade_fee".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetOrderAlgoInstrumentId" => Okcoin::request(self, "order_algo/{instrument_id}".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstruments" => Okcoin::request(self, "instruments".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsInstrumentIdDepth" => Okcoin::request(self, "instruments/{instrument_id}/depth".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsTicker" => Okcoin::request(self, "instruments/ticker".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsInstrumentIdTicker" => Okcoin::request(self, "instruments/{instrument_id}/ticker".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsInstrumentIdTrades" => Okcoin::request(self, "instruments/{instrument_id}/trades".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsInstrumentIdCandles" => Okcoin::request(self, "instruments/{instrument_id}/candles".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsInstrumentIdHistoryCandles" => Okcoin::request(self, "instruments/{instrument_id}/history/candles".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsInstrumentIdIndex" => Okcoin::request(self, "instruments/{instrument_id}/index".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetRate" => Okcoin::request(self, "rate".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsInstrumentIdOpenInterest" => Okcoin::request(self, "instruments/{instrument_id}/open_interest".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsInstrumentIdPriceLimit" => Okcoin::request(self, "instruments/{instrument_id}/price_limit".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsInstrumentIdLiquidation" => Okcoin::request(self, "instruments/{instrument_id}/liquidation".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsInstrumentIdFundingTime" => Okcoin::request(self, "instruments/{instrument_id}/funding_time".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsInstrumentIdMarkPrice" => Okcoin::request(self, "instruments/{instrument_id}/mark_price".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapGetInstrumentsInstrumentIdHistoricalFundingRate" => Okcoin::request(self, "instruments/{instrument_id}/historical_funding_rate".into(), "swap".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapPostAccountsInstrumentIdLeverage" => Okcoin::request(self, "accounts/{instrument_id}/leverage".into(), "swap".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapPostOrder" => Okcoin::request(self, "order".into(), "swap".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapPostAmendOrderInstrumentId" => Okcoin::request(self, "amend_order/{instrument_id}".into(), "swap".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapPostOrders" => Okcoin::request(self, "orders".into(), "swap".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapPostCancelOrderInstrumentIdOrderId" => Okcoin::request(self, "cancel_order/{instrument_id}/{order_id}".into(), "swap".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapPostCancelOrderInstrumentIdClientOid" => Okcoin::request(self, "cancel_order/{instrument_id}/{client_oid}".into(), "swap".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapPostCancelBatchOrdersInstrumentId" => Okcoin::request(self, "cancel_batch_orders/{instrument_id}".into(), "swap".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapPostOrderAlgo" => Okcoin::request(self, "order_algo".into(), "swap".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapPostCancelAlgos" => Okcoin::request(self, "cancel_algos".into(), "swap".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapPostClosePosition" => Okcoin::request(self, "close_position".into(), "swap".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "swapPostCancelAll" => Okcoin::request(self, "cancel_all".into(), "swap".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetAccounts" => Okcoin::request(self, "accounts".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetPosition" => Okcoin::request(self, "position".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetUnderlyingPosition" => Okcoin::request(self, "{underlying}/position".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetAccountsUnderlying" => Okcoin::request(self, "accounts/{underlying}".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetOrdersUnderlying" => Okcoin::request(self, "orders/{underlying}".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetFillsUnderlying" => Okcoin::request(self, "fills/{underlying}".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetAccountsUnderlyingLedger" => Okcoin::request(self, "accounts/{underlying}/ledger".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetTradeFee" => Okcoin::request(self, "trade_fee".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetOrdersUnderlyingOrderId" => Okcoin::request(self, "orders/{underlying}/{order_id}".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetOrdersUnderlyingClientOid" => Okcoin::request(self, "orders/{underlying}/{client_oid}".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetUnderlying" => Okcoin::request(self, "underlying".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetInstrumentsUnderlying" => Okcoin::request(self, "instruments/{underlying}".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetInstrumentsUnderlyingSummary" => Okcoin::request(self, "instruments/{underlying}/summary".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetInstrumentsUnderlyingSummaryInstrumentId" => Okcoin::request(self, "instruments/{underlying}/summary/{instrument_id}".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetInstrumentsInstrumentIdBook" => Okcoin::request(self, "instruments/{instrument_id}/book".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetInstrumentsInstrumentIdTrades" => Okcoin::request(self, "instruments/{instrument_id}/trades".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetInstrumentsInstrumentIdTicker" => Okcoin::request(self, "instruments/{instrument_id}/ticker".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionGetInstrumentsInstrumentIdCandles" => Okcoin::request(self, "instruments/{instrument_id}/candles".into(), "option".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionPostOrder" => Okcoin::request(self, "order".into(), "option".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionPostOrders" => Okcoin::request(self, "orders".into(), "option".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionPostCancelOrderUnderlyingOrderId" => Okcoin::request(self, "cancel_order/{underlying}/{order_id}".into(), "option".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionPostCancelOrderUnderlyingClientOid" => Okcoin::request(self, "cancel_order/{underlying}/{client_oid}".into(), "option".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionPostCancelBatchOrdersUnderlying" => Okcoin::request(self, "cancel_batch_orders/{underlying}".into(), "option".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionPostAmendOrderUnderlying" => Okcoin::request(self, "amend_order/{underlying}".into(), "option".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "optionPostAmendBatchOrdersUnderlying" => Okcoin::request(self, "amend_batch_orders/{underlying}".into(), "option".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "informationGetCurrencyLongShortRatio" => Okcoin::request(self, "{currency}/long_short_ratio".into(), "information".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "informationGetCurrencyVolume" => Okcoin::request(self, "{currency}/volume".into(), "information".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "informationGetCurrencyTaker" => Okcoin::request(self, "{currency}/taker".into(), "information".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "informationGetCurrencySentiment" => Okcoin::request(self, "{currency}/sentiment".into(), "information".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "informationGetCurrencyMargin" => Okcoin::request(self, "{currency}/margin".into(), "information".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "indexGetInstrumentIdConstituents" => Okcoin::request(self, "{instrument_id}/constituents".into(), "index".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct OkcoinImpl(Value);
impl Exchange for OkcoinImpl {}
impl Okcoin for OkcoinImpl {}
impl ValueTrait for OkcoinImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl OkcoinImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = OkcoinImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Okcoin::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

