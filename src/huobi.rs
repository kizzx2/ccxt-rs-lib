#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_code)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(unused_comparisons)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use async_trait::async_trait;
use std::str::FromStr;
use serde::{Deserialize, Serialize};
use serde_json::json;
use crate::exchange::{Exchange, ExchangeImpl, Precise, Value, ValueTrait, JSON, Array, Object, Math, parse_int, shift_2, extend_2, normalize};

use crate::exchange::{PRECISE_BASE, TRUNCATE, ROUND, ROUND_UP, ROUND_DOWN};
use crate::exchange::{DECIMAL_PLACES, SIGNIFICANT_DIGITS, TICK_SIZE, NO_PADDING, PAD_WITH_ZERO};

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

#[async_trait]
pub trait Huobi : Exchange {
    fn describe(&self) -> Value {
        Value::Json(serde_json::Value::from_str(r###"{
            "id": "huobi",
            "name": "Huobi",
            "countries": [
                "CN"
            ],
            "enableRateLimit": true,
            "rateLimit": 100,
            "certified": true,
            "pro": true,
            "alias": false,
            "has": {
                "publicAPI": true,
                "privateAPI": true,
                "spot": true,
                "margin": true,
                "swap": true,
                "future": true,
                "cancelAllOrders": true,
                "cancelOrder": true,
                "cancelOrders": true,
                "createLimitOrder": true,
                "createMarketOrder": true,
                "createOrder": true,
                "createReduceOnlyOrder": false,
                "createStopOrder": true,
                "createStopLimitOrder": true,
                "createStopMarketOrder": true,
                "editOrder": "emulated",
                "fetchAccounts": true,
                "fetchBalance": true,
                "fetchBorrowInterest": true,
                "fetchBorrowRatesPerSymbol": true,
                "fetchBorrowRates": true,
                "fetchClosedOrders": true,
                "fetchCurrencies": true,
                "fetchDepositAddress": true,
                "fetchDepositAddressesByNetwork": true,
                "fetchDeposits": true,
                "fetchFundingHistory": true,
                "fetchFundingRate": true,
                "fetchFundingRateHistory": true,
                "fetchFundingRates": true,
                "fetchIndexOHLCV": true,
                "fetchL2OrderBook": true,
                "fetchLedger": true,
                "fetchLeverageTiers": true,
                "fetchMarketLeverageTiers": true,
                "fetchMarkets": true,
                "fetchMarkOHLCV": true,
                "fetchMyTrades": true,
                "fetchOHLCV": true,
                "fetchOpenOrders": true,
                "fetchOrder": true,
                "fetchOrderBook": true,
                "fetchOrders": true,
                "fetchOrderTrades": true,
                "fetchPosition": true,
                "fetchPositions": true,
                "fetchPositionsRisk": false,
                "fetchPremiumIndexOHLCV": true,
                "fetchStatus": true,
                "fetchTicker": true,
                "fetchTickers": true,
                "fetchTime": true,
                "fetchTrades": true,
                "fetchTradingFee": true,
                "fetchTradingFees": false,
                "fetchTradingLimits": true,
                "fetchWithdrawals": true,
                "setLeverage": true,
                "setMarginMode": false,
                "setPositionMode": false,
                "transfer": true,
                "withdraw": true,
                "borrowMargin": true,
                "fetchLeverage": false,
                "fetchOpenInterestHistory": true,
                "fetchSettlementHistory": true,
                "fetchWithdrawAddressesByNetwork": true,
                "repayMargin": true
            },
            "urls": {
                "logo": "https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg",
                "api": {
                    "status": "https://{hostname}",
                    "contract": "https://{hostname}",
                    "spot": "https://{hostname}",
                    "market": "https://{hostname}",
                    "public": "https://{hostname}",
                    "private": "https://{hostname}",
                    "v2Public": "https://{hostname}",
                    "v2Private": "https://{hostname}"
                },
                "www": "https://www.huobi.com",
                "doc": [
                    "https://huobiapi.github.io/docs/spot/v1/cn/",
                    "https://huobiapi.github.io/docs/dm/v1/cn/",
                    "https://huobiapi.github.io/docs/coin_margined_swap/v1/cn/",
                    "https://huobiapi.github.io/docs/usdt_swap/v1/cn/",
                    "https://huobiapi.github.io/docs/option/v1/cn/"
                ],
                "fees": "https://www.huobi.com/about/fee/",
                "hostnames": {
                    "contract": "api.hbdm.com",
                    "spot": "api.huobi.pro",
                    "status": {
                        "spot": "status.huobigroup.com",
                        "future": {
                            "inverse": "status-dm.huobigroup.com",
                            "linear": "status-linear-swap.huobigroup.com"
                        },
                        "swap": {
                            "inverse": "status-swap.huobigroup.com",
                            "linear": "status-linear-swap.huobigroup.com"
                        }
                    }
                },
                "referral": {
                    "url": "https://www.huobi.com/en-us/topic/double-reward/?invite_code=6rmm2223",
                    "discount": 0.15
                }
            },
            "api": {
                "v2Public": {
                    "get": {
                        "reference/currencies": 1,
                        "market-status": 1
                    }
                },
                "v2Private": {
                    "get": {
                        "account/ledger": 1,
                        "account/withdraw/quota": 1,
                        "account/withdraw/address": 1,
                        "account/deposit/address": 1,
                        "account/repayment": 5,
                        "reference/transact-fee-rate": 1,
                        "account/asset-valuation": 0.2,
                        "point/account": 5,
                        "sub-user/user-list": 1,
                        "sub-user/user-state": 1,
                        "sub-user/account-list": 1,
                        "sub-user/deposit-address": 1,
                        "sub-user/query-deposit": 1,
                        "user/api-key": 1,
                        "user/uid": 1,
                        "algo-orders/opening": 1,
                        "algo-orders/history": 1,
                        "algo-orders/specific": 1,
                        "c2c/offers": 1,
                        "c2c/offer": 1,
                        "c2c/transactions": 1,
                        "c2c/repayment": 1,
                        "c2c/account": 1,
                        "etp/reference": 1,
                        "etp/transactions": 5,
                        "etp/transaction": 5,
                        "etp/rebalance": 1,
                        "etp/limit": 1
                    },
                    "post": {
                        "account/transfer": 1,
                        "account/repayment": 5,
                        "point/transfer": 5,
                        "sub-user/management": 1,
                        "sub-user/creation": 1,
                        "sub-user/tradable-market": 1,
                        "sub-user/transferability": 1,
                        "sub-user/api-key-generation": 1,
                        "sub-user/api-key-modification": 1,
                        "sub-user/api-key-deletion": 1,
                        "sub-user/deduct-mode": 1,
                        "algo-orders": 1,
                        "algo-orders/cancel-all-after": 1,
                        "algo-orders/cancellation": 1,
                        "c2c/offer": 1,
                        "c2c/cancellation": 1,
                        "c2c/cancel-all": 1,
                        "c2c/repayment": 1,
                        "c2c/transfer": 1,
                        "etp/creation": 5,
                        "etp/redemption": 5,
                        "etp/{transactId}/cancel": 10,
                        "etp/batch-cancel": 50
                    }
                },
                "market": {
                    "get": {
                        "history/kline": 1,
                        "detail/merged": 1,
                        "depth": 1,
                        "trade": 1,
                        "history/trade": 1,
                        "detail": 1,
                        "tickers": 1,
                        "etp": 1
                    }
                },
                "public": {
                    "get": {
                        "common/symbols": 1,
                        "common/currencys": 1,
                        "common/timestamp": 1,
                        "common/exchange": 1,
                        "settings/currencys": 1
                    }
                },
                "private": {
                    "get": {
                        "account/accounts": 0.2,
                        "account/accounts/{id}/balance": 0.2,
                        "account/accounts/{sub-uid}": 1,
                        "account/history": 4,
                        "cross-margin/loan-info": 1,
                        "margin/loan-info": 1,
                        "fee/fee-rate/get": 1,
                        "order/openOrders": 0.4,
                        "order/orders": 0.4,
                        "order/orders/{id}": 0.4,
                        "order/orders/{id}/matchresults": 0.4,
                        "order/orders/getClientOrder": 0.4,
                        "order/history": 1,
                        "order/matchresults": 1,
                        "query/deposit-withdraw": 1,
                        "margin/loan-orders": 0.2,
                        "margin/accounts/balance": 0.2,
                        "cross-margin/loan-orders": 1,
                        "cross-margin/accounts/balance": 1,
                        "points/actions": 1,
                        "points/orders": 1,
                        "subuser/aggregate-balance": 10,
                        "stable-coin/exchange_rate": 1,
                        "stable-coin/quote": 1
                    },
                    "post": {
                        "account/transfer": 1,
                        "futures/transfer": 1,
                        "order/batch-orders": 0.4,
                        "order/orders/place": 0.2,
                        "order/orders/submitCancelClientOrder": 0.2,
                        "order/orders/batchCancelOpenOrders": 0.4,
                        "order/orders/{id}/submitcancel": 0.2,
                        "order/orders/batchcancel": 0.4,
                        "dw/withdraw/api/create": 1,
                        "dw/withdraw-virtual/{id}/cancel": 1,
                        "dw/transfer-in/margin": 10,
                        "dw/transfer-out/margin": 10,
                        "margin/orders": 10,
                        "margin/orders/{id}/repay": 10,
                        "cross-margin/transfer-in": 1,
                        "cross-margin/transfer-out": 1,
                        "cross-margin/orders": 1,
                        "cross-margin/orders/{id}/repay": 1,
                        "stable-coin/exchange": 1,
                        "subuser/transfer": 10
                    }
                },
                "status": {
                    "public": {
                        "spot": {
                            "get": {
                                "api/v2/summary.json": 1
                            }
                        },
                        "future": {
                            "inverse": {
                                "get": {
                                    "api/v2/summary.json": 1
                                }
                            },
                            "linear": {
                                "get": {
                                    "api/v2/summary.json": 1
                                }
                            }
                        },
                        "swap": {
                            "inverse": {
                                "get": {
                                    "api/v2/summary.json": 1
                                }
                            },
                            "linear": {
                                "get": {
                                    "api/v2/summary.json": 1
                                }
                            }
                        }
                    }
                },
                "spot": {
                    "public": {
                        "get": {
                            "v2/market-status": 1,
                            "v1/common/symbols": 1,
                            "v1/common/currencys": 1,
                            "v2/reference/currencies": 1,
                            "v1/common/timestamp": 1,
                            "v1/common/exchange": 1,
                            "market/history/candles": 1,
                            "market/history/kline": 1,
                            "market/detail/merged": 1,
                            "market/tickers": 1,
                            "market/depth": 1,
                            "market/trade": 1,
                            "market/history/trade": 1,
                            "market/detail/": 1,
                            "market/etp": 1,
                            "v2/etp/reference": 1,
                            "v2/etp/rebalance": 1
                        }
                    },
                    "private": {
                        "get": {
                            "v1/account/accounts": 0.2,
                            "v1/account/accounts/{account-id}/balance": 0.2,
                            "v2/account/valuation": 1,
                            "v2/account/asset-valuation": 0.2,
                            "v1/account/history": 4,
                            "v2/account/ledger": 1,
                            "v2/point/account": 5,
                            "v2/account/deposit/address": 1,
                            "v2/account/withdraw/quota": 1,
                            "v2/account/withdraw/address": 1,
                            "v2/reference/currencies": 1,
                            "v1/query/deposit-withdraw": 1,
                            "v2/user/api-key": 1,
                            "v2/user/uid": 1,
                            "v2/sub-user/user-list": 1,
                            "v2/sub-user/user-state": 1,
                            "v2/sub-user/account-list": 1,
                            "v2/sub-user/deposit-address": 1,
                            "v2/sub-user/query-deposit": 1,
                            "v1/subuser/aggregate-balance": 10,
                            "v1/account/accounts/{sub-uid}": 1,
                            "v1/order/openOrders": 0.4,
                            "v1/order/orders/{order-id}": 0.4,
                            "v1/order/orders/getClientOrder": 0.4,
                            "v1/order/orders/{order-id}/matchresults": 0.4,
                            "v1/order/orders": 0.4,
                            "v1/order/history": 1,
                            "v1/order/matchresults": 1,
                            "v2/reference/transact-fee-rate": 1,
                            "v2/algo-orders/opening": 1,
                            "v2/algo-orders/history": 1,
                            "v2/algo-orders/specific": 1,
                            "v1/margin/loan-info": 1,
                            "v1/margin/loan-orders": 0.2,
                            "v1/margin/accounts/balance": 0.2,
                            "v1/cross-margin/loan-info": 1,
                            "v1/cross-margin/loan-orders": 1,
                            "v1/cross-margin/accounts/balance": 1,
                            "v2/account/repayment": 5,
                            "v1/stable-coin/quote": 1,
                            "v2/etp/transactions": 5,
                            "v2/etp/transaction": 5,
                            "v2/etp/limit": 1
                        },
                        "post": {
                            "v1/account/transfer": 1,
                            "v1/futures/transfer": 1,
                            "v2/point/transfer": 5,
                            "v2/account/transfer": 1,
                            "v1/dw/withdraw/api/create": 1,
                            "v1/dw/withdraw-virtual/{withdraw-id}/cancel": 1,
                            "v2/sub-user/deduct-mode": 1,
                            "v2/sub-user/creation": 1,
                            "v2/sub-user/management": 1,
                            "v2/sub-user/tradable-market": 1,
                            "v2/sub-user/transferability": 1,
                            "v2/sub-user/api-key-generation": 1,
                            "v2/sub-user/api-key-modification": 1,
                            "v2/sub-user/api-key-deletion": 1,
                            "v1/subuser/transfer": 10,
                            "v1/order/orders/place": 0.2,
                            "v1/order/batch-orders": 0.4,
                            "v1/order/orders/{order-id}/submitcancel": 0.2,
                            "v1/order/orders/submitCancelClientOrder": 0.2,
                            "v1/order/orders/batchCancelOpenOrders": 0.4,
                            "v1/order/orders/batchcancel": 0.4,
                            "v2/algo-orders/cancel-all-after": 1,
                            "v2/algo-orders": 1,
                            "v2/algo-orders/cancellation": 1,
                            "v2/account/repayment": 5,
                            "v1/dw/transfer-in/margin": 10,
                            "v1/dw/transfer-out/margin": 10,
                            "v1/margin/orders": 10,
                            "v1/margin/orders/{order-id}/repay": 10,
                            "v1/cross-margin/transfer-in": 1,
                            "v1/cross-margin/transfer-out": 1,
                            "v1/cross-margin/orders": 1,
                            "v1/cross-margin/orders/{order-id}/repay": 1,
                            "v1/stable-coin/exchange": 1,
                            "v2/etp/creation": 5,
                            "v2/etp/redemption": 5,
                            "v2/etp/{transactId}/cancel": 10,
                            "v2/etp/batch-cancel": 50
                        }
                    }
                },
                "contract": {
                    "public": {
                        "get": {
                            "api/v1/timestamp": 1,
                            "heartbeat/": 1,
                            "api/v1/contract_contract_info": 1,
                            "api/v1/contract_index": 1,
                            "api/v1/contract_price_limit": 1,
                            "api/v1/contract_open_interest": 1,
                            "api/v1/contract_delivery_price": 1,
                            "market/depth": 1,
                            "market/bbo": 1,
                            "market/history/kline": 1,
                            "index/market/history/mark_price_kline": 1,
                            "market/detail/merged": 1,
                            "market/detail/batch_merged": 1,
                            "market/trade": 1,
                            "market/history/trade": 1,
                            "api/v1/contract_risk_info": 1,
                            "api/v1/contract_insurance_fund": 1,
                            "api/v1/contract_adjustfactor": 1,
                            "api/v1/contract_his_open_interest": 1,
                            "api/v1/contract_ladder_margin": 1,
                            "api/v1/contract_api_state": 1,
                            "api/v1/contract_elite_account_ratio": 1,
                            "api/v1/contract_elite_position_ratio": 1,
                            "api/v1/contract_liquidation_orders": 1,
                            "api/v1/contract_settlement_records": 1,
                            "index/market/history/index": 1,
                            "index/market/history/basis": 1,
                            "api/v1/contract_estimated_settlement_price": 1,
                            "swap-api/v1/swap_contract_info": 1,
                            "swap-api/v1/swap_index": 1,
                            "swap-api/v1/swap_price_limit": 1,
                            "swap-api/v1/swap_open_interest": 1,
                            "swap-ex/market/depth": 1,
                            "swap-ex/market/bbo": 1,
                            "swap-ex/market/history/kline": 1,
                            "index/market/history/swap_mark_price_kline": 1,
                            "swap-ex/market/detail/merged": 1,
                            "swap-ex/market/detail/batch_merged": 1,
                            "swap-ex/market/trade": 1,
                            "swap-ex/market/history/trade": 1,
                            "swap-api/v1/swap_risk_info": 1,
                            "swap-api/v1/swap_insurance_fund": 1,
                            "swap-api/v1/swap_adjustfactor": 1,
                            "swap-api/v1/swap_his_open_interest": 1,
                            "swap-api/v1/swap_ladder_margin": 1,
                            "swap-api/v1/swap_api_state": 1,
                            "swap-api/v1/swap_elite_account_ratio": 1,
                            "swap-api/v1/swap_elite_position_ratio": 1,
                            "swap-api/v1/swap_estimated_settlement_price": 1,
                            "swap-api/v1/swap_liquidation_orders": 1,
                            "swap-api/v1/swap_settlement_records": 1,
                            "swap-api/v1/swap_funding_rate": 1,
                            "swap-api/v1/swap_batch_funding_rate": 1,
                            "swap-api/v1/swap_historical_funding_rate": 1,
                            "index/market/history/swap_premium_index_kline": 1,
                            "index/market/history/swap_estimated_rate_kline": 1,
                            "index/market/history/swap_basis": 1,
                            "linear-swap-api/v1/swap_contract_info": 1,
                            "linear-swap-api/v1/swap_index": 1,
                            "linear-swap-api/v1/swap_price_limit": 1,
                            "linear-swap-api/v1/swap_open_interest": 1,
                            "linear-swap-ex/market/depth": 1,
                            "linear-swap-ex/market/bbo": 1,
                            "linear-swap-ex/market/history/kline": 1,
                            "index/market/history/linear_swap_mark_price_kline": 1,
                            "linear-swap-ex/market/detail/merged": 1,
                            "linear-swap-ex/market/detail/batch_merged": 1,
                            "linear-swap-ex/market/trade": 1,
                            "linear-swap-ex/market/history/trade": 1,
                            "linear-swap-api/v1/swap_risk_info": 1,
                            "swap-api/v1/linear-swap-api/v1/swap_insurance_fund": 1,
                            "linear-swap-api/v1/swap_adjustfactor": 1,
                            "linear-swap-api/v1/swap_cross_adjustfactor": 1,
                            "linear-swap-api/v1/swap_his_open_interest": 1,
                            "linear-swap-api/v1/swap_ladder_margin": 1,
                            "linear-swap-api/v1/swap_cross_ladder_margin": 1,
                            "linear-swap-api/v1/swap_api_state": 1,
                            "linear-swap-api/v1/swap_cross_transfer_state": 1,
                            "linear-swap-api/v1/swap_cross_trade_state": 1,
                            "linear-swap-api/v1/swap_elite_account_ratio": 1,
                            "linear-swap-api/v1/swap_elite_position_ratio": 1,
                            "linear-swap-api/v1/swap_liquidation_orders": 1,
                            "linear-swap-api/v1/swap_settlement_records": 1,
                            "linear-swap-api/v1/swap_funding_rate": 1,
                            "linear-swap-api/v1/swap_batch_funding_rate": 1,
                            "linear-swap-api/v1/swap_historical_funding_rate": 1,
                            "index/market/history/linear_swap_premium_index_kline": 1,
                            "index/market/history/linear_swap_estimated_rate_kline": 1,
                            "index/market/history/linear_swap_basis": 1,
                            "linear-swap-api/v1/swap_estimated_settlement_price": 1
                        }
                    },
                    "private": {
                        "get": {
                            "api/v1/contract_api_trading_status": 1,
                            "swap-api/v1/swap_api_trading_status": 1,
                            "linear-swap-api/v1/swap_api_trading_status": 1
                        },
                        "post": {
                            "api/v1/contract_balance_valuation": 1,
                            "api/v1/contract_account_info": 1,
                            "api/v1/contract_position_info": 1,
                            "api/v1/contract_sub_auth": 1,
                            "api/v1/contract_sub_account_list": 1,
                            "api/v1/contract_sub_account_info_list": 1,
                            "api/v1/contract_sub_account_info": 1,
                            "api/v1/contract_sub_position_info": 1,
                            "api/v1/contract_financial_record": 1,
                            "api/v1/contract_financial_record_exact": 1,
                            "api/v1/contract_user_settlement_records": 1,
                            "api/v1/contract_order_limit": 1,
                            "api/v1/contract_fee": 1,
                            "api/v1/contract_transfer_limit": 1,
                            "api/v1/contract_position_limit": 1,
                            "api/v1/contract_account_position_info": 1,
                            "api/v1/contract_master_sub_transfer": 1,
                            "api/v1/contract_master_sub_transfer_record": 1,
                            "api/v1/contract_available_level_rate": 1,
                            "api/v1/contract_order": 1,
                            "v1/contract_batchorder": 1,
                            "api/v1/contract_cancel": 1,
                            "api/v1/contract_cancelall": 1,
                            "api/v1/contract_switch_lever_rate": 1,
                            "api/v1/lightning_close_position": 1,
                            "api/v1/contract_order_info": 1,
                            "api/v1/contract_order_detail": 1,
                            "api/v1/contract_openorders": 1,
                            "api/v1/contract_hisorders": 1,
                            "api/v1/contract_hisorders_exact": 1,
                            "api/v1/contract_matchresults": 1,
                            "api/v1/contract_matchresults_exact": 1,
                            "api/v1/contract_trigger_order": 1,
                            "api/v1/contract_trigger_cancel": 1,
                            "api/v1/contract_trigger_cancelall": 1,
                            "api/v1/contract_trigger_openorders": 1,
                            "api/v1/contract_trigger_hisorders": 1,
                            "api/v1/contract_tpsl_order": 1,
                            "api/v1/contract_tpsl_cancel": 1,
                            "api/v1/contract_tpsl_cancelall": 1,
                            "api/v1/contract_tpsl_openorders": 1,
                            "api/v1/contract_tpsl_hisorders": 1,
                            "api/v1/contract_relation_tpsl_order": 1,
                            "api/v1/contract_track_order": 1,
                            "api/v1/contract_track_cancel": 1,
                            "api/v1/contract_track_cancelall": 1,
                            "api/v1/contract_track_openorders": 1,
                            "api/v1/contract_track_hisorders": 1,
                            "swap-api/v1/swap_balance_valuation": 1,
                            "swap-api/v1/swap_account_info": 1,
                            "swap-api/v1/swap_position_info": 1,
                            "swap-api/v1/swap_account_position_info": 1,
                            "swap-api/v1/swap_sub_auth": 1,
                            "swap-api/v1/swap_sub_account_list": 1,
                            "swap-api/v1/swap_sub_account_info_list": 1,
                            "swap-api/v1/swap_sub_account_info": 1,
                            "swap-api/v1/swap_sub_position_info": 1,
                            "swap-api/v1/swap_financial_record": 1,
                            "swap-api/v1/swap_financial_record_exact": 1,
                            "swap-api/v1/swap_user_settlement_records": 1,
                            "swap-api/v1/swap_available_level_rate": 1,
                            "swap-api/v1/swap_order_limit": 1,
                            "swap-api/v1/swap_fee": 1,
                            "swap-api/v1/swap_transfer_limit": 1,
                            "swap-api/v1/swap_position_limit": 1,
                            "swap-api/v1/swap_master_sub_transfer": 1,
                            "swap-api/v1/swap_master_sub_transfer_record": 1,
                            "swap-api/v1/swap_order": 1,
                            "swap-api/v1/swap_batchorder": 1,
                            "swap-api/v1/swap_cancel": 1,
                            "swap-api/v1/swap_cancelall": 1,
                            "swap-api/v1/swap_lightning_close_position": 1,
                            "swap-api/v1/swap_switch_lever_rate": 1,
                            "swap-api/v1/swap_order_info": 1,
                            "swap-api/v1/swap_order_detail": 1,
                            "swap-api/v1/swap_openorders": 1,
                            "swap-api/v1/swap_hisorders": 1,
                            "swap-api/v1/swap_hisorders_exact": 1,
                            "swap-api/v1/swap_matchresults": 1,
                            "swap-api/v1/swap_matchresults_exact": 1,
                            "swap-api/v1/swap_trigger_order": 1,
                            "swap-api/v1/swap_trigger_cancel": 1,
                            "swap-api/v1/swap_trigger_cancelall": 1,
                            "swap-api/v1/swap_trigger_openorders": 1,
                            "swap-api/v1/swap_trigger_hisorders": 1,
                            "swap-api/v1/swap_tpsl_order": 1,
                            "swap-api/v1/swap_tpsl_cancel": 1,
                            "swap-api/v1/swap_tpsl_cancelall": 1,
                            "swap-api/v1/swap_tpsl_openorders": 1,
                            "swap-api/v1/swap_tpsl_hisorders": 1,
                            "swap-api/v1/swap_relation_tpsl_order": 1,
                            "swap-api/v1/swap_track_order": 1,
                            "swap-api/v1/swap_track_cancel": 1,
                            "swap-api/v1/swap_track_cancelall": 1,
                            "swap-api/v1/swap_track_openorders": 1,
                            "swap-api/v1/swap_track_hisorders": 1,
                            "linear-swap-api/v1/swap_lever_position_limit": 1,
                            "linear-swap-api/v1/swap_cross_lever_position_limit": 1,
                            "linear-swap-api/v1/swap_balance_valuation": 1,
                            "linear-swap-api/v1/swap_account_info": 1,
                            "linear-swap-api/v1/swap_cross_account_info": 1,
                            "linear-swap-api/v1/swap_position_info": 1,
                            "linear-swap-api/v1/swap_cross_position_info": 1,
                            "linear-swap-api/v1/swap_account_position_info": 1,
                            "linear-swap-api/v1/swap_cross_account_position_info": 1,
                            "linear-swap-api/v1/swap_sub_auth": 1,
                            "linear-swap-api/v1/swap_sub_account_list": 1,
                            "linear-swap-api/v1/swap_cross_sub_account_list": 1,
                            "linear-swap-api/v1/swap_sub_account_info_list": 1,
                            "linear-swap-api/v1/swap_cross_sub_account_info_list": 1,
                            "linear-swap-api/v1/swap_sub_account_info": 1,
                            "linear-swap-api/v1/swap_cross_sub_account_info": 1,
                            "linear-swap-api/v1/swap_sub_position_info": 1,
                            "linear-swap-api/v1/swap_cross_sub_position_info": 1,
                            "linear-swap-api/v1/swap_financial_record": 1,
                            "linear-swap-api/v1/swap_financial_record_exact": 1,
                            "linear-swap-api/v1/swap_user_settlement_records": 1,
                            "linear-swap-api/v1/swap_cross_user_settlement_records": 1,
                            "linear-swap-api/v1/swap_available_level_rate": 1,
                            "linear-swap-api/v1/swap_cross_available_level_rate": 1,
                            "linear-swap-api/v1/swap_order_limit": 1,
                            "linear-swap-api/v1/swap_fee": 1,
                            "linear-swap-api/v1/swap_transfer_limit": 1,
                            "linear-swap-api/v1/swap_cross_transfer_limit": 1,
                            "linear-swap-api/v1/swap_position_limit": 1,
                            "linear-swap-api/v1/swap_cross_position_limit": 1,
                            "linear-swap-api/v1/swap_master_sub_transfer": 1,
                            "linear-swap-api/v1/swap_master_sub_transfer_record": 1,
                            "linear-swap-api/v1/swap_transfer_inner": 1,
                            "linear-swap-api/v1/swap_order": 1,
                            "linear-swap-api/v1/swap_cross_order": 1,
                            "linear-swap-api/v1/swap_batchorder": 1,
                            "linear-swap-api/v1/swap_cross_batchorder": 1,
                            "linear-swap-api/v1/swap_cancel": 1,
                            "linear-swap-api/v1/swap_cross_cancel": 1,
                            "linear-swap-api/v1/swap_cancelall": 1,
                            "linear-swap-api/v1/swap_cross_cancelall": 1,
                            "linear-swap-api/v1/swap_switch_lever_rate": 1,
                            "linear-swap-api/v1/swap_cross_switch_lever_rate": 1,
                            "linear-swap-api/v1/swap_lightning_close_position": 1,
                            "linear-swap-api/v1/swap_cross_lightning_close_position": 1,
                            "linear-swap-api/v1/swap_order_info": 1,
                            "linear-swap-api/v1/swap_cross_order_info": 1,
                            "linear-swap-api/v1/swap_order_detail": 1,
                            "linear-swap-api/v1/swap_cross_order_detail": 1,
                            "linear-swap-api/v1/swap_openorders": 1,
                            "linear-swap-api/v1/swap_cross_openorders": 1,
                            "linear-swap-api/v1/swap_hisorders": 1,
                            "linear-swap-api/v1/swap_cross_hisorders": 1,
                            "linear-swap-api/v1/swap_hisorders_exact": 1,
                            "linear-swap-api/v1/swap_cross_hisorders_exact": 1,
                            "linear-swap-api/v1/swap_matchresults": 1,
                            "linear-swap-api/v1/swap_cross_matchresults": 1,
                            "linear-swap-api/v1/swap_matchresults_exact": 1,
                            "linear-swap-api/v1/swap_cross_matchresults_exact": 1,
                            "linear-swap-api/v1/swap_switch_position_mode": 1,
                            "linear-swap-api/v1/swap_cross_switch_position_mode": 1,
                            "linear-swap-api/v1/swap_trigger_order": 1,
                            "linear-swap-api/v1/swap_cross_trigger_order": 1,
                            "linear-swap-api/v1/swap_trigger_cancel": 1,
                            "linear-swap-api/v1/swap_cross_trigger_cancel": 1,
                            "linear-swap-api/v1/swap_trigger_cancelall": 1,
                            "linear-swap-api/v1/swap_cross_trigger_cancelall": 1,
                            "linear-swap-api/v1/swap_trigger_openorders": 1,
                            "linear-swap-api/v1/swap_cross_trigger_openorders": 1,
                            "linear-swap-api/v1/swap_trigger_hisorders": 1,
                            "linear-swap-api/v1/swap_cross_trigger_hisorders": 1,
                            "linear-swap-api/v1/swap_tpsl_order": 1,
                            "linear-swap-api/v1/swap_cross_tpsl_order": 1,
                            "linear-swap-api/v1/swap_tpsl_cancel": 1,
                            "linear-swap-api/v1/swap_cross_tpsl_cancel": 1,
                            "linear-swap-api/v1/swap_tpsl_cancelall": 1,
                            "linear-swap-api/v1/swap_cross_tpsl_cancelall": 1,
                            "linear-swap-api/v1/swap_tpsl_openorders": 1,
                            "linear-swap-api/v1/swap_cross_tpsl_openorders": 1,
                            "linear-swap-api/v1/swap_tpsl_hisorders": 1,
                            "linear-swap-api/v1/swap_cross_tpsl_hisorders": 1,
                            "linear-swap-api/v1/swap_relation_tpsl_order": 1,
                            "linear-swap-api/v1/swap_cross_relation_tpsl_order": 1,
                            "linear-swap-api/v1/swap_track_order": 1,
                            "linear-swap-api/v1/swap_cross_track_order": 1,
                            "linear-swap-api/v1/swap_track_cancel": 1,
                            "linear-swap-api/v1/swap_cross_track_cancel": 1,
                            "linear-swap-api/v1/swap_track_cancelall": 1,
                            "linear-swap-api/v1/swap_cross_track_cancelall": 1,
                            "linear-swap-api/v1/swap_track_openorders": 1,
                            "linear-swap-api/v1/swap_cross_track_openorders": 1,
                            "linear-swap-api/v1/swap_track_hisorders": 1,
                            "linear-swap-api/v1/swap_cross_track_hisorders": 1
                        }
                    }
                }
            },
            "requiredCredentials": {
                "apiKey": true,
                "secret": true,
                "uid": false,
                "login": false,
                "password": false,
                "twofa": false,
                "privateKey": false,
                "walletAddress": false,
                "token": false
            },
            "currencies": {},
            "timeframes": {
                "1m": "1min",
                "5m": "5min",
                "15m": "15min",
                "30m": "30min",
                "1h": "60min",
                "4h": "4hour",
                "1d": "1day",
                "1w": "1week",
                "1M": "1mon",
                "1y": "1year"
            },
            "fees": {
                "trading": {
                    "tierBased": false,
                    "percentage": true,
                    "taker": 0.002,
                    "maker": 0.002,
                    "feeSide": "get"
                },
                "funding": {
                    "withdraw": {},
                    "deposit": {}
                }
            },
            "status": {
                "status": "ok"
            },
            "exceptions": {
                "broad": {},
                "exact": {}
            },
            "httpExceptions": {},
            "commonCurrencies": {
                "XBT": "BTC",
                "BCC": "BCH",
                "BCHABC": "BCH",
                "BCHSV": "BSV",
                "GET": "Themis",
                "GTC": "Game.com",
                "HIT": "HitChain",
                "HOT": "Hydro Protocol",
                "PNT": "Penta",
                "SBTC": "Super Bitcoin",
                "BIFI": "Bitcoin File"
            },
            "precisionMode": 2,
            "paddingMode": 0,
            "limits": {
                "leverage": {},
                "amount": {},
                "price": {},
                "cost": {}
            },
            "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36",
            "version": "v1",
            "hostname": "api.huobi.pro",
            "options": {
                "fetchMarkets": {
                    "types": {
                        "spot": true,
                        "future": {
                            "linear": true,
                            "inverse": true
                        },
                        "swap": {
                            "linear": true,
                            "inverse": true
                        }
                    }
                },
                "defaultType": "spot",
                "defaultSubType": "inverse",
                "defaultNetwork": "ERC20",
                "networks": {
                    "ETH": "erc20",
                    "TRX": "trc20",
                    "HRC20": "hrc20",
                    "HECO": "hrc20",
                    "HT": "hrc20",
                    "ALGO": "algo",
                    "OMNI": ""
                },
                "fetchOrdersByStatesMethod": "spot_private_get_v1_order_orders",
                "createMarketBuyOrderRequiresPrice": true,
                "language": "en-US",
                "broker": {
                    "id": "AA03022abc"
                },
                "accountsByType": {
                    "spot": "pro",
                    "funding": "pro",
                    "future": "futures"
                },
                "accountsById": {
                    "spot": "spot",
                    "margin": "margin",
                    "otc": "otc",
                    "point": "point",
                    "super-margin": "super-margin",
                    "investment": "investment",
                    "borrow": "borrow",
                    "grid-trading": "grid-trading",
                    "deposit-earning": "deposit-earning",
                    "otc-options": "otc-options"
                },
                "marginAccounts": {
                    "cross": "super-margin",
                    "isolated": "margin"
                },
                "typesByAccount": {
                    "pro": "spot",
                    "futures": "future"
                },
                "spot": {
                    "stopOrderTypes": {
                        "stop-limit": true,
                        "buy-stop-limit": true,
                        "sell-stop-limit": true,
                        "stop-limit-fok": true,
                        "buy-stop-limit-fok": true,
                        "sell-stop-limit-fok": true
                    },
                    "limitOrderTypes": {
                        "limit": true,
                        "buy-limit": true,
                        "sell-limit": true,
                        "ioc": true,
                        "buy-ioc": true,
                        "sell-ioc": true,
                        "limit-maker": true,
                        "buy-limit-maker": true,
                        "sell-limit-maker": true,
                        "stop-limit": true,
                        "buy-stop-limit": true,
                        "sell-stop-limit": true,
                        "limit-fok": true,
                        "buy-limit-fok": true,
                        "sell-limit-fok": true,
                        "stop-limit-fok": true,
                        "buy-stop-limit-fok": true,
                        "sell-stop-limit-fok": true
                    }
                }
            }
        }"###).unwrap())
    }

    async fn fetch_status(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market_type: Value = Value::Undefined;
        (market_type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchMyTrades"), Value::Undefined, params.clone()));
        let mut method: Value = Value::from("statusPublicSpotGetApiV2SummaryJson");
        if market_type.clone() != Value::from("spot") {
            let mut sub_type: Value = self.safe_string(params.clone(), Value::from("subType"), self.get("options".into()).get(Value::from("defaultSubType")));
            if market_type.clone() == Value::from("swap") {
                if sub_type.clone() == Value::from("linear") {
                    method = Value::from("statusPublicSwapLinearGetApiV2SummaryJson");
                } else if sub_type.clone() == Value::from("inverse") {
                    method = Value::from("statusPublicSwapInverseGetApiV2SummaryJson");
                };
            } else if market_type.clone() == Value::from("future") {
                if sub_type.clone() == Value::from("linear") {
                    method = Value::from("statusPublicFutureLinearGetApiV2SummaryJson");
                } else if sub_type.clone() == Value::from("inverse") {
                    method = Value::from("statusPublicFutureInverseGetApiV2SummaryJson");
                };
            } else if market_type.clone() == Value::from("contract") {
                method = Value::from("contractPublicGetHeartbeat");
            };
        };
        let mut response: Value = Huobi::dispatch(self, method, Value::Undefined, Value::Undefined).await;
        //
        // statusPublicSpotGetApiV2SummaryJson, statusPublicSwapInverseGetApiV2SummaryJson, statusPublicFutureLinearGetApiV2SummaryJson, statusPublicFutureInverseGetApiV2SummaryJson
        //
        //      {
        //          "page": {
        //              "id":"mn7l2lw8pz4p",
        //              "name":"Huobi Futures-USDT-margined Swaps",
        //              "url":"https://status-linear-swap.huobigroup.com",
        //              "time_zone":"Asia/Singapore",
        //              "updated_at":"2022-04-29T12:47:21.319+08:00"},
        //              "components": [
        //                  {
        //                      "id":"lrv093qk3yp5",
        //                      "name":"market data",
        //                      "status":"operational",
        //                      "created_at":"2020-10-29T14:08:59.427+08:00",
        //                      "updated_at":"2020-10-29T14:08:59.427+08:00",
        //                      "position":1,"description":null,
        //                      "showcase":false,
        //                      "start_date":null,
        //                      "group_id":null,
        //                      "page_id":"mn7l2lw8pz4p",
        //                      "group":true,
        //                      "only_show_if_degraded":false,
        //                      "components": [
        //                          "82k5jxg7ltxd" // list of related components
        //                      ]
        //                  },
        //              ],
        //              "incidents": [ // empty array if there are no issues
        //                  {
        //                      "id": "rclfxz2g21ly",  // incident id
        //                      "name": "Market data is delayed",  // incident name
        //                      "status": "investigating",  // incident status
        //                      "created_at": "2020-02-11T03:15:01.913Z",  // incident create time
        //                      "updated_at": "2020-02-11T03:15:02.003Z",   // incident update time
        //                      "monitoring_at": null,
        //                      "resolved_at": null,
        //                      "impact": "minor",  // incident impact
        //                      "shortlink": "http://stspg.io/pkvbwp8jppf9",
        //                      "started_at": "2020-02-11T03:15:01.906Z",
        //                      "page_id": "p0qjfl24znv5",
        //                      "incident_updates": [
        //                          {
        //                              "id": "dwfsk5ttyvtb",
        //                              "status": "investigating",
        //                              "body": "Market data is delayed",
        //                              "incident_id": "rclfxz2g21ly",
        //                              "created_at": "2020-02-11T03:15:02.000Z",
        //                              "updated_at": "2020-02-11T03:15:02.000Z",
        //                              "display_at": "2020-02-11T03:15:02.000Z",
        //                              "affected_components": [
        //                                  {
        //                                      "code": "nctwm9tghxh6",
        //                                      "name": "Market data",
        //                                      "old_status": "operational",
        //                                      "new_status": "degraded_performance"
        //                                  }
        //                              ],
        //                              "deliver_notifications": true,
        //                              "custom_tweet": null,
        //                              "tweet_id": null
        //                          }
        //                      ],
        //                      "components": [
        //                          {
        //                              "id": "nctwm9tghxh6",
        //                              "name": "Market data",
        //                              "status": "degraded_performance",
        //                              "created_at": "2020-01-13T09:34:48.284Z",
        //                              "updated_at": "2020-02-11T03:15:01.951Z",
        //                              "position": 8,
        //                              "description": null,
        //                              "showcase": false,
        //                              "group_id": null,
        //                              "page_id": "p0qjfl24znv5",
        //                              "group": false,
        //                              "only_show_if_degraded": false
        //                          }
        //                      ]
        //                  }, ...
        //              ],
        //              "scheduled_maintenances":[ // empty array if there are no scheduled maintenances
        //                  {
        //                      "id": "k7g299zl765l", // incident id
        //                      "name": "Schedule maintenance", // incident name
        //                      "status": "scheduled", // incident status
        //                      "created_at": "2020-02-11T03:16:31.481Z",  // incident create time
        //                      "updated_at": "2020-02-11T03:16:31.530Z",  // incident update time
        //                      "monitoring_at": null,
        //                      "resolved_at": null,
        //                      "impact": "maintenance",  // incident impact
        //                      "shortlink": "http://stspg.io/md4t4ym7nytd",
        //                      "started_at": "2020-02-11T03:16:31.474Z",
        //                      "page_id": "p0qjfl24znv5",
        //                      "incident_updates": [
        //                          {
        //                              "id": "8whgr3rlbld8",
        //                              "status": "scheduled",
        //                              "body": "We will be undergoing scheduled maintenance during this time.",
        //                              "incident_id": "k7g299zl765l",
        //                              "created_at": "2020-02-11T03:16:31.527Z",
        //                              "updated_at": "2020-02-11T03:16:31.527Z",
        //                              "display_at": "2020-02-11T03:16:31.527Z",
        //                              "affected_components": [
        //                                  {
        //                                      "code": "h028tnzw1n5l",
        //                                      "name": "Deposit And Withdraw - Deposit",
        //                                      "old_status": "operational",
        //                                      "new_status": "operational"
        //                                  }
        //                              ],
        //                              "deliver_notifications": true,
        //                              "custom_tweet": null,
        //                              "tweet_id": null
        //                          }
        //                      ],
        //                      "components": [
        //                          {
        //                              "id": "h028tnzw1n5l",
        //                              "name": "Deposit",
        //                              "status": "operational",
        //                              "created_at": "2019-12-05T02:07:12.372Z",
        //                              "updated_at": "2020-02-10T12:34:52.970Z",
        //                              "position": 1,
        //                              "description": null,
        //                              "showcase": false,
        //                              "group_id": "gtd0nyr3pf0k",
        //                              "page_id": "p0qjfl24znv5",
        //                              "group": false,
        //                              "only_show_if_degraded": false
        //                          }
        //                      ],
        //                      "scheduled_for": "2020-02-15T00:00:00.000Z",  // scheduled maintenance start time
        //                      "scheduled_until": "2020-02-15T01:00:00.000Z"  // scheduled maintenance end time
        //                  }
        //              ],
        //              "status": {
        //                  "indicator":"none", // none, minor, major, critical, maintenance
        //                  "description":"all systems operational" // All Systems Operational, Minor Service Outage, Partial System Outage, Partially Degraded Service, Service Under Maintenance
        //              }
        //          }
        //
        //
        // contractPublicGetHeartbeat
        //
        //      {
        //          "status": "ok", // 'ok', 'error'
        //          "data": {
        //              "heartbeat": 1, // future 1: available, 0: maintenance with service suspended
        //              "estimated_recovery_time": null, // estimated recovery time in milliseconds
        //              "swap_heartbeat": 1,
        //              "swap_estimated_recovery_time": null,
        //              "option_heartbeat": 1,
        //              "option_estimated_recovery_time": null,
        //              "linear_swap_heartbeat": 1,
        //              "linear_swap_estimated_recovery_time": null
        //          },
        //          "ts": 1557714418033
        //      }
        //
        let mut status: Value = Value::Undefined;
        let mut updated: Value = Value::Undefined;
        let mut url: Value = Value::Undefined;
        if method.clone() == Value::from("contractPublicGetHeartbeat") {
            let mut status_raw: Value = self.safe_string(response.clone(), Value::from("status"), Value::Undefined);
            status = if status_raw.clone() == Value::from("ok") { Value::from("ok") } else { Value::from("maintenance") };
            // 'ok', 'error'
            updated = self.safe_string(response.clone(), Value::from("ts"), Value::Undefined);
        } else {
            let mut status_data: Value = self.safe_value(response.clone(), Value::from("status"), Value::new_object());
            let mut status_raw: Value = self.safe_string(status_data.clone(), Value::from("indicator"), Value::Undefined);
            status = if status_raw.clone() == Value::from("none") { Value::from("ok") } else { Value::from("maintenance") };
            // none, minor, major, critical, maintenance
            let mut page_data: Value = self.safe_value(response.clone(), Value::from("page"), Value::new_object());
            let mut datetime: Value = self.safe_string(page_data.clone(), Value::from("updated_at"), Value::Undefined);
            updated = self.parse8601(datetime.clone());
            url = self.safe_string(page_data.clone(), Value::from("url"), Value::Undefined);
        };
        return Value::Json(normalize(&Value::Json(json!({
            "status": status,
            "updated": updated,
            "eta": Value::Undefined,
            "url": url,
            "info": response
        }))).unwrap());
    }

    /// Returns the current integer timestamp in milliseconds from the exchange server
    ///
    /// Fetches the current integer timestamp in milliseconds from the exchange server
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_time(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchTime"), Value::new_object());
        let mut default_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultType"), Value::from("spot"));
        let mut r#type: Value = self.safe_string(options.clone(), Value::from("type"), default_type.clone());
        r#type = self.safe_string(params.clone(), Value::from("type"), r#type.clone());
        let mut method: Value = Value::from("spotPublicGetV1CommonTimestamp");
        if r#type.clone() == Value::from("future") || r#type.clone() == Value::from("swap") {
            method = Value::from("contractPublicGetApiV1Timestamp");
        };
        let mut response: Value = Huobi::dispatch(self, method, params.clone(), Value::Undefined).await;
        //
        // spot
        //
        //     {"status":"ok","data":1637504261099}
        //
        // future, swap
        //
        //     {"status":"ok","ts":1637504164707}
        //
        return self.safe_integer_2(response.clone(), Value::from("data"), Value::from("ts"), Value::Undefined);
    }

    fn parse_trading_fee(&self, mut fee: Value, mut market: Value) -> Value {
        //
        //     {
        //         "symbol":"btcusdt",
        //         "actualMakerRate":"0.002",
        //         "actualTakerRate":"0.002",
        //         "takerFeeRate":"0.002",
        //         "makerFeeRate":"0.002"
        //     }
        //
        let mut market_id: Value = self.safe_string(fee.clone(), Value::from("symbol"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": fee,
            "symbol": Huobi::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined),
            "maker": Huobi::safe_number(self, fee.clone(), Value::from("actualMakerRate"), Value::Undefined),
            "taker": Huobi::safe_number(self, fee.clone(), Value::from("actualTakerRate"), Value::Undefined)
        }))).unwrap());
    }

    /// Returns a [fee structure](https://docs.ccxt.com/en/latest/manual.html#fee-structure)
    ///
    /// Fetch the trading fees for a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_trading_fee(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbols": market.get(Value::from("id"))
        }))).unwrap());
        // trading symbols comma-separated
        let mut response: Value = Huobi::dispatch(self, "spotPrivateGetV2ReferenceTransactFeeRate".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code":200,
        //         "data":[
        //             {
        //                 "symbol":"btcusdt",
        //                 "actualMakerRate":"0.002",
        //                 "actualTakerRate":"0.002",
        //                 "takerFeeRate":"0.002",
        //                 "makerFeeRate":"0.002"
        //             }
        //         ],
        //         "success":true
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut first: Value = self.safe_value(data.clone(), Value::from(0), Value::new_object());
        return Huobi::parse_trading_fee(self, first.clone(), market.clone());
    }

    async fn fetch_trading_limits(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        // this method should not be called directly, use loadTradingLimits () instead
        //  by default it will try load withdrawal fees of all currencies (with separate requests)
        //  however if you define symbols = [ 'ETH/BTC', 'LTC/BTC' ] in args it will only load those
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        if symbols.clone().is_nullish() {
            symbols = self.get("symbols".into());
        };
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < symbols.len() {
            let mut symbol: Value = symbols.get(i.into());
            result.set(symbol.clone(), Huobi::fetch_trading_limits_by_id(self, Huobi::market_id(self, symbol.clone()), params.clone()).await);
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_trading_limits_by_id(&mut self, mut id: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "symbol": id
        }))).unwrap());
        let mut response: Value = Huobi::dispatch(self, "spotPublicGetV1CommonExchange".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     { status:   "ok",
        //         data: {                                  symbol: "aidocbtc",
        //                              'buy-limit-must-less-than':  1.1,
        //                          'sell-limit-must-greater-than':  0.9,
        //                         'limit-order-must-greater-than':  1,
        //                            'limit-order-must-less-than':  5000000,
        //                    'market-buy-order-must-greater-than':  0.0001,
        //                       'market-buy-order-must-less-than':  100,
        //                   'market-sell-order-must-greater-than':  1,
        //                      'market-sell-order-must-less-than':  500000,
        //                       'circuit-break-when-greater-than':  10000,
        //                          'circuit-break-when-less-than':  10,
        //                 'market-sell-order-rate-must-less-than':  0.1,
        //                  'market-buy-order-rate-must-less-than':  0.1        } }
        //
        return Huobi::parse_trading_limits(self, self.safe_value(response.clone(), Value::from("data"), Value::new_object()), Value::Undefined, Value::Undefined);
    }

    fn parse_trading_limits(&self, mut limits: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        //   {                                  symbol: "aidocbtc",
        //                  'buy-limit-must-less-than':  1.1,
        //              'sell-limit-must-greater-than':  0.9,
        //             'limit-order-must-greater-than':  1,
        //                'limit-order-must-less-than':  5000000,
        //        'market-buy-order-must-greater-than':  0.0001,
        //           'market-buy-order-must-less-than':  100,
        //       'market-sell-order-must-greater-than':  1,
        //          'market-sell-order-must-less-than':  500000,
        //           'circuit-break-when-greater-than':  10000,
        //              'circuit-break-when-less-than':  10,
        //     'market-sell-order-rate-must-less-than':  0.1,
        //      'market-buy-order-rate-must-less-than':  0.1        }
        //
        return Value::Json(normalize(&Value::Json(json!({
            "info": limits,
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Huobi::safe_number(self, limits.clone(), Value::from("limit-order-must-greater-than"), Value::Undefined),
                    "max": Huobi::safe_number(self, limits.clone(), Value::from("limit-order-must-less-than"), Value::Undefined)
                }))).unwrap())
            }))).unwrap())
        }))).unwrap());
    }

    fn cost_to_precision(&mut self, mut symbol: Value, mut cost: Value) -> Value {
        return self.decimal_to_precision(cost.clone(), TRUNCATE.into(), self.get("markets".into()).get(symbol.clone()).get(Value::from("precision")).get(Value::from("cost")), self.get("precision_mode".into()), Value::Undefined);
    }

    /// Returns an array of objects representing market data
    ///
    /// Retrieves data on all markets for huobi
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_markets(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchMarkets"), Value::new_object());
        let mut types: Value = self.safe_value(options.clone(), Value::from("types"), Value::new_object());
        let mut all_markets: Value = Value::new_array();
        let mut promises: Value = Value::new_array();
        let mut keys: Value = Object::keys(types.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut r#type: Value = keys.get(i.into());
            let mut value: Value = self.safe_value(types.clone(), r#type.clone(), Value::Undefined);
            if value.clone() == true.into() {
                promises.push(Huobi::fetch_markets_by_type_and_sub_type(self, r#type.clone(), Value::Undefined, params.clone()));
            } else {
                let mut sub_keys: Value = Object::keys(value.clone());
                let mut j: usize = 0;
                while j < sub_keys.len() {
                    let mut sub_type: Value = sub_keys.get(j.into());
                    let mut sub_value: Value = self.safe_value(value.clone(), sub_type.clone(), Value::Undefined);
                    if sub_value.is_truthy() {
                        promises.push(Huobi::fetch_markets_by_type_and_sub_type(self, r#type.clone(), sub_type.clone(), params.clone()));
                    };
                    j += 1;
                };
            };
            i += 1;
        };
        promises = Promise::all(promises.clone()).await;
        let mut i: usize = 0;
        while i < promises.len() {
            all_markets = self.array_concat(all_markets.clone(), promises.get(i.into()));
            i += 1;
        };
        return all_markets.clone();
    }

    async fn fetch_markets_by_type_and_sub_type(&mut self, mut r#type: Value, mut sub_type: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut method: Value = Value::from("spotPublicGetV1CommonSymbols");
        let mut query: Value = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("type").into(), Value::from("subType").into()])));
        let mut spot: Value = (r#type.clone() == Value::from("spot")).into();
        let mut contract: Value = (r#type.clone() != Value::from("spot")).into();
        let mut future: Value = (r#type.clone() == Value::from("future")).into();
        let mut swap: Value = (r#type.clone() == Value::from("swap")).into();
        let mut linear: Value = Value::Undefined;
        let mut inverse: Value = Value::Undefined;
        let mut request: Value = Value::new_object();
        if contract.is_truthy() {
            linear = (sub_type.clone() == Value::from("linear")).into();
            inverse = (sub_type.clone() == Value::from("inverse")).into();
            if linear.is_truthy() {
                method = Value::from("contractPublicGetLinearSwapApiV1SwapContractInfo");
                if future.is_truthy() {
                    request.set("business_type".into(), Value::from("futures"));
                };
            } else if inverse.is_truthy() {
                if future.is_truthy() {
                    method = Value::from("contractPublicGetApiV1ContractContractInfo");
                } else if swap.is_truthy() {
                    method = Value::from("contractPublicGetSwapApiV1SwapContractInfo");
                };
            };
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "base-currency":"xrp3s",
        //                 "quote-currency":"usdt",
        //                 "price-precision":4,
        //                 "amount-precision":4,
        //                 "symbol-partition":"innovation",
        //                 "symbol":"xrp3susdt",
        //                 "state":"online",
        //                 "value-precision":8,
        //                 "min-order-amt":0.01,
        //                 "max-order-amt":1616.4353,
        //                 "min-order-value":5,
        //                 "limit-order-min-order-amt":0.01,
        //                 "limit-order-max-order-amt":1616.4353,
        //                 "limit-order-max-buy-amt":1616.4353,
        //                 "limit-order-max-sell-amt":1616.4353,
        //                 "sell-market-min-order-amt":0.01,
        //                 "sell-market-max-order-amt":1616.4353,
        //                 "buy-market-max-order-value":2500,
        //                 "max-order-value":2500,
        //                 "underlying":"xrpusdt",
        //                 "mgmt-fee-rate":0.035000000000000000,
        //                 "charge-time":"23:55:00",
        //                 "rebal-time":"00:00:00",
        //                 "rebal-threshold":-5,
        //                 "init-nav":10.000000000000000000,
        //                 "api-trading":"enabled",
        //                 "tags":"etp,nav,holdinglimit"
        //             },
        //         ]
        //     }
        //
        // inverse future
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC211126",
        //                 "contract_type":"this_week",
        //                 "contract_size":100.000000000000000000,
        //                 "price_tick":0.010000000000000000,
        //                 "delivery_date":"20211126",
        //                 "delivery_time":"1637913600000",
        //                 "create_date":"20211112",
        //                 "contract_status":1,
        //                 "settlement_time":"1637481600000"
        //             },
        //         ],
        //         "ts":1637474595140
        //     }
        //
        // linear futures
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC-USDT-211231",
        //                 "contract_size":0.001000000000000000,
        //                 "price_tick":0.100000000000000000,
        //                 "delivery_date":"20211231",
        //                 "delivery_time":"1640937600000",
        //                 "create_date":"20211228",
        //                 "contract_status":1,
        //                 "settlement_date":"1640764800000",
        //                 "support_margin_mode":"cross",
        //                 "business_type":"futures",
        //                 "pair":"BTC-USDT",
        //                 "contract_type":"this_week" // next_week, quarter
        //             },
        //         ],
        //         "ts":1640736207263
        //     }
        //
        // swaps
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC-USDT",
        //                 "contract_size":0.001000000000000000,
        //                 "price_tick":0.100000000000000000,
        //                 "delivery_time":"",
        //                 "create_date":"20201021",
        //                 "contract_status":1,
        //                 "settlement_date":"1637481600000",
        //                 "support_margin_mode":"all", // isolated
        //             },
        //         ],
        //         "ts":1637474774467
        //     }
        //
        let mut markets: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut num_markets: Value = markets.len().into();
        if num_markets.clone() < Value::from(1) {
            panic!(r###"NetworkError::new(self.get("id".into()) + Value::from(" fetchMarkets() returned an empty response: ") + self.json(markets.clone(), Value::Undefined))"###);
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < markets.len() {
            let mut market: Value = markets.get(i.into());
            let mut base_id: Value = Value::Undefined;
            let mut quote_id: Value = Value::Undefined;
            let mut settle_id: Value = Value::Undefined;
            let mut id: Value = Value::Undefined;
            let mut lowercase_id: Value = Value::Undefined;
            let mut lowercase_base_id: Value = Value::Undefined;
            if contract.is_truthy() {
                id = self.safe_string(market.clone(), Value::from("contract_code"), Value::Undefined);
                lowercase_id = id.to_lower_case();
                if swap.is_truthy() {
                    let mut parts: Value = id.split(Value::from("-"));
                    base_id = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
                    lowercase_base_id = base_id.to_lower_case();
                    quote_id = self.safe_string_lower(parts.clone(), Value::from(1), Value::Undefined);
                    settle_id = if inverse.is_truthy() { base_id.clone() } else { quote_id.clone() };
                } else if future.is_truthy() {
                    base_id = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
                    lowercase_base_id = base_id.to_lower_case();
                    if inverse.is_truthy() {
                        quote_id = Value::from("USD");
                        settle_id = base_id.clone();
                    } else {
                        let mut pair: Value = self.safe_string(market.clone(), Value::from("pair"), Value::Undefined);
                        let mut parts: Value = pair.split(Value::from("-"));
                        quote_id = self.safe_string(parts.clone(), Value::from(1), Value::Undefined);
                        settle_id = quote_id.clone();
                    };
                };
            } else {
                base_id = self.safe_string(market.clone(), Value::from("base-currency"), Value::Undefined);
                lowercase_base_id = base_id.to_lower_case();
                quote_id = self.safe_string(market.clone(), Value::from("quote-currency"), Value::Undefined);
                id = base_id.clone() + quote_id.clone();
                lowercase_id = id.to_lower_case();
            };
            let mut base: Value = Huobi::safe_currency_code(self, base_id.clone(), Value::Undefined);
            let mut quote: Value = Huobi::safe_currency_code(self, quote_id.clone(), Value::Undefined);
            let mut settle: Value = Huobi::safe_currency_code(self, settle_id.clone(), Value::Undefined);
            let mut symbol: Value = base.clone() + Value::from("/") + quote.clone();
            let mut expiry: Value = Value::Undefined;
            if contract.is_truthy() {
                if inverse.is_truthy() {
                    symbol = symbol +  Value::from(":") + base.clone();
                } else if linear.is_truthy() {
                    symbol = symbol +  Value::from(":") + quote.clone();
                };
                if future.is_truthy() {
                    expiry = self.safe_integer(market.clone(), Value::from("delivery_time"), Value::Undefined);
                    symbol = symbol +  Value::from("-") + self.yymmdd(expiry.clone(), Value::Undefined);
                };
            };
            let mut contract_size: Value = Huobi::safe_number(self, market.clone(), Value::from("contract_size"), Value::Undefined);
            let mut price_precision: Value = Value::Undefined;
            let mut amount_precision: Value = Value::Undefined;
            let mut cost_precision: Value = Value::Undefined;
            if spot.is_truthy() {
                price_precision = self.parse_number(Huobi::parse_precision(self, self.safe_string(market.clone(), Value::from("price-precision"), Value::Undefined)), Value::Undefined);
                amount_precision = self.parse_number(Huobi::parse_precision(self, self.safe_string(market.clone(), Value::from("amount-precision"), Value::Undefined)), Value::Undefined);
                cost_precision = self.parse_number(Huobi::parse_precision(self, self.safe_string(market.clone(), Value::from("value-precision"), Value::Undefined)), Value::Undefined);
            } else {
                price_precision = Huobi::safe_number(self, market.clone(), Value::from("price_tick"), Value::Undefined);
                amount_precision = self.parse_number(Value::from("1"), Value::Undefined);
            };
            // other markets have step size of 1 contract
            let mut maker: Value = Value::Undefined;
            let mut taker: Value = Value::Undefined;
            if spot.is_truthy() {
                maker = if base.clone() == Value::from("OMG") { Value::from(0) } else { Value::from(0.2) / Value::from(100) };
                taker = if base.clone() == Value::from("OMG") { Value::from(0) } else { Value::from(0.2) / Value::from(100) };
            };
            let mut min_amount: Value = Huobi::safe_number(self, market.clone(), Value::from("min-order-amt"), Value::Undefined);
            let mut max_amount: Value = Huobi::safe_number(self, market.clone(), Value::from("max-order-amt"), Value::Undefined);
            let mut min_cost: Value = Huobi::safe_number(self, market.clone(), Value::from("min-order-value"), Value::from(0));
            let mut active: Value = Value::Undefined;
            if spot.is_truthy() {
                let mut state: Value = self.safe_string(market.clone(), Value::from("state"), Value::Undefined);
                active = (state.clone() == Value::from("online")).into();
            } else if contract.is_truthy() {
                let mut contract_status: Value = self.safe_integer(market.clone(), Value::from("contract_status"), Value::Undefined);
                active = (contract_status.clone() == Value::from(1)).into();
            };
            let mut leverage_ratio: Value = self.safe_string(market.clone(), Value::from("leverage-ratio"), Value::from("1"));
            let mut super_leverage_ratio: Value = self.safe_string(market.clone(), Value::from("super-margin-leverage-ratio"), Value::from("1"));
            let mut has_leverage: Value = (Precise::string_gt(leverage_ratio.clone(), Value::from("1")) || Precise::string_gt(super_leverage_ratio.clone(), Value::from("1"))).into();
            // 0 Delisting
            // 1 Listing
            // 2 Pending Listing
            // 3 Suspension
            // 4 Suspending of Listing
            // 5 In Settlement
            // 6 Delivering
            // 7 Settlement Completed
            // 8 Delivered
            // 9 Suspending of Trade
            result.push(Value::Json(normalize(&Value::Json(json!({
                "id": id,
                "lowercaseId": lowercase_id,
                "symbol": symbol,
                "base": base,
                "quote": quote,
                "settle": settle,
                "baseId": base_id,
                "lowercaseBaseId": lowercase_base_id,
                "quoteId": quote_id,
                "settleId": settle_id,
                "type": r#type,
                "spot": spot,
                "margin": spot.is_truthy() && has_leverage.is_truthy(),
                "swap": swap,
                "future": future,
                "option": false,
                "active": active,
                "contract": contract,
                "linear": linear,
                "inverse": inverse,
                "taker": taker,
                "maker": maker,
                "contractSize": contract_size,
                "expiry": expiry,
                "expiryDatetime": self.iso8601(expiry.clone()),
                "strike": Value::Undefined,
                "optionType": Value::Undefined,
                "precision": Value::Json(normalize(&Value::Json(json!({
                    "amount": amount_precision,
                    "price": price_precision,
                    "cost": cost_precision
                }))).unwrap()),
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "leverage": Value::Json(normalize(&Value::Json(json!({
                        "min": self.parse_number(Value::from("1"), Value::Undefined),
                        "max": self.parse_number(leverage_ratio.clone(), Value::Undefined),
                        "superMax": self.parse_number(super_leverage_ratio.clone(), Value::Undefined)
                    }))).unwrap()),
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": min_amount,
                        "max": max_amount
                    }))).unwrap()),
                    "price": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "cost": Value::Json(normalize(&Value::Json(json!({
                        "min": min_cost,
                        "max": Value::Undefined
                    }))).unwrap())
                }))).unwrap()),
                "info": market
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    fn parse_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        //
        // fetchTicker
        //
        //     {
        //         "amount": 26228.672978342216,
        //         "open": 9078.95,
        //         "close": 9146.86,
        //         "high": 9155.41,
        //         "id": 209988544334,
        //         "count": 265846,
        //         "low": 8988.0,
        //         "version": 209988544334,
        //         "ask": [ 9146.87, 0.156134 ],
        //         "vol": 2.3822168242201668E8,
        //         "bid": [ 9146.86, 0.080758 ],
        //     }
        //
        // fetchTickers
        //
        //     {
        //         symbol: "bhdht",
        //         open:  2.3938,
        //         high:  2.4151,
        //         low:  2.3323,
        //         close:  2.3909,
        //         amount:  628.992,
        //         vol:  1493.71841095,
        //         count:  2088,
        //         bid:  2.3643,
        //         bidSize:  0.7136,
        //         ask:  2.4061,
        //         askSize:  0.4156
        //     }
        //
        let mut market_id: Value = self.safe_string_2(ticker.clone(), Value::from("symbol"), Value::from("contract_code"), Value::Undefined);
        let mut symbol: Value = Huobi::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(ticker.clone(), Value::from("ts"), Value::Undefined);
        let mut bid: Value = Value::Undefined;
        let mut bid_volume: Value = Value::Undefined;
        let mut ask: Value = Value::Undefined;
        let mut ask_volume: Value = Value::Undefined;
        if ticker.contains_key(Value::from("bid")) {
            if Array::is_array(ticker.get(Value::from("bid"))).is_truthy() {
                bid = self.safe_string(ticker.get(Value::from("bid")), Value::from(0), Value::Undefined);
                bid_volume = self.safe_string(ticker.get(Value::from("bid")), Value::from(1), Value::Undefined);
            } else {
                bid = self.safe_string(ticker.clone(), Value::from("bid"), Value::Undefined);
                bid_volume = self.safe_string(ticker.clone(), Value::from("bidSize"), Value::Undefined);
            };
        };
        if ticker.contains_key(Value::from("ask")) {
            if Array::is_array(ticker.get(Value::from("ask"))).is_truthy() {
                ask = self.safe_string(ticker.get(Value::from("ask")), Value::from(0), Value::Undefined);
                ask_volume = self.safe_string(ticker.get(Value::from("ask")), Value::from(1), Value::Undefined);
            } else {
                ask = self.safe_string(ticker.clone(), Value::from("ask"), Value::Undefined);
                ask_volume = self.safe_string(ticker.clone(), Value::from("askSize"), Value::Undefined);
            };
        };
        let mut open: Value = self.safe_string(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_string(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut base_volume: Value = self.safe_string(ticker.clone(), Value::from("amount"), Value::Undefined);
        let mut quote_volume: Value = self.safe_string(ticker.clone(), Value::from("vol"), Value::Undefined);
        return Huobi::safe_ticker(self, Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "high": self.safe_string(ticker.clone(), Value::from("high"), Value::Undefined),
            "low": self.safe_string(ticker.clone(), Value::from("low"), Value::Undefined),
            "bid": bid,
            "bidVolume": bid_volume,
            "ask": ask,
            "askVolume": ask_volume,
            "vwap": Value::Undefined,
            "open": open,
            "close": close,
            "last": close,
            "previousClose": Value::Undefined,
            "change": Value::Undefined,
            "percentage": Value::Undefined,
            "average": Value::Undefined,
            "baseVolume": base_volume,
            "quoteVolume": quote_volume,
            "info": ticker
        }))).unwrap()), market.clone());
    }

    /// Returns a [ticker structure](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the ticker for
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_ticker(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let mut request: Value = Value::new_object();
        let mut field_name: Value = Value::from("symbol");
        let mut method: Value = Value::from("spotPublicGetMarketDetailMerged");
        if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("contractPublicGetLinearSwapExMarketDetailMerged");
            field_name = Value::from("contract_code");
        } else if market.get(Value::from("inverse")).is_truthy() {
            if market.get(Value::from("future")).is_truthy() {
                method = Value::from("contractPublicGetMarketDetailMerged");
            } else if market.get(Value::from("swap")).is_truthy() {
                method = Value::from("contractPublicGetSwapExMarketDetailMerged");
                field_name = Value::from("contract_code");
            };
        };
        request.set(field_name.clone(), market.get(Value::from("id")));
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "ch": "market.btcusdt.detail.merged",
        //         "ts": 1583494336669,
        //         "tick": {
        //             "amount": 26228.672978342216,
        //             "open": 9078.95,
        //             "close": 9146.86,
        //             "high": 9155.41,
        //             "id": 209988544334,
        //             "count": 265846,
        //             "low": 8988.0,
        //             "version": 209988544334,
        //             "ask": [ 9146.87, 0.156134 ],
        //             "vol": 2.3822168242201668E8,
        //             "bid": [ 9146.86, 0.080758 ],
        //         }
        //     }
        //
        // future, swap
        //
        //     {
        //         "ch":"market.BTC211126.detail.merged",
        //         "status":"ok",
        //         "tick":{
        //             "amount":"669.3385682049668320322569544150680718474",
        //             "ask":[59117.44,48],
        //             "bid":[59082,48],
        //             "close":"59087.97",
        //             "count":5947,
        //             "high":"59892.62",
        //             "id":1637502670,
        //             "low":"57402.87",
        //             "open":"57638",
        //             "ts":1637502670059,
        //             "vol":"394598"
        //         },
        //         "ts":1637502670059
        //     }
        //
        let mut tick: Value = self.safe_value(response.clone(), Value::from("tick"), Value::new_object());
        let mut ticker: Value = Huobi::parse_ticker(self, tick.clone(), market.clone());
        let mut timestamp: Value = self.safe_integer(response.clone(), Value::from("ts"), Value::Undefined);
        ticker.set("timestamp".into(), timestamp.clone());
        ticker.set("datetime".into(), self.iso8601(timestamp.clone()));
        return ticker.clone();
    }

    /// Returns an array of [ticker structures](https://docs.ccxt.com/en/latest/manual.html#ticker-structure)
    ///
    /// Fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_tickers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Huobi::market_symbols(self, symbols.clone());
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchTickers"), Value::new_object());
        let mut default_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultType"), Value::from("spot"));
        let mut r#type: Value = self.safe_string(options.clone(), Value::from("type"), default_type.clone());
        r#type = self.safe_string(params.clone(), Value::from("type"), r#type.clone());
        let mut method: Value = Value::from("spotPublicGetMarketTickers");
        let mut default_sub_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultSubType"), Value::from("inverse"));
        let mut sub_type: Value = self.safe_string(options.clone(), Value::from("subType"), default_sub_type.clone());
        sub_type = self.safe_string(params.clone(), Value::from("subType"), sub_type.clone());
        let mut request: Value = Value::new_object();
        let mut future: Value = (r#type.clone() == Value::from("future")).into();
        let mut swap: Value = (r#type.clone() == Value::from("swap")).into();
        let mut linear: Value = (sub_type.clone() == Value::from("linear")).into();
        let mut inverse: Value = (sub_type.clone() == Value::from("inverse")).into();
        if future.is_truthy() || swap.is_truthy() {
            if linear.is_truthy() {
                method = Value::from("contractPublicGetLinearSwapExMarketDetailBatchMerged");
                if future.is_truthy() {
                    request.set("business_type".into(), Value::from("futures"));
                };
            } else if inverse.is_truthy() {
                if future.is_truthy() {
                    method = Value::from("contractPublicGetMarketDetailBatchMerged");
                } else if swap.is_truthy() {
                    method = Value::from("contractPublicGetSwapExMarketDetailBatchMerged");
                };
            };
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("type").into(), Value::from("subType").into()])));
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "data":[
        //             {
        //                 "symbol":"hbcbtc",
        //                 "open":5.313E-5,
        //                 "high":5.34E-5,
        //                 "low":5.112E-5,
        //                 "close":5.175E-5,
        //                 "amount":1183.87,
        //                 "vol":0.0618599229,
        //                 "count":205,
        //                 "bid":5.126E-5,
        //                 "bidSize":5.25,
        //                 "ask":5.214E-5,
        //                 "askSize":150.0
        //             },
        //         ],
        //         "status":"ok",
        //         "ts":1639547261293
        //     }
        //
        // inverse swaps, linear swaps, inverse futures
        //
        //     {
        //         "status":"ok",
        //         "ticks":[
        //             {
        //                 "id":1637504679,
        //                 "ts":1637504679372,
        //                 "ask":[0.10644,100],
        //                 "bid":[0.10624,26],
        //                 "symbol":"TRX_CW",
        //                 "open":"0.10233",
        //                 "close":"0.10644",
        //                 "low":"0.1017",
        //                 "high":"0.10725",
        //                 "amount":"2340267.415144052378486261756692535687481566",
        //                 "count":882,
        //                 "vol":"24706"
        //             }
        //         ],
        //         "ts":1637504679376
        //     }
        //
        // linear futures
        //
        //     {
        //         "status":"ok",
        //         "ticks":[
        //             {
        //                 "id":1640745627,
        //                 "ts":1640745627957,
        //                 "ask":[48079.1,20],
        //                 "bid":[47713.8,125],
        //                 "business_type":"futures",
        //                 "contract_code":"BTC-USDT-CW",
        //                 "open":"49011.8",
        //                 "close":"47934",
        //                 "low":"47292.3",
        //                 "high":"49011.8",
        //                 "amount":"17.398",
        //                 "count":1515,
        //                 "vol":"17398",
        //                 "trade_turnover":"840726.5048"
        //             }
        //         ],
        //         "ts":1640745627988
        //     }
        //
        let mut tickers: Value = self.safe_value_2(response.clone(), Value::from("data"), Value::from("ticks"), Value::new_array());
        let mut timestamp: Value = self.safe_integer(response.clone(), Value::from("ts"), Value::Undefined);
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < tickers.len() {
            let mut ticker: Value = Huobi::parse_ticker(self, tickers.get(i.into()), Value::Undefined);
            // the market ids for linear futures are non-standard and differ from all the other endpoints
            // we are doing a linear-matching here
            if future.is_truthy() && linear.is_truthy() {
                let mut j: usize = 0;
                while j < self.get("symbols".into()).len() {
                    let mut symbol: Value = self.get("symbols".into()).get(j.into());
                    let mut market: Value = Huobi::market(self, symbol.clone());
                    let mut contract_type: Value = self.safe_string(market.get(Value::from("info")), Value::from("contract_type"), Value::Undefined);
                    if contract_type.clone() == Value::from("this_week") && ticker.get(Value::from("symbol")) == market.get(Value::from("baseId")) + Value::from("-") + market.get(Value::from("quoteId")) + Value::from("-CW") {
                        ticker.set("symbol".into(), market.get(Value::from("symbol")));
                        break;
                    } else if contract_type.clone() == Value::from("next_week") && ticker.get(Value::from("symbol")) == market.get(Value::from("baseId")) + Value::from("-") + market.get(Value::from("quoteId")) + Value::from("-NW") {
                        ticker.set("symbol".into(), market.get(Value::from("symbol")));
                        break;
                    } else if contract_type.clone() == Value::from("this_quarter") && ticker.get(Value::from("symbol")) == market.get(Value::from("baseId")) + Value::from("-") + market.get(Value::from("quoteId")) + Value::from("-CQ") {
                        ticker.set("symbol".into(), market.get(Value::from("symbol")));
                        break;
                    } else if contract_type.clone() == Value::from("next_quarter") && ticker.get(Value::from("symbol")) == market.get(Value::from("baseId")) + Value::from("-") + market.get(Value::from("quoteId")) + Value::from("-NQ") {
                        ticker.set("symbol".into(), market.get(Value::from("symbol")));
                        break;
                    };
                    j += 1;
                };
            };
            let mut symbol: Value = ticker.get(Value::from("symbol"));
            ticker.set("timestamp".into(), timestamp.clone());
            ticker.set("datetime".into(), self.iso8601(timestamp.clone()));
            result.set(symbol.clone(), ticker.clone());
            i += 1;
        };
        return Huobi::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    /// Returns a dictionary of [order book structures](https://docs.ccxt.com/en/latest/manual.html#order-book-structure) indexed by market symbols
    ///
    /// Fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the order book for
    /// * `limit` {int|undefined} - the maximum amount of order book entries to return
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "type": "step0"
        }))).unwrap());
        //
        // from the API docs
        //
        //     to get depth data within step 150, use step0, step1, step2, step3, step4, step5, step14, step15merged depth data 0-5,14-15, when step is 0depth data will not be merged
        //     to get depth data within step 20, use step6, step7, step8, step9, step10, step11, step12, step13(merged depth data 7-13), when step is 6, depth data will not be merged
        //
        // 'symbol': market['id'], // spot, future
        // 'contract_code': market['id'], // swap
        let mut field_name: Value = Value::from("symbol");
        let mut method: Value = Value::from("spotPublicGetMarketDepth");
        if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("contractPublicGetLinearSwapExMarketDepth");
            field_name = Value::from("contract_code");
        } else if market.get(Value::from("inverse")).is_truthy() {
            if market.get(Value::from("future")).is_truthy() {
                method = Value::from("contractPublicGetMarketDepth");
            } else if market.get(Value::from("swap")).is_truthy() {
                method = Value::from("contractPublicGetSwapExMarketDepth");
                field_name = Value::from("contract_code");
            };
        } else {
            if limit.clone().is_nonnullish() {
                // Valid depths are 5, 10, 20 or empty https://huobiapi.github.io/docs/spot/v1/en/#get-market-depth
                if limit.clone() != Value::from(5) && limit.clone() != Value::from(10) && limit.clone() != Value::from(20) && limit.clone() != Value::from(150) {
                    panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchOrderBook() limit argument must be undefined, 5, 10, 20, or 150, default is 150"))"###);
                };
                // only set the depth if it is not 150
                // 150 is the implicit default on the exchange side for step0 and no orderbook aggregation
                // it is not accepted by the exchange if you set it explicitly
                if limit.clone() != Value::from(150) {
                    request.set("depth".into(), limit.clone());
                };
            };
        };
        request.set(field_name.clone(), market.get(Value::from("id")));
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot, future, swap
        //
        //     {
        //         "status": "ok",
        //         "ch": "market.btcusdt.depth.step0",
        //         "ts": 1583474832790,
        //         "tick": {
        //             "bids": [
        //                 [ 9100.290000000000000000, 0.200000000000000000 ],
        //                 [ 9099.820000000000000000, 0.200000000000000000 ],
        //                 [ 9099.610000000000000000, 0.205000000000000000 ],
        //             ],
        //             "asks": [
        //                 [ 9100.640000000000000000, 0.005904000000000000 ],
        //                 [ 9101.010000000000000000, 0.287311000000000000 ],
        //                 [ 9101.030000000000000000, 0.012121000000000000 ],
        //             ],
        //             "ch":"market.BTC-USD.depth.step0",
        //             "ts":1583474832008,
        //             "id":1637554816,
        //             "mrid":121654491624,
        //             "version":104999698780
        //         }
        //     }
        //
        if response.contains_key(Value::from("tick")) {
            if !response.get(Value::from("tick")).is_truthy() {
                panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" fetchOrderBook() returned empty response: ") + self.json(response.clone(), Value::Undefined))"###);
            };
            let mut tick: Value = self.safe_value(response.clone(), Value::from("tick"), Value::Undefined);
            let mut timestamp: Value = self.safe_integer(tick.clone(), Value::from("ts"), self.safe_integer(response.clone(), Value::from("ts"), Value::Undefined));
            let mut result: Value = Huobi::parse_order_book(self, tick.clone(), symbol.clone(), timestamp.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
            result.set("nonce".into(), self.safe_integer(tick.clone(), Value::from("version"), Value::Undefined));
            return result.clone();
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchOrderBook() returned unrecognized response: ") + self.json(response.clone(), Value::Undefined))"###);
        Value::Undefined
    }

    fn parse_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        //
        // spot fetchTrades (public)
        //
        //     {
        //         "amount": 0.010411000000000000,
        //         "trade-id": 102090736910,
        //         "ts": 1583497692182,
        //         "id": 10500517034273194594947,
        //         "price": 9096.050000000000000000,
        //         "direction": "sell"
        //     }
        //
        // spot fetchMyTrades (private)
        //
        //     {
        //          'symbol': 'swftcbtc',
        //          'fee-currency': 'swftc',
        //          'filled-fees': '0',
        //          'source': 'spot-api',
        //          'id': 83789509854000,
        //          'type': 'buy-limit',
        //          'order-id': 83711103204909,
        //          'filled-points': '0.005826843283532154',
        //          'fee-deduct-currency': 'ht',
        //          'filled-amount': '45941.53',
        //          'price': '0.0000001401',
        //          'created-at': 1597933260729,
        //          'match-id': 100087455560,
        //          'role': 'maker',
        //          'trade-id': 100050305348
        //     }
        //
        // linear swap isolated margin fetchOrder details
        //
        //     {
        //         "trade_id": 131560927,
        //         "trade_price": 13059.800000000000000000,
        //         "trade_volume": 1.000000000000000000,
        //         "trade_turnover": 13.059800000000000000,
        //         "trade_fee": -0.005223920000000000,
        //         "created_at": 1603703614715,
        //         "role": "taker",
        //         "fee_asset": "USDT",
        //         "profit": 0,
        //         "real_profit": 0,
        //         "id": "131560927-770334322963152896-1"
        //     }
        //
        // inverse swap cross margin fetchMyTrades
        //
        //     {
        //         "contract_type":"swap",
        //         "pair":"O3-USDT",
        //         "business_type":"swap",
        //         "query_id":652123190,
        //         "match_id":28306009409,
        //         "order_id":941137865226903553,
        //         "symbol":"O3",
        //         "contract_code":"O3-USDT",
        //         "direction":"sell",
        //         "offset":"open",
        //         "trade_volume":100.000000000000000000,
        //         "trade_price":0.398500000000000000,
        //         "trade_turnover":39.850000000000000000,
        //         "trade_fee":-0.007970000000000000,
        //         "offset_profitloss":0E-18,
        //         "create_date":1644426352999,
        //         "role":"Maker",
        //         "order_source":"api",
        //         "order_id_str":"941137865226903553",
        //         "id":"28306009409-941137865226903553-1",
        //         "fee_asset":"USDT",
        //         "margin_mode":"cross",
        //         "margin_account":"USDT",
        //         "real_profit":0E-18,
        //         "trade_partition":"USDT"
        //     }
        //
        let mut market_id: Value = self.safe_string_2(trade.clone(), Value::from("contract_code"), Value::from("symbol"), Value::Undefined);
        market = Huobi::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut timestamp: Value = self.safe_integer_2(trade.clone(), Value::from("ts"), Value::from("created-at"), Value::Undefined);
        timestamp = self.safe_integer_2(trade.clone(), Value::from("created_at"), Value::from("create_date"), timestamp.clone());
        let mut order: Value = self.safe_string_2(trade.clone(), Value::from("order-id"), Value::from("order_id"), Value::Undefined);
        let mut side: Value = self.safe_string(trade.clone(), Value::from("direction"), Value::Undefined);
        let mut r#type: Value = self.safe_string(trade.clone(), Value::from("type"), Value::Undefined);
        if r#type.clone().is_nonnullish() {
            let mut type_parts: Value = r#type.split(Value::from("-"));
            side = type_parts.get(Value::from(0));
            r#type = type_parts.get(Value::from(1));
        };
        let mut taker_or_maker: Value = self.safe_string_lower(trade.clone(), Value::from("role"), Value::Undefined);
        let mut price_string: Value = self.safe_string_2(trade.clone(), Value::from("price"), Value::from("trade_price"), Value::Undefined);
        let mut amount_string: Value = self.safe_string_2(trade.clone(), Value::from("filled-amount"), Value::from("amount"), Value::Undefined);
        amount_string = self.safe_string(trade.clone(), Value::from("trade_volume"), amount_string.clone());
        let mut cost_string: Value = self.safe_string(trade.clone(), Value::from("trade_turnover"), Value::Undefined);
        let mut fee: Value = Value::Undefined;
        let mut fee_cost: Value = self.safe_string_2(trade.clone(), Value::from("filled-fees"), Value::from("trade_fee"), Value::Undefined);
        let mut fee_currency_id: Value = self.safe_string_2(trade.clone(), Value::from("fee-currency"), Value::from("fee_asset"), Value::Undefined);
        let mut fee_currency: Value = Huobi::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined);
        let mut filled_points: Value = self.safe_string(trade.clone(), Value::from("filled-points"), Value::Undefined);
        if filled_points.clone().is_nonnullish() {
            if fee_cost.clone().is_nullish() || Precise::string_equals(fee_cost.clone(), Value::from("0")) {
                let mut fee_deduct_currency: Value = self.safe_string(trade.clone(), Value::from("fee-deduct-currency"), Value::Undefined);
                if fee_deduct_currency.clone() != Value::from("") {
                    fee_cost = filled_points.clone();
                    fee_currency = Huobi::safe_currency_code(self, fee_deduct_currency.clone(), Value::Undefined);
                };
            };
        };
        if fee_cost.clone().is_nonnullish() {
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost,
                "currency": fee_currency
            }))).unwrap());
        };
        let mut trade_id: Value = self.safe_string_2(trade.clone(), Value::from("trade-id"), Value::from("tradeId"), Value::Undefined);
        let mut id: Value = self.safe_string_2(trade.clone(), Value::from("trade_id"), Value::from("id"), trade_id.clone());
        return Huobi::safe_trade(self, Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "info": trade,
            "order": order,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "symbol": symbol,
            "type": r#type,
            "side": side,
            "takerOrMaker": taker_or_maker,
            "price": price_string,
            "amount": amount_string,
            "cost": cost_string,
            "fee": fee
        }))).unwrap()), market.clone());
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all the trades made from a single order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades to retrieve
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_order_trades(&mut self, mut id: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Huobi::market(self, symbol.clone());
        };
        let mut market_type: Value = Value::Undefined;
        (market_type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchOrderTrades"), market.clone(), params.clone()));
        let mut method: Value = Huobi::get_supported_mapping(self, market_type.clone(), Value::Json(normalize(&Value::Json(json!({
            "spot": "fetchSpotOrderTrades"
        }))).unwrap()));
        // 'swap': 'fetchContractOrderTrades',
        // 'future': 'fetchContractOrderTrades',
        return Huobi::dispatch(self, method, id.clone(), symbol.clone()).await;
    }

    async fn fetch_spot_order_trades(&mut self, mut id: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "order-id": id
        }))).unwrap());
        let mut response: Value = Huobi::dispatch(self, "spotPrivateGetV1OrderOrdersOrderIdMatchresults".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        return Huobi::parse_trades(self, response.get(Value::from("data")), Value::Undefined, since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html#trade-structure)
    ///
    /// Fetch all trades made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch trades for
    /// * `limit` {int|undefined} - the maximum number of trades structures to retrieve
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_my_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Huobi::market(self, symbol.clone());
        };
        let mut market_type: Value = Value::Undefined;
        (market_type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchMyTrades"), market.clone(), params.clone()));
        let mut request: Value = Value::new_object();
        // spot -----------------------------------------------------------
        // 'symbol': market['id'],
        // 'types': 'buy-market,sell-market,buy-limit,sell-limit,buy-ioc,sell-ioc,buy-limit-maker,sell-limit-maker,buy-stop-limit,sell-stop-limit',
        // 'start-time': since, // max 48 hours within 120 days
        // 'end-time': this.milliseconds (), // max 48 hours within 120 days
        // 'from': 'id', // tring false N/A Search internal id to begin with if search next page, then this should be the last id (not trade-id) of last page; if search previous page, then this should be the first id (not trade-id) of last page
        // 'direct': 'next', // next, prev
        // 'size': limit, // default 100, max 500 The number of orders to return [1-500]
        // contracts ------------------------------------------------------
        // 'symbol': market['settleId'], // required
        // 'trade_type': 0, // required, 0 all, 1 open long, 2 open short, 3 close short, 4 close long, 5 liquidate long positions, 6 liquidate short positions
        // 'contract_code': market['id'],
        // 'start_time': since, // max 48 hours within 120 days
        // 'end_time': this.milliseconds (), // max 48 hours within 120 days
        // 'from_id': 'id', // tring false N/A Search internal id to begin with if search next page, then this should be the last id (not trade-id) of last page; if search previous page, then this should be the first id (not trade-id) of last page
        // 'direct': 'prev', // next, prev
        // 'size': limit, // default 20, max 50
        let mut method: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            if symbol.clone().is_nonnullish() {
                market = Huobi::market(self, symbol.clone());
                request.set("symbol".into(), market.get(Value::from("id")));
            };
            if limit.clone().is_nonnullish() {
                request.set("size".into(), limit.clone());
            };
            // default 100, max 500
            if since.clone().is_nonnullish() {
                request.set("start-time".into(), since.clone());
            };
            // a date within 120 days from today
            // request['end-time'] = this.sum (since, 172800000); // 48 hours window
            method = Value::from("spotPrivateGetV1OrderMatchresults");
        } else {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchMyTrades() requires a symbol for ") + market_type.clone() + Value::from(" orders"))"###);
            };
            request.set("contract_code".into(), market.get(Value::from("id")));
            request.set("trade_type".into(), Value::from(0));
            // 0 all, 1 open long, 2 open short, 3 close short, 4 close long, 5 liquidate long positions, 6 liquidate short positions
            if market.get(Value::from("linear")).is_truthy() {
                let mut margin_mode: Value = Value::Undefined;
                (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("fetchMyTrades"), params.clone()));
                margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
                if margin_mode.clone() == Value::from("isolated") {
                    method = Value::from("contractPrivatePostLinearSwapApiV1SwapMatchresultsExact");
                } else if margin_mode.clone() == Value::from("cross") {
                    method = Value::from("contractPrivatePostLinearSwapApiV1SwapCrossMatchresultsExact");
                };
            } else if market.get(Value::from("inverse")).is_truthy() {
                if market_type.clone() == Value::from("future") {
                    method = Value::from("contractPrivatePostApiV1ContractMatchresultsExact");
                    request.set("symbol".into(), market.get(Value::from("settleId")));
                } else if market_type.clone() == Value::from("swap") {
                    method = Value::from("contractPrivatePostSwapApiV1SwapMatchresultsExact");
                } else {
                    panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMyTrades() does not support ") + market_type.clone() + Value::from(" markets"))"###);
                };
            };
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "symbol": "polyusdt",
        //                 "fee-currency": "poly",
        //                 "source": "spot-web",
        //                 "price": "0.338",
        //                 "created-at": 1629443051839,
        //                 "role": "taker",
        //                 "order-id": 345487249132375,
        //                 "match-id": 5014,
        //                 "trade-id": 1085,
        //                 "filled-amount": "147.928994082840236",
        //                 "filled-fees": "0",
        //                 "filled-points": "0.1",
        //                 "fee-deduct-currency": "hbpoint",
        //                 "fee-deduct-state": "done",
        //                 "id": 313288753120940,
        //                 "type": "buy-market"
        //             }
        //         ]
        //     }
        //
        // contracts
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "trades": [
        //                 {
        //                     "query_id": 2424420723,
        //                     "match_id": 113891764710,
        //                     "order_id": 773135295142658048,
        //                     "symbol": "ADA",
        //                     "contract_type": "quarter", // swap
        //                     "business_type": "futures", // swap
        //                     "contract_code": "ADA201225",
        //                     "direction": "buy",
        //                     "offset": "open",
        //                     "trade_volume": 1,
        //                     "trade_price": 0.092,
        //                     "trade_turnover": 10,
        //                     "trade_fee": -0.021739130434782608,
        //                     "offset_profitloss": 0,
        //                     "create_date": 1604371703183,
        //                     "role": "Maker",
        //                     "order_source": "web",
        //                     "order_id_str": "773135295142658048",
        //                     "fee_asset": "ADA",
        //                     "margin_mode": "isolated", // cross
        //                     "margin_account": "BTC-USDT",
        //                     "real_profit": 0,
        //                     "id": "113891764710-773135295142658048-1",
        //                     "trade_partition":"USDT",
        //                 }
        //             ],
        //             "remain_size": 15,
        //             "next_id": 2424413094
        //         },
        //         "ts": 1604372202243
        //     }
        //
        let mut trades: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        if !Array::is_array(trades.clone()).is_truthy() {
            trades = self.safe_value(trades.clone(), Value::from("trades"), Value::Undefined);
        };
        return Huobi::parse_trades(self, trades.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [trade structures](https://docs.ccxt.com/en/latest/manual.html?#public-trades)
    ///
    /// Get the list of most recent trades for a particular symbol
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch trades for
    /// * `since` {int|undefined} - timestamp in ms of the earliest trade to fetch
    /// * `limit` {int|undefined} - the maximum amount of trades to fetch
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_trades(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        limit = limit.or_default(Value::from(1000));
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let mut request: Value = Value::new_object();
        // 'symbol': market['id'], // spot, future
        // 'contract_code': market['id'], // swap
        let mut field_name: Value = Value::from("symbol");
        let mut method: Value = Value::from("spotPublicGetMarketHistoryTrade");
        if market.get(Value::from("future")).is_truthy() {
            if market.get(Value::from("inverse")).is_truthy() {
                method = Value::from("contractPublicGetMarketHistoryTrade");
            } else if market.get(Value::from("linear")).is_truthy() {
                method = Value::from("contractPublicGetLinearSwapExMarketHistoryTrade");
                field_name = Value::from("contract_code");
            };
        } else if market.get(Value::from("swap")).is_truthy() {
            if market.get(Value::from("inverse")).is_truthy() {
                method = Value::from("contractPublicGetSwapExMarketHistoryTrade");
            } else if market.get(Value::from("linear")).is_truthy() {
                method = Value::from("contractPublicGetLinearSwapExMarketHistoryTrade");
            };
            field_name = Value::from("contract_code");
        };
        request.set(field_name.clone(), market.get(Value::from("id")));
        if limit.clone().is_nonnullish() {
            request.set("size".into(), limit.clone());
        };
        // max 2000
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "status": "ok",
        //         "ch": "market.btcusdt.trade.detail",
        //         "ts": 1583497692365,
        //         "data": [
        //             {
        //                 "id": 105005170342,
        //                 "ts": 1583497692182,
        //                 "data": [
        //                     {
        //                         "amount": 0.010411000000000000,
        //                         "trade-id": 102090736910,
        //                         "ts": 1583497692182,
        //                         "id": 10500517034273194594947,
        //                         "price": 9096.050000000000000000,
        //                         "direction": "sell"
        //                     }
        //                 ]
        //             },
        //             // ...
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < data.len() {
            let mut trades: Value = self.safe_value(data.get(i.into()), Value::from("data"), Value::new_array());
            let mut j: usize = 0;
            while j < trades.len() {
                let mut trade: Value = Huobi::parse_trade(self, trades.get(j.into()), market.clone());
                result.push(trade.clone());
                j += 1;
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Huobi::filter_by_symbol_since_limit(self, result.clone(), market.get(Value::from("symbol")), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_ohlcv(&self, mut ohlcv: Value, mut market: Value) -> Value {
        //
        //     {
        //         "amount":1.2082,
        //         "open":0.025096,
        //         "close":0.025095,
        //         "high":0.025096,
        //         "id":1591515300,
        //         "count":6,
        //         "low":0.025095,
        //         "vol":0.0303205097
        //     }
        //
        return Value::Json(serde_json::Value::Array(vec![self.safe_timestamp(ohlcv.clone(), Value::from("id"), Value::Undefined).into(), Huobi::safe_number(self, ohlcv.clone(), Value::from("open"), Value::Undefined).into(), Huobi::safe_number(self, ohlcv.clone(), Value::from("high"), Value::Undefined).into(), Huobi::safe_number(self, ohlcv.clone(), Value::from("low"), Value::Undefined).into(), Huobi::safe_number(self, ohlcv.clone(), Value::from("close"), Value::Undefined).into(), Huobi::safe_number(self, ohlcv.clone(), Value::from("amount"), Value::Undefined).into()]));
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, volume
    ///
    /// Fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "period": self.get("timeframes".into()).get(timeframe.clone())
        }))).unwrap());
        // 'symbol': market['id'], // spot, future
        // 'contract_code': market['id'], // swap
        // 'size': 1000, // max 1000 for spot, 2000 for contracts
        // 'from': parseInt (since / 1000), spot only
        // 'to': this.seconds (), spot only
        let mut field_name: Value = Value::from("symbol");
        let mut price: Value = self.safe_string(params.clone(), Value::from("price"), Value::Undefined);
        params = self.omit(params.clone(), Value::from("price"));
        let mut method: Value = Value::from("spotPublicGetMarketHistoryCandles");
        if market.get(Value::from("spot")).is_truthy() {
            if since.clone().is_nonnullish() {
                request.set("from".into(), parse_int(since.clone() / Value::from(1000)));
            };
            if limit.clone().is_nonnullish() {
                request.set("size".into(), limit.clone());
            };
        } else if market.get(Value::from("future")).is_truthy() {
            // max 2000
            if market.get(Value::from("inverse")).is_truthy() {
                if price.clone() == Value::from("mark") {
                    method = Value::from("contractPublicGetIndexMarketHistoryMarkPriceKline");
                } else if price.clone() == Value::from("index") {
                    method = Value::from("contractPublicGetIndexMarketHistoryIndex");
                } else if price.clone() == Value::from("premiumIndex") {
                    panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" ") + market.get(Value::from("type")) + Value::from(" has no api endpoint for ") + price.clone() + Value::from(" kline data"))"###);
                } else {
                    method = Value::from("contractPublicGetMarketHistoryKline");
                };
            } else if market.get(Value::from("linear")).is_truthy() {
                if price.clone() == Value::from("mark") {
                    method = Value::from("contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline");
                } else if price.clone() == Value::from("index") {
                    panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" ") + market.get(Value::from("type")) + Value::from(" has no api endpoint for ") + price.clone() + Value::from(" kline data"))"###);
                } else if price.clone() == Value::from("premiumIndex") {
                    method = Value::from("contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline");
                } else {
                    method = Value::from("contractPublicGetLinearSwapExMarketHistoryKline");
                };
                field_name = Value::from("contract_code");
            };
        } else if market.get(Value::from("swap")).is_truthy() {
            if market.get(Value::from("inverse")).is_truthy() {
                if price.clone() == Value::from("mark") {
                    method = Value::from("contractPublicGetIndexMarketHistorySwapMarkPriceKline");
                } else if price.clone() == Value::from("index") {
                    panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" ") + market.get(Value::from("type")) + Value::from(" has no api endpoint for ") + price.clone() + Value::from(" kline data"))"###);
                } else if price.clone() == Value::from("premiumIndex") {
                    method = Value::from("contractPublicGetIndexMarketHistorySwapPremiumIndexKline");
                } else {
                    method = Value::from("contractPublicGetSwapExMarketHistoryKline");
                };
            } else if market.get(Value::from("linear")).is_truthy() {
                if price.clone() == Value::from("mark") {
                    method = Value::from("contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline");
                } else if price.clone() == Value::from("index") {
                    panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" ") + market.get(Value::from("type")) + Value::from(" has no api endpoint for ") + price.clone() + Value::from(" kline data"))"###);
                } else if price.clone() == Value::from("premiumIndex") {
                    method = Value::from("contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline");
                } else {
                    method = Value::from("contractPublicGetLinearSwapExMarketHistoryKline");
                };
            };
            field_name = Value::from("contract_code");
        };
        if market.get(Value::from("contract")).is_truthy() {
            if limit.clone().is_nullish() {
                limit = Value::from(2000);
            };
            request.set("size".into(), limit.clone());
            if price.clone().is_nullish() {
                let mut duration: Value = self.parse_timeframe(timeframe.clone());
                if since.clone().is_nullish() {
                    let mut now: Value = self.seconds();
                    request.set("from".into(), now.clone() - duration.clone() * limit.clone() - Value::from(1));
                    request.set("to".into(), now.clone());
                } else {
                    let mut start: Value = parse_int(since.clone() / Value::from(1000));
                    request.set("from".into(), start.clone());
                    request.set("to".into(), self.sum(start.clone(), duration.clone() * limit.clone() - Value::from(1)));
                };
            };
        };
        request.set(field_name.clone(), market.get(Value::from("id")));
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "status":"ok",
        //         "ch":"market.ethbtc.kline.1min",
        //         "ts":1591515374371,
        //         "data":[
        //             {"amount":0.0,"open":0.025095,"close":0.025095,"high":0.025095,"id":1591515360,"count":0,"low":0.025095,"vol":0.0},
        //             {"amount":1.2082,"open":0.025096,"close":0.025095,"high":0.025096,"id":1591515300,"count":6,"low":0.025095,"vol":0.0303205097},
        //             {"amount":0.0648,"open":0.025096,"close":0.025096,"high":0.025096,"id":1591515240,"count":2,"low":0.025096,"vol":0.0016262208},
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Huobi::parse_ohlcvs(self, data.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    /// Returns a dictionary of [account structures](https://docs.ccxt.com/en/latest/manual.html#account-structure) indexed by the account type
    ///
    /// Fetch all the accounts associated with a profile
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_accounts(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Huobi::dispatch(self, "spotPrivateGetV1AccountAccounts".into(), params.clone(), Value::Undefined).await;
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {"id":5202591,"type":"point","subtype":"","state":"working"},
        //             {"id":1528640,"type":"spot","subtype":"","state":"working"},
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        return Huobi::parse_accounts(self, data.clone(), Value::Undefined);
    }

    fn parse_account(&self, mut account: Value) -> Value {
        //
        //     {
        //         "id": 5202591,
        //         "type": "point",   // spot, margin, otc, point, super-margin, investment, borrow, grid-trading, deposit-earning, otc-options
        //         "subtype": "",     // The corresponding trading symbol (currency pair) the isolated margin is based on, e.g. btcusdt
        //         "state": "working" // working, lock
        //     }
        //
        let mut type_id: Value = self.safe_string(account.clone(), Value::from("type"), Value::Undefined);
        let mut accounts_by_id: Value = self.safe_value(self.get("options".into()), Value::from("accountsById"), Value::new_object());
        let mut r#type: Value = self.safe_value(accounts_by_id.clone(), type_id.clone(), type_id.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "info": account,
            "id": self.safe_string(account.clone(), Value::from("id"), Value::Undefined),
            "type": r#type,
            "code": Value::Undefined
        }))).unwrap());
    }

    async fn fetch_account_id_by_type(&mut self, mut r#type: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut accounts: Value = Huobi::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut account_id: Value = self.safe_value(params.clone(), Value::from("account-id"), Value::Undefined);
        if account_id.clone().is_nonnullish() {
            return account_id.clone();
        };
        let mut indexed_accounts: Value = self.index_by(accounts.clone(), Value::from("type"), Value::Undefined);
        let mut default_account: Value = self.safe_value(accounts.clone(), Value::from(0), Value::new_object());
        let mut account: Value = self.safe_value(indexed_accounts.clone(), r#type.clone(), default_account.clone());
        return self.safe_string(account.clone(), Value::from("id"), Value::Undefined);
    }

    /// Returns an associative dictionary of currencies
    ///
    /// Fetches all available currencies on an exchange
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_currencies(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut response: Value = Huobi::dispatch(self, "spotPublicGetV2ReferenceCurrencies".into(), params.clone(), Value::Undefined).await;
        //     {
        //       "code": 200,
        //       "data": [
        //         {
        //           "currency": "sxp",
        //           "assetType": "1",
        //           "chains": [
        //             {
        //               "chain": "sxp",
        //               "displayName": "ERC20",
        //               "baseChain": "ETH",
        //               "baseChainProtocol": "ERC20",
        //               "isDynamic": true,
        //               "numOfConfirmations": "12",
        //               "numOfFastConfirmations": "12",
        //               "depositStatus": "allowed",
        //               "minDepositAmt": "0.23",
        //               "withdrawStatus": "allowed",
        //               "minWithdrawAmt": "0.23",
        //               "withdrawPrecision": "8",
        //               "maxWithdrawAmt": "227000.000000000000000000",
        //               "withdrawQuotaPerDay": "227000.000000000000000000",
        //               "withdrawQuotaPerYear": null,
        //               "withdrawQuotaTotal": null,
        //               "withdrawFeeType": "fixed",
        //               "transactFeeWithdraw": "11.1653",
        //               "addrWithTag": false,
        //               "addrDepositTag": false
        //             }
        //           ],
        //           "instStatus": "normal"
        //         }
        //       ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < data.len() {
            let mut entry: Value = data.get(i.into());
            let mut currency_id: Value = self.safe_string(entry.clone(), Value::from("currency"), Value::Undefined);
            let mut code: Value = Huobi::safe_currency_code(self, currency_id.clone(), Value::Undefined);
            let mut chains: Value = self.safe_value(entry.clone(), Value::from("chains"), Value::new_array());
            let mut networks: Value = Value::new_object();
            let mut inst_status: Value = self.safe_string(entry.clone(), Value::from("instStatus"), Value::Undefined);
            let mut currency_active: Value = (inst_status.clone() == Value::from("normal")).into();
            let mut fee: Value = Value::Undefined;
            let mut min_precision: Value = Value::Undefined;
            let mut min_withdraw: Value = Value::Undefined;
            let mut max_withdraw: Value = Value::Undefined;
            let mut deposit: Value = Value::Undefined;
            let mut withdraw: Value = Value::Undefined;
            let mut j: usize = 0;
            while j < chains.len() {
                let mut chain: Value = chains.get(j.into());
                let mut network_id: Value = self.safe_string(chain.clone(), Value::from("chain"), Value::Undefined);
                let mut base_chain_protocol: Value = self.safe_string(chain.clone(), Value::from("baseChainProtocol"), Value::Undefined);
                let mut huobi_token: Value = Value::from("h") + currency_id.clone();
                if base_chain_protocol.clone().is_nullish() {
                    if huobi_token.clone() == network_id.clone() {
                        base_chain_protocol = Value::from("ERC20");
                    } else {
                        base_chain_protocol = self.safe_string(chain.clone(), Value::from("displayName"), Value::Undefined);
                    };
                };
                let mut network: Value = Huobi::safe_network(self, base_chain_protocol.clone());
                min_withdraw = Huobi::safe_number(self, chain.clone(), Value::from("minWithdrawAmt"), Value::Undefined);
                max_withdraw = Huobi::safe_number(self, chain.clone(), Value::from("maxWithdrawAmt"), Value::Undefined);
                let mut withdraw_status: Value = self.safe_string(chain.clone(), Value::from("withdrawStatus"), Value::Undefined);
                let mut deposit_status: Value = self.safe_string(chain.clone(), Value::from("depositStatus"), Value::Undefined);
                let mut withdraw_enabled: Value = (withdraw_status.clone() == Value::from("allowed")).into();
                let mut deposit_enabled: Value = (deposit_status.clone() == Value::from("allowed")).into();
                let mut active: Value = (withdraw_enabled.is_truthy() && deposit_enabled.is_truthy()).into();
                let mut precision: Value = self.parse_number(Huobi::parse_precision(self, self.safe_string(chain.clone(), Value::from("withdrawPrecision"), Value::Undefined)), Value::Undefined);
                if precision.clone().is_nonnullish() {
                    min_precision = if min_precision.clone().is_nullish() { precision.clone() } else { Math::max(precision.clone(), min_precision.clone()) };
                };
                if withdraw_enabled.is_truthy() && !withdraw.is_truthy() {
                    withdraw = true.into();
                } else if !withdraw_enabled.is_truthy() {
                    withdraw = false.into();
                };
                if deposit_enabled.is_truthy() && !deposit.is_truthy() {
                    deposit = true.into();
                } else if !deposit_enabled.is_truthy() {
                    deposit = false.into();
                };
                fee = Huobi::safe_number(self, chain.clone(), Value::from("transactFeeWithdraw"), Value::Undefined);
                networks.set(network.clone(), Value::Json(normalize(&Value::Json(json!({
                    "info": chain,
                    "id": network_id,
                    "network": network,
                    "limits": Value::Json(normalize(&Value::Json(json!({
                        "withdraw": Value::Json(normalize(&Value::Json(json!({
                            "min": min_withdraw,
                            "max": max_withdraw
                        }))).unwrap())
                    }))).unwrap()),
                    "active": active,
                    "deposit": deposit_enabled,
                    "withdraw": withdraw_enabled,
                    "fee": fee,
                    "precision": precision
                }))).unwrap()));
                j += 1;
            };
            let mut networks_keys: Value = Object::keys(networks.clone());
            let mut network_length: Value = networks_keys.len().into();
            result.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                "info": entry,
                "code": code,
                "id": currency_id,
                "active": currency_active,
                "deposit": deposit,
                "withdraw": withdraw,
                "fee": if network_length.clone() <= Value::from(1) { fee.clone() } else { Value::Undefined },
                "name": Value::Undefined,
                "limits": Value::Json(normalize(&Value::Json(json!({
                    "amount": Value::Json(normalize(&Value::Json(json!({
                        "min": Value::Undefined,
                        "max": Value::Undefined
                    }))).unwrap()),
                    "withdraw": Value::Json(normalize(&Value::Json(json!({
                        "min": if network_length.clone() <= Value::from(1) { min_withdraw.clone() } else { Value::Undefined },
                        "max": if network_length.clone() <= Value::from(1) { max_withdraw.clone() } else { Value::Undefined }
                    }))).unwrap())
                }))).unwrap()),
                "precision": min_precision,
                "networks": networks
            }))).unwrap()));
            i += 1;
        };
        return result.clone();
    }

    /// Returns a [balance structure](https://docs.ccxt.com/en/latest/manual.html?#balance-structure)
    ///
    /// Query for balance and get the amount of funds available for trading or funds locked in orders
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut r#type: Value = Value::Undefined;
        (r#type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchBalance"), Value::Undefined, params.clone()));
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchBalance"), Value::new_object());
        let mut request: Value = Value::new_object();
        let mut method: Value = Value::Undefined;
        let mut margin: Value = (r#type.clone() == Value::from("margin")).into();
        let mut spot: Value = (r#type.clone() == Value::from("spot")).into();
        let mut future: Value = (r#type.clone() == Value::from("future")).into();
        let mut swap: Value = (r#type.clone() == Value::from("swap")).into();
        let mut default_sub_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
        let mut sub_type: Value = self.safe_string_2(options.clone(), Value::from("defaultSubType"), Value::from("subType"), default_sub_type.clone());
        sub_type = self.safe_string_2(params.clone(), Value::from("defaultSubType"), Value::from("subType"), sub_type.clone());
        let mut inverse: Value = (sub_type.clone() == Value::from("inverse")).into();
        let mut linear: Value = (sub_type.clone() == Value::from("linear")).into();
        let mut margin_mode: Value = Value::Undefined;
        (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("fetchBalance"), params.clone()));
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        let mut isolated: Value = (margin_mode.clone() == Value::from("isolated")).into();
        let mut cross: Value = (margin_mode.clone() == Value::from("cross")).into();
        if spot.is_truthy() {
            if isolated.is_truthy() {
                method = Value::from("spotPrivateGetV1MarginAccountsBalance");
            } else if cross.is_truthy() {
                method = Value::from("spotPrivateGetV1CrossMarginAccountsBalance");
            } else {
                Huobi::load_accounts(self, Value::Undefined, Value::Undefined).await;
                let mut account_id: Value = Huobi::fetch_account_id_by_type(self, r#type.clone(), params.clone()).await;
                request.set("account-id".into(), account_id.clone());
                method = Value::from("spotPrivateGetV1AccountAccountsAccountIdBalance");
            };
        } else if margin.is_truthy() {
            if isolated.is_truthy() {
                method = Value::from("spotPrivateGetV1MarginAccountsBalance");
            } else {
                method = Value::from("spotPrivateGetV1CrossMarginAccountsBalance");
            };
        } else if linear.is_truthy() {
            if isolated.is_truthy() {
                method = Value::from("contractPrivatePostLinearSwapApiV1SwapAccountInfo");
            } else {
                method = Value::from("contractPrivatePostLinearSwapApiV1SwapCrossAccountInfo");
            };
        } else if inverse.is_truthy() {
            if future.is_truthy() {
                method = Value::from("contractPrivatePostApiV1ContractAccountInfo");
            } else if swap.is_truthy() {
                method = Value::from("contractPrivatePostSwapApiV1SwapAccountInfo");
            };
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "id": 1528640,
        //             "type": "spot",
        //             "state": "working",
        //             "list": [
        //                 { "currency": "lun", "type": "trade", "balance": "0", "seq-num": "0" },
        //                 { "currency": "lun", "type": "frozen", "balance": "0", "seq-num": "0" },
        //                 { "currency": "ht", "type": "frozen", "balance": "0", "seq-num": "145" },
        //             ]
        //         },
        //         "ts":1637644827566
        //     }
        //
        // cross margin
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "id": 51015302,
        //             "type": "cross-margin",
        //             "state": "working",
        //             "risk-rate": "2",
        //             "acct-balance-sum": "100",
        //             "debt-balance-sum": "0",
        //             "list": [
        //                 { "currency": "usdt", "type": "trade", "balance": "100" },
        //                 { "currency": "usdt", "type": "frozen", "balance": "0" },
        //                 { "currency": "usdt", "type": "loan-available", "balance": "200" },
        //                 { "currency": "usdt", "type": "transfer-out-available", "balance": "-1" },
        //                 { "currency": "ht", "type": "loan-available", "balance": "36.60724091" },
        //                 { "currency": "ht", "type": "transfer-out-available", "balance": "-1" },
        //                 { "currency": "btc", "type": "trade", "balance": "1168.533000000000000000" },
        //                 { "currency": "btc", "type": "frozen", "balance": "0.000000000000000000" },
        //                 { "currency": "btc", "type": "loan", "balance": "-2.433000000000000000" },
        //                 { "currency": "btc", "type": "interest", "balance": "-0.000533000000000000" },
        //                 { "currency": "btc", "type": "transfer-out-available", "balance": "1163.872174670000000000" },
        //                 { "currency": "btc", "type": "loan-available", "balance": "8161.876538350676000000" }
        //             ]
        //         },
        //         "code": 200
        //     }
        //
        // isolated margin
        //
        //     {
        //         "data": [
        //             {
        //                 "id": 18264,
        //                 "type": "margin",
        //                 "state": "working",
        //                 "symbol": "btcusdt",
        //                 "fl-price": "0",
        //                 "fl-type": "safe",
        //                 "risk-rate": "475.952571086994250554",
        //                 "list": [
        //                     { "currency": "btc","type": "trade","balance": "1168.533000000000000000" },
        //                     { "currency": "btc","type": "frozen","balance": "0.000000000000000000" },
        //                     { "currency": "btc","type": "loan","balance": "-2.433000000000000000" },
        //                     { "currency": "btc","type": "interest","balance": "-0.000533000000000000" },
        //                     { "currency": "btc","type": "transfer-out-available", "balance": "1163.872174670000000000" },
        //                     { "currency": "btc","type": "loan-available", "balance": "8161.876538350676000000" }
        //                 ]
        //             }
        //         ]
        //     }
        //
        // future, swap isolated
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "symbol": "BTC",
        //                 "margin_balance": 0,
        //                 "margin_position": 0E-18,
        //                 "margin_frozen": 0,
        //                 "margin_available": 0E-18,
        //                 "profit_real": 0,
        //                 "profit_unreal": 0,
        //                 "risk_rate": null,
        //                 "withdraw_available": 0,
        //                 "liquidation_price": null,
        //                 "lever_rate": 5,
        //                 "adjust_factor": 0.025000000000000000,
        //                 "margin_static": 0,
        //                 "is_debit": 0, // future only
        //                 "contract_code": "BTC-USD", // swap only
        //                 "margin_asset": "USDT", // linear only
        //                 "margin_mode": "isolated", // linear only
        //                 "margin_account": "BTC-USDT" // linear only
        //                 "transfer_profit_ratio": null // inverse only
        //             },
        //         ],
        //         "ts": 1637644827566
        //     }
        //
        // linear cross futures and linear cross swap
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "futures_contract_detail": [
        //                     {
        //                         "symbol": "ETH",
        //                         "contract_code": "ETH-USDT-220325",
        //                         "margin_position": 0,
        //                         "margin_frozen": 0,
        //                         "margin_available": 200.000000000000000000,
        //                         "profit_unreal": 0E-18,
        //                         "liquidation_price": null,
        //                         "lever_rate": 5,
        //                         "adjust_factor": 0.060000000000000000,
        //                         "contract_type": "quarter",
        //                         "pair": "ETH-USDT",
        //                         "business_type": "futures"
        //                     },
        //                 ],
        //                 "margin_mode": "cross",
        //                 "margin_account": "USDT",
        //                 "margin_asset": "USDT",
        //                 "margin_balance": 200.000000000000000000,
        //                 "margin_static": 200.000000000000000000,
        //                 "margin_position": 0,
        //                 "margin_frozen": 0,
        //                 "profit_real": 0E-18,
        //                 "profit_unreal": 0,
        //                 "withdraw_available": 2E+2,
        //                 "risk_rate": null,
        //                 "contract_detail": [
        //                     {
        //                         "symbol": "MANA",
        //                         "contract_code": "MANA-USDT",
        //                         "margin_position": 0,
        //                         "margin_frozen": 0,
        //                         "margin_available": 200.000000000000000000,
        //                         "profit_unreal": 0E-18,
        //                         "liquidation_price": null,
        //                         "lever_rate": 5,
        //                         "adjust_factor": 0.100000000000000000,
        //                         "contract_type": "swap",
        //                         "pair": "MANA-USDT",
        //                         "business_type": "swap"
        //                     },
        //                 ]
        //             }
        //         ],
        //         "ts": 1640915104870
        //     }
        //
        // TODO add balance parsing for linear swap
        //
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        if spot.is_truthy() || margin.is_truthy() {
            if isolated.is_truthy() {
                let mut i: usize = 0;
                while i < data.len() {
                    let mut entry: Value = data.get(i.into());
                    let mut symbol: Value = Huobi::safe_symbol(self, self.safe_string(entry.clone(), Value::from("symbol"), Value::Undefined), Value::Undefined, Value::Undefined);
                    let mut balances: Value = self.safe_value(entry.clone(), Value::from("list"), Value::Undefined);
                    let mut sub_result: Value = Value::new_object();
                    let mut i: usize = 0;
                    while i < balances.len() {
                        let mut balance: Value = balances.get(i.into());
                        let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("currency"), Value::Undefined);
                        let mut code: Value = Huobi::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                        sub_result.set(code.clone(), Huobi::parse_margin_balance_helper(self, balance.clone(), code.clone(), sub_result.clone()));
                        i += 1;
                    };
                    result.set(symbol.clone(), Huobi::safe_balance(self, sub_result.clone()));
                    i += 1;
                };
            } else {
                let mut balances: Value = self.safe_value(data.clone(), Value::from("list"), Value::new_array());
                let mut i: usize = 0;
                while i < balances.len() {
                    let mut balance: Value = balances.get(i.into());
                    let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("currency"), Value::Undefined);
                    let mut code: Value = Huobi::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                    result.set(code.clone(), Huobi::parse_margin_balance_helper(self, balance.clone(), code.clone(), result.clone()));
                    i += 1;
                };
            };
        } else if linear.is_truthy() {
            let mut first: Value = self.safe_value(data.clone(), Value::from(0), Value::new_object());
            if cross.is_truthy() {
                let mut account: Value = Huobi::account(self);
                account.set("free".into(), self.safe_string(first.clone(), Value::from("margin_balance"), Value::from("margin_available")));
                account.set("used".into(), self.safe_string(first.clone(), Value::from("margin_frozen"), Value::Undefined));
                let mut currency_id: Value = self.safe_string_2(first.clone(), Value::from("margin_asset"), Value::from("symbol"), Value::Undefined);
                let mut code: Value = Huobi::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                result.set(code.clone(), account.clone());
            } else if isolated.is_truthy() {
                let mut i: usize = 0;
                while i < data.len() {
                    let mut balance: Value = data.get(i.into());
                    let mut market_id: Value = self.safe_string_2(balance.clone(), Value::from("contract_code"), Value::from("margin_account"), Value::Undefined);
                    let mut market: Value = Huobi::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                    let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("margin_asset"), Value::Undefined);
                    let mut currency: Value = Huobi::safe_currency(self, currency_id.clone(), Value::Undefined);
                    let mut code: Value = self.safe_string(market.clone(), Value::from("settle"), currency.get(Value::from("code")));
                    // the exchange outputs positions for delisted markets
                    // https://www.huobi.com/support/en-us/detail/74882968522337
                    // we skip it if the market was delisted
                    if code.clone().is_nonnullish() {
                        let mut account: Value = Huobi::account(self);
                        account.set("free".into(), self.safe_string(balance.clone(), Value::from("margin_balance"), Value::Undefined));
                        account.set("used".into(), self.safe_string(balance.clone(), Value::from("margin_frozen"), Value::Undefined));
                        let mut accounts_by_code: Value = Value::new_object();
                        accounts_by_code.set(code.clone(), account.clone());
                        let mut symbol: Value = market.get(Value::from("symbol"));
                        result.set(symbol.clone(), Huobi::safe_balance(self, accounts_by_code.clone()));
                    };
                    i += 1;
                };
                return result.clone();
            };
        } else if inverse.is_truthy() {
            let mut i: usize = 0;
            while i < data.len() {
                let mut balance: Value = data.get(i.into());
                let mut currency_id: Value = self.safe_string(balance.clone(), Value::from("symbol"), Value::Undefined);
                let mut code: Value = Huobi::safe_currency_code(self, currency_id.clone(), Value::Undefined);
                let mut account: Value = Huobi::account(self);
                account.set("free".into(), self.safe_string(balance.clone(), Value::from("margin_available"), Value::Undefined));
                account.set("used".into(), self.safe_string(balance.clone(), Value::from("margin_frozen"), Value::Undefined));
                result.set(code.clone(), account.clone());
                i += 1;
            };
        };
        let mut isolated_margin: Value = (isolated.is_truthy() && spot.is_truthy() || margin.is_truthy()).into();
        return if isolated_margin.is_truthy() { result.clone() } else { Huobi::safe_balance(self, result.clone()) };
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on an order made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Huobi::market(self, symbol.clone());
        };
        let mut market_type: Value = Value::Undefined;
        (market_type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchOrder"), market.clone(), params.clone()));
        let mut request: Value = Value::new_object();
        // spot -----------------------------------------------------------
        // 'order-id': 'id',
        // 'symbol': market['id'],
        // 'client-order-id': clientOrderId,
        // 'clientOrderId': clientOrderId,
        // contracts ------------------------------------------------------
        // 'order_id': id,
        // 'client_order_id': clientOrderId,
        // 'contract_code': market['id'],
        // 'pair': 'BTC-USDT',
        // 'contract_type': 'this_week', // swap, this_week, next_week, quarter, next_ quarter
        let mut method: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            let mut client_order_id: Value = self.safe_string(params.clone(), Value::from("clientOrderId"), Value::Undefined);
            method = Value::from("spotPrivateGetV1OrderOrdersOrderId");
            if client_order_id.clone().is_nonnullish() {
                method = Value::from("spotPrivateGetV1OrderOrdersGetClientOrder");
            } else {
                // will be filled below in extend ()
                // they expect clientOrderId instead of client-order-id
                // request['clientOrderId'] = clientOrderId;
                request.set("order-id".into(), id.clone());
            };
        } else {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrder() requires a symbol for ") + market_type.clone() + Value::from(" orders"))"###);
            };
            request.set("contract_code".into(), market.get(Value::from("id")));
            if market.get(Value::from("linear")).is_truthy() {
                let mut margin_mode: Value = Value::Undefined;
                (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("fetchOrder"), params.clone()));
                margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
                if margin_mode.clone() == Value::from("isolated") {
                    method = Value::from("contractPrivatePostLinearSwapApiV1SwapOrderInfo");
                } else if margin_mode.clone() == Value::from("cross") {
                    method = Value::from("contractPrivatePostLinearSwapApiV1SwapCrossOrderInfo");
                };
            } else if market.get(Value::from("inverse")).is_truthy() {
                if market_type.clone() == Value::from("future") {
                    method = Value::from("contractPrivatePostApiV1ContractOrderInfo");
                    request.set("symbol".into(), market.get(Value::from("settleId")));
                } else if market_type.clone() == Value::from("swap") {
                    method = Value::from("contractPrivatePostSwapApiV1SwapOrderInfo");
                } else {
                    panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrder() does not support ") + market_type.clone() + Value::from(" markets"))"###);
                };
            };
            let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("client_order_id"), Value::from("clientOrderId"), Value::Undefined);
            if client_order_id.clone().is_nullish() {
                request.set("order_id".into(), id.clone());
            } else {
                request.set("client_order_id".into(), client_order_id.clone());
                params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("client_order_id").into(), Value::from("clientOrderId").into()])));
            };
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "status":"ok",
        //         "data":{
        //             "id":438398393065481,
        //             "symbol":"ethusdt",
        //             "account-id":1528640,
        //             "client-order-id":"AA03022abc2163433e-006b-480e-9ad1-d4781478c5e7",
        //             "amount":"0.100000000000000000",
        //             "price":"3000.000000000000000000",
        //             "created-at":1640549994642,
        //             "type":"buy-limit",
        //             "field-amount":"0.0",
        //             "field-cash-amount":"0.0",
        //             "field-fees":"0.0",
        //             "finished-at":0,
        //             "source":"spot-api",
        //             "state":"submitted",
        //             "canceled-at":0
        //         }
        //     }
        //
        // linear swap cross margin
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "business_type":"swap",
        //                 "contract_type":"swap",
        //                 "pair":"BTC-USDT",
        //                 "symbol":"BTC",
        //                 "contract_code":"BTC-USDT",
        //                 "volume":1,
        //                 "price":3000,
        //                 "order_price_type":"limit",
        //                 "order_type":1,
        //                 "direction":"buy",
        //                 "offset":"open",
        //                 "lever_rate":1,
        //                 "order_id":924912513206878210,
        //                 "client_order_id":null,
        //                 "created_at":1640557927189,
        //                 "trade_volume":0,
        //                 "trade_turnover":0,
        //                 "fee":0,
        //                 "trade_avg_price":null,
        //                 "margin_frozen":3.000000000000000000,
        //                 "profit":0,
        //                 "status":3,
        //                 "order_source":"api",
        //                 "order_id_str":"924912513206878210",
        //                 "fee_asset":"USDT",
        //                 "liquidation_type":"0",
        //                 "canceled_at":0,
        //                 "margin_asset":"USDT",
        //                 "margin_account":"USDT",
        //                 "margin_mode":"cross",
        //                 "is_tpsl":0,
        //                 "real_profit":0
        //             }
        //         ],
        //         "ts":1640557982556
        //     }
        //
        // linear swap isolated margin detail
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "symbol": "BTC",
        //             "contract_code": "BTC-USDT",
        //             "instrument_price": 0,
        //             "final_interest": 0,
        //             "adjust_value": 0,
        //             "lever_rate": 10,
        //             "direction": "sell",
        //             "offset": "open",
        //             "volume": 1.000000000000000000,
        //             "price": 13059.800000000000000000,
        //             "created_at": 1603703614712,
        //             "canceled_at": 0,
        //             "order_source": "api",
        //             "order_price_type": "opponent",
        //             "margin_frozen": 0,
        //             "profit": 0,
        //             "trades": [
        //                 {
        //                     "trade_id": 131560927,
        //                     "trade_price": 13059.800000000000000000,
        //                     "trade_volume": 1.000000000000000000,
        //                     "trade_turnover": 13.059800000000000000,
        //                     "trade_fee": -0.005223920000000000,
        //                     "created_at": 1603703614715,
        //                     "role": "taker",
        //                     "fee_asset": "USDT",
        //                     "profit": 0,
        //                     "real_profit": 0,
        //                     "id": "131560927-770334322963152896-1"
        //                 }
        //             ],
        //             "total_page": 1,
        //             "current_page": 1,
        //             "total_size": 1,
        //             "liquidation_type": "0",
        //             "fee_asset": "USDT",
        //             "fee": -0.005223920000000000,
        //             "order_id": 770334322963152896,
        //             "order_id_str": "770334322963152896",
        //             "client_order_id": 57012021045,
        //             "order_type": "1",
        //             "status": 6,
        //             "trade_avg_price": 13059.800000000000000000,
        //             "trade_turnover": 13.059800000000000000,
        //             "trade_volume": 1.000000000000000000,
        //             "margin_asset": "USDT",
        //             "margin_mode": "isolated",
        //             "margin_account": "BTC-USDT",
        //             "real_profit": 0,
        //             "is_tpsl": 0
        //         },
        //         "ts": 1603703678477
        //     }
        let mut order: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        if Array::is_array(order.clone()).is_truthy() {
            order = self.safe_value(order.clone(), Value::from(0), Value::Undefined);
        };
        return Huobi::parse_order(self, order.clone(), Value::Undefined);
    }

    fn parse_margin_balance_helper(&self, mut balance: Value, mut code: Value, mut result: Value) -> Value {
        let mut account: Value = Value::Undefined;
        if result.contains_key(code.clone()) {
            account = result.get(code.clone());
        } else {
            account = Huobi::account(self);
        };
        if balance.get(Value::from("type")) == Value::from("trade") {
            account.set("free".into(), self.safe_string(balance.clone(), Value::from("balance"), Value::Undefined));
        };
        if balance.get(Value::from("type")) == Value::from("frozen") {
            account.set("used".into(), self.safe_string(balance.clone(), Value::from("balance"), Value::Undefined));
        };
        return account.clone();
    }

    async fn fetch_spot_orders_by_states(&mut self, mut states: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut method: Value = self.safe_string(self.get("options".into()), Value::from("fetchOrdersByStatesMethod"), Value::from("spot_private_get_v1_order_orders"));
        // spot_private_get_v1_order_history
        if method.clone() == Value::from("spot_private_get_v1_order_orders") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrders() requires a symbol argument"))"###);
            };
        };
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "states": states
        }))).unwrap());
        // spot_private_get_v1_order_orders GET /v1/order/orders ----------
        // 'symbol': market['id'], // required
        // 'types': 'buy-market,sell-market,buy-limit,sell-limit,buy-ioc,sell-ioc,buy-stop-limit,sell-stop-limit,buy-limit-fok,sell-limit-fok,buy-stop-limit-fok,sell-stop-limit-fok',
        // 'start-time': since, // max window of 48h within a range of 180 days, within past 2 hours for cancelled orders
        // 'end-time': this.milliseconds (),
        // filled, partial-canceled, canceled
        // 'from': order['id'],
        // 'direct': 'next', // next, prev, used with from
        // 'size': 100, // max 100
        // spot_private_get_v1_order_history GET /v1/order/history --------
        // 'symbol': market['id'], // optional
        // 'start-time': since, // max window of 48h within a range of 180 days, within past 2 hours for cancelled orders
        // 'end-time': this.milliseconds (),
        // 'direct': 'next', // next, prev, used with from
        // 'size': 100, // max 100
        if symbol.clone().is_nonnullish() {
            market = Huobi::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("start-time".into(), since.clone());
            // a window of 48 hours within 180 days
            request.set("end-time".into(), self.sum(since.clone(), Value::from(48) * Value::from(60) * Value::from(60) * Value::from(1000)));
        };
        if limit.clone().is_nonnullish() {
            request.set("size".into(), limit.clone());
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot_private_get_v1_order_orders GET /v1/order/orders
        //
        //     {
        //         status: "ok",
        //         data: [
        //             {
        //                 id: 13997833014,
        //                 symbol: "ethbtc",
        //                 'account-id': 3398321,
        //                 'client-order-id': "23456",
        //                 amount: "0.045000000000000000",
        //                 price: "0.034014000000000000",
        //                 'created-at': 1545836976871,
        //                 type: "sell-limit",
        //                 'field-amount': "0.045000000000000000",
        //                 'field-cash-amount': "0.001530630000000000",
        //                 'field-fees': "0.000003061260000000",
        //                 'finished-at': 1545837948214,
        //                 source: "spot-api",
        //                 state: "filled",
        //                 'canceled-at': 0
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Huobi::parse_orders(self, data.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    async fn fetch_spot_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::fetch_spot_orders_by_states(self, Value::from("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled"), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
    }

    async fn fetch_closed_spot_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::fetch_spot_orders_by_states(self, Value::from("filled,partial-canceled,canceled"), symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
    }

    async fn fetch_contract_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchContractOrders() requires a symbol argument"))"###);
        };
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let mut market_type: Value = Value::Undefined;
        (market_type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchOrders"), market.clone(), params.clone()));
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "contract_code": market.get(Value::from("id")),
            "trade_type": 0,
            "type": 1,
            "status": "0",
            "create_date": 90
        }))).unwrap());
        // POST /api/v1/contract_hisorders inverse futures ----------------
        // 'symbol': market['settleId'], // BTC, ETH, ...
        // 'order_type': '1', // 1 limit3 opponent4 lightning, 5 trigger order, 6 pst_only, 7 optimal_5, 8 optimal_10, 9 optimal_20, 10 fok, 11 ioc
        // POST /swap-api/v1/swap_hisorders inverse swap ------------------
        // POST /linear-swap-api/v1/swap_hisorders linear isolated --------
        // POST /linear-swap-api/v1/swap_cross_hisorders linear cross -----
        // 0 all, 1 buy long, 2 sell short, 3 buy short, 4 sell long, 5 sell liquidation, 6 buy liquidation, 7 Delivery long, 8 Delivery short 11 reduce positions to close long, 12 reduce positions to close short
        // 1 all orders, 2 finished orders
        // comma separated, 0 all, 3 submitted orders, 4 partially matched, 5 partially cancelled, 6 fully matched and closed, 7 canceled
        // in days?
        // 'page_index': 1,
        // 'page_size': limit, // default 20, max 50
        // 'sort_by': 'create_date', // create_date descending, update_time descending
        let mut method: Value = Value::Undefined;
        request.set("contract_code".into(), market.get(Value::from("id")));
        if market.get(Value::from("linear")).is_truthy() {
            let mut margin_mode: Value = Value::Undefined;
            (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("fetchContractOrders"), params.clone()));
            margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
            method = Huobi::get_supported_mapping(self, margin_mode.clone(), Value::Json(normalize(&Value::Json(json!({
                "isolated": "contractPrivatePostLinearSwapApiV1SwapHisorders",
                "cross": "contractPrivatePostLinearSwapApiV1SwapCrossHisorders"
            }))).unwrap()));
        } else if market.get(Value::from("inverse")).is_truthy() {
            method = Huobi::get_supported_mapping(self, market_type.clone(), Value::Json(normalize(&Value::Json(json!({
                "future": "contractPrivatePostApiV1ContractHisorders",
                "swap": "contractPrivatePostSwapApiV1SwapHisorders"
            }))).unwrap()));
            if market_type.clone() == Value::from("future") {
                request.set("symbol".into(), market.get(Value::from("settleId")));
            };
        };
        if limit.clone().is_nonnullish() {
            request.set("page_size".into(), limit.clone());
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "order_id": 773131315209248768,
        //                     "contract_code": "ADA201225",
        //                     "symbol": "ADA",
        //                     "lever_rate": 20,
        //                     "direction": "buy",
        //                     "offset": "close",
        //                     "volume": 1,
        //                     "price": 0.0925,
        //                     "create_date": 1604370469629,
        //                     "update_time": 1603704221118,
        //                     "order_source": "web",
        //                     "order_price_type": 6,
        //                     "order_type": 1,
        //                     "margin_frozen": 0,
        //                     "profit": 0,
        //                     "contract_type": "quarter",
        //                     "trade_volume": 0,
        //                     "trade_turnover": 0,
        //                     "fee": 0,
        //                     "trade_avg_price": 0,
        //                     "status": 3,
        //                     "order_id_str": "773131315209248768",
        //                     "fee_asset": "ADA",
        //                     "liquidation_type": "0",
        //                     "is_tpsl": 0,
        //                     "real_profit": 0
        //                     "margin_asset": "USDT",
        //                     "margin_mode": "cross",
        //                     "margin_account": "USDT",
        //                     "trade_partition": "USDT", // only in isolated & cross of linear
        //                     "reduce_only": "1", // only in isolated & cross of linear
        //                     "contract_type": "quarter", // only in cross-margin (inverse & linear)
        //                     "pair": "BTC-USDT", // only in cross-margin (inverse & linear)
        //                     "business_type": "futures" // only in cross-margin (inverse & linear)
        //                 }
        //             ],
        //             "total_page": 19,
        //             "current_page": 1,
        //             "total_size": 19
        //         },
        //         "ts": 1604370617322
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut orders: Value = self.safe_value(data.clone(), Value::from("orders"), Value::new_array());
        return Huobi::parse_orders(self, orders.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    async fn fetch_closed_contract_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "status": "5,6,7"
        }))).unwrap());
        // comma separated, 0 all, 3 submitted orders, 4 partially matched, 5 partially cancelled, 6 fully matched and closed, 7 canceled
        return Huobi::fetch_contract_orders(self, symbol.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Huobi::market(self, symbol.clone());
        };
        let mut market_type: Value = Value::Undefined;
        (market_type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchOrders"), market.clone(), params.clone()));
        let mut method: Value = Huobi::get_supported_mapping(self, market_type.clone(), Value::Json(normalize(&Value::Json(json!({
            "spot": "fetchSpotOrders",
            "swap": "fetchContractOrders",
            "future": "fetchContractOrders"
        }))).unwrap()));
        if method.clone().is_nullish() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOrders() does not support ") + market_type.clone() + Value::from(" markets yet"))"###);
        };
        let mut contract: Value = (market_type.clone() == Value::from("swap") || market_type.clone() == Value::from("future")).into();
        if contract.is_truthy() && symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOrders() requires a symbol argument for ") + market_type.clone() + Value::from(" orders"))"###);
        };
        return Huobi::dispatch(self, method, symbol.clone(), since.clone()).await;
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetches information on multiple closed orders made by the user
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol of the market orders were made in
    /// * `since` {int|undefined} - the earliest time in ms to fetch orders for
    /// * `limit` {int|undefined} - the maximum number of  orde structures to retrieve
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_closed_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Huobi::market(self, symbol.clone());
        };
        let mut market_type: Value = Value::Undefined;
        (market_type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchClosedOrders"), market.clone(), params.clone()));
        let mut method: Value = Huobi::get_supported_mapping(self, market_type.clone(), Value::Json(normalize(&Value::Json(json!({
            "spot": "fetchClosedSpotOrders",
            "swap": "fetchClosedContractOrders",
            "future": "fetchClosedContractOrders"
        }))).unwrap()));
        if method.clone().is_nullish() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchClosedOrders() does not support ") + market_type.clone() + Value::from(" markets yet"))"###);
        };
        return Huobi::dispatch(self, method, symbol.clone(), since.clone()).await;
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Fetch all unfilled currently open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch open orders for
    /// * `limit` {int|undefined} - the maximum number of  open orders structures to retrieve
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_open_orders(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Huobi::market(self, symbol.clone());
        };
        let mut market_type: Value = Value::Undefined;
        (market_type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchOpenOrders"), market.clone(), params.clone()));
        let mut request: Value = Value::new_object();
        // spot -----------------------------------------------------------
        // 'account-id': account['id'],
        // 'symbol': market['id'],
        // 'side': 'buy', // buy, sell
        // 'from': 'id', // order id to begin with
        // 'direct': 'prev', // prev, next, mandatory if from is defined
        // 'size': 100, // default 100, max 500
        // futures --------------------------------------------------------
        // 'symbol': market['settleId'],
        // 'page_index': 1, // default 1
        // 'page_size': limit, // default 20, max 50
        // 'sort_by': 'created_at', // created_at, update_time, descending sorting field
        // 'trade_type': 0, // 0 all, 1 buy long, 2 sell short, 3 buy short, 4 sell long
        let mut method: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            method = Value::from("spotPrivateGetV1OrderOpenOrders");
            if symbol.clone().is_nonnullish() {
                market = Huobi::market(self, symbol.clone());
                request.set("symbol".into(), market.get(Value::from("id")));
            };
            // todo replace with fetchAccountIdByType
            let mut account_id: Value = self.safe_string(params.clone(), Value::from("account-id"), Value::Undefined);
            if account_id.clone().is_nullish() {
                // pick the first account
                Huobi::load_accounts(self, Value::Undefined, Value::Undefined).await;
                let mut i: usize = 0;
                while i < self.get("accounts".into()).len() {
                    let mut account: Value = self.get("accounts".into()).get(i.into());
                    if account.get(Value::from("type")) == Value::from("spot") {
                        account_id = self.safe_string(account.clone(), Value::from("id"), Value::Undefined);
                        if account_id.clone().is_nonnullish() {
                            break;
                        };
                    };
                    i += 1;
                };
            };
            request.set("account-id".into(), account_id.clone());
            if limit.clone().is_nonnullish() {
                request.set("size".into(), limit.clone());
            };
            params = self.omit(params.clone(), Value::from("account-id"));
        } else {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOpenOrders() requires a symbol for ") + market_type.clone() + Value::from(" orders"))"###);
            };
            let mut market: Value = Huobi::market(self, symbol.clone());
            request.set("contract_code".into(), market.get(Value::from("id")));
            if market.get(Value::from("linear")).is_truthy() {
                let mut margin_mode: Value = Value::Undefined;
                (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("fetchOpenOrders"), params.clone()));
                margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
                if margin_mode.clone() == Value::from("isolated") {
                    method = Value::from("contractPrivatePostLinearSwapApiV1SwapOpenorders");
                } else if margin_mode.clone() == Value::from("cross") {
                    method = Value::from("contractPrivatePostLinearSwapApiV1SwapCrossOpenorders");
                };
            } else if market.get(Value::from("inverse")).is_truthy() {
                if market.get(Value::from("future")).is_truthy() {
                    method = Value::from("contractPrivatePostApiV1ContractOpenorders");
                    request.set("symbol".into(), market.get(Value::from("settleId")));
                } else if market.get(Value::from("swap")).is_truthy() {
                    method = Value::from("contractPrivatePostSwapApiV1SwapOpenorders");
                };
            };
            if limit.clone().is_nonnullish() {
                request.set("page_size".into(), limit.clone());
            };
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "status":"ok",
        //         "data":[
        //             {
        //                 "symbol":"ethusdt",
        //                 "source":"api",
        //                 "amount":"0.010000000000000000",
        //                 "account-id":1528640,
        //                 "created-at":1561597491963,
        //                 "price":"400.000000000000000000",
        //                 "filled-amount":"0.0",
        //                 "filled-cash-amount":"0.0",
        //                 "filled-fees":"0.0",
        //                 "id":38477101630,
        //                 "state":"submitted",
        //                 "type":"sell-limit"
        //             }
        //         ]
        //     }
        //
        // futures
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "orders": [
        //                 {
        //                     "symbol": "ADA",
        //                     "contract_code": "ADA201225",
        //                     "contract_type": "quarter",
        //                     "volume": 1,
        //                     "price": 0.0925,
        //                     "order_price_type": "post_only",
        //                     "order_type": 1,
        //                     "direction": "buy",
        //                     "offset": "close",
        //                     "lever_rate": 20,
        //                     "order_id": 773131315209248768,
        //                     "client_order_id": null,
        //                     "created_at": 1604370469629,
        //                     "trade_volume": 0,
        //                     "trade_turnover": 0,
        //                     "fee": 0,
        //                     "trade_avg_price": null,
        //                     "margin_frozen": 0,
        //                     "profit": 0,
        //                     "status": 3,
        //                     "order_source": "web",
        //                     "order_id_str": "773131315209248768",
        //                     "fee_asset": "ADA",
        //                     "liquidation_type": null,
        //                     "canceled_at": null,
        //                     "is_tpsl": 0,
        //                     "update_time": 1606975980467,
        //                     "real_profit": 0
        //                 }
        //             ],
        //             "total_page": 1,
        //             "current_page": 1,
        //             "total_size": 1
        //         },
        //         "ts": 1604370488518
        //     }
        //
        let mut orders: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        if !Array::is_array(orders.clone()).is_truthy() {
            orders = self.safe_value(orders.clone(), Value::from("orders"), Value::new_array());
        };
        return Huobi::parse_orders(self, orders.clone(), market.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_order_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "partial-filled": "open",
            "partial-canceled": "canceled",
            "filled": "closed",
            "canceled": "canceled",
            "submitted": "open",
            "created": "open",
            "1": "open",
            "2": "open",
            "3": "open",
            "4": "open",
            "5": "canceled",
            "6": "closed",
            "7": "canceled",
            "11": "canceling"
        }))).unwrap());
        // spot
        // For stop orders
        // contract
        // partially matched
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    fn parse_order(&mut self, mut order: Value, mut market: Value) -> Value {
        //
        // spot
        //
        //     {
        //         id:  13997833014,
        //         symbol: "ethbtc",
        //         'account-id':  3398321,
        //         amount: "0.045000000000000000",
        //         price: "0.034014000000000000",
        //         'created-at':  1545836976871,
        //         type: "sell-limit",
        //         'field-amount': "0.045000000000000000", // they have fixed it for filled-amount
        //         'field-cash-amount': "0.001530630000000000", // they have fixed it for filled-cash-amount
        //         'field-fees': "0.000003061260000000", // they have fixed it for filled-fees
        //         'finished-at':  1545837948214,
        //         source: "spot-api",
        //         state: "filled",
        //         'canceled-at':  0
        //     }
        //
        //     {
        //         id:  20395337822,
        //         symbol: "ethbtc",
        //         'account-id':  5685075,
        //         amount: "0.001000000000000000",
        //         price: "0.0",
        //         'created-at':  1545831584023,
        //         type: "buy-market",
        //         'field-amount': "0.029100000000000000", // they have fixed it for filled-amount
        //         'field-cash-amount': "0.000999788700000000", // they have fixed it for filled-cash-amount
        //         'field-fees': "0.000058200000000000", // they have fixed it for filled-fees
        //         'finished-at':  1545831584181,
        //         source: "spot-api",
        //         state: "filled",
        //         'canceled-at':  0
        //     }
        //
        // linear swap cross margin createOrder
        //
        //     {
        //         "order_id":924660854912552960,
        //         "order_id_str":"924660854912552960"
        //     }
        //
        // contracts fetchOrder
        //
        //     {
        //         "business_type":"swap",
        //         "contract_type":"swap",
        //         "pair":"BTC-USDT",
        //         "symbol":"BTC",
        //         "contract_code":"BTC-USDT",
        //         "volume":1,
        //         "price":3000,
        //         "order_price_type":"limit",
        //         "order_type":1,
        //         "direction":"buy",
        //         "offset":"open",
        //         "lever_rate":1,
        //         "order_id":924912513206878210,
        //         "client_order_id":null,
        //         "created_at":1640557927189,
        //         "trade_volume":0,
        //         "trade_turnover":0,
        //         "fee":0,
        //         "trade_avg_price":null,
        //         "margin_frozen":3.000000000000000000,
        //         "profit":0,
        //         "status":3,
        //         "order_source":"api",
        //         "order_id_str":"924912513206878210",
        //         "fee_asset":"USDT",
        //         "liquidation_type":"0",
        //         "canceled_at":0,
        //         "margin_asset":"USDT",
        //         "margin_account":"USDT",
        //         "margin_mode":"cross",
        //         "is_tpsl":0,
        //         "real_profit":0
        //     }
        //
        // contracts fetchOrder detailed
        //
        //     {
        //         "symbol": "BTC",
        //         "contract_code": "BTC-USDT",
        //         "instrument_price": 0,
        //         "final_interest": 0,
        //         "adjust_value": 0,
        //         "lever_rate": 10,
        //         "direction": "sell",
        //         "offset": "open",
        //         "volume": 1.000000000000000000,
        //         "price": 13059.800000000000000000,
        //         "created_at": 1603703614712,
        //         "canceled_at": 0,
        //         "order_source": "api",
        //         "order_price_type": "opponent",
        //         "margin_frozen": 0,
        //         "profit": 0,
        //         "trades": [
        //             {
        //                 "trade_id": 131560927,
        //                 "trade_price": 13059.800000000000000000,
        //                 "trade_volume": 1.000000000000000000,
        //                 "trade_turnover": 13.059800000000000000,
        //                 "trade_fee": -0.005223920000000000,
        //                 "created_at": 1603703614715,
        //                 "role": "taker",
        //                 "fee_asset": "USDT",
        //                 "profit": 0,
        //                 "real_profit": 0,
        //                 "id": "131560927-770334322963152896-1"
        //             }
        //         ],
        //         "total_page": 1,
        //         "current_page": 1,
        //         "total_size": 1,
        //         "liquidation_type": "0",
        //         "fee_asset": "USDT",
        //         "fee": -0.005223920000000000,
        //         "order_id": 770334322963152896,
        //         "order_id_str": "770334322963152896",
        //         "client_order_id": 57012021045,
        //         "order_type": "1",
        //         "status": 6,
        //         "trade_avg_price": 13059.800000000000000000,
        //         "trade_turnover": 13.059800000000000000,
        //         "trade_volume": 1.000000000000000000,
        //         "margin_asset": "USDT",
        //         "margin_mode": "isolated",
        //         "margin_account": "BTC-USDT",
        //         "real_profit": 0,
        //         "is_tpsl": 0
        //     }
        //
        // fetchOrders
        //
        //     {
        //         "order_id": 773131315209248768,
        //         "contract_code": "ADA201225",
        //         "symbol": "ADA",
        //         "lever_rate": 20,
        //         "direction": "buy",
        //         "offset": "close",
        //         "volume": 1,
        //         "price": 0.0925,
        //         "create_date": 1604370469629,
        //         "update_time": 1603704221118,
        //         "order_source": "web",
        //         "order_price_type": 6,
        //         "order_type": 1,
        //         "margin_frozen": 0,
        //         "profit": 0,
        //         "contract_type": "quarter",
        //         "trade_volume": 0,
        //         "trade_turnover": 0,
        //         "fee": 0,
        //         "trade_avg_price": 0,
        //         "status": 3,
        //         "order_id_str": "773131315209248768",
        //         "fee_asset": "ADA",
        //         "liquidation_type": "0",
        //         "is_tpsl": 0,
        //         "real_profit": 0
        //         "margin_asset": "USDT",
        //         "margin_mode": "cross",
        //         "margin_account": "USDT",
        //         "trade_partition": "USDT", // only in isolated & cross of linear
        //         "reduce_only": "1", // only in isolated & cross of linear
        //         "contract_type": "quarter", // only in cross-margin (inverse & linear)
        //         "pair": "BTC-USDT", // only in cross-margin (inverse & linear)
        //         "business_type": "futures" // only in cross-margin (inverse & linear)
        //     }
        //
        let mut id: Value = self.safe_string_2(order.clone(), Value::from("id"), Value::from("order_id_str"), Value::Undefined);
        let mut side: Value = self.safe_string(order.clone(), Value::from("direction"), Value::Undefined);
        let mut r#type: Value = self.safe_string(order.clone(), Value::from("order_price_type"), Value::Undefined);
        if order.contains_key(Value::from("type")) {
            let mut order_type: Value = order.get(Value::from("type")).split(Value::from("-"));
            side = order_type.get(Value::from(0));
            r#type = order_type.get(Value::from(1));
        };
        let mut status: Value = Huobi::parse_order_status(self, self.safe_string_2(order.clone(), Value::from("state"), Value::from("status"), Value::Undefined));
        let mut market_id: Value = self.safe_string_2(order.clone(), Value::from("contract_code"), Value::from("symbol"), Value::Undefined);
        market = Huobi::safe_market(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut timestamp: Value = self.safe_integer_n(order.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("created_at").into(), Value::from("created-at").into(), Value::from("create_date").into()])), Value::Undefined);
        let mut client_order_id: Value = self.safe_string_2(order.clone(), Value::from("client_order_id"), Value::from("client-order-id"), Value::Undefined);
        let mut cost: Value = Value::Undefined;
        let mut amount: Value = Value::Undefined;
        if r#type.clone().is_nonnullish() && r#type.index_of(Value::from("market")) >= Value::from(0) {
            // for market orders amount is in quote currency, meaning it is the cost
            if side.clone() == Value::from("sell") {
                cost = self.safe_string(order.clone(), Value::from("field-cash-amount"), Value::Undefined);
            } else {
                cost = self.safe_string(order.clone(), Value::from("amount"), Value::Undefined);
            };
        } else {
            amount = self.safe_string_2(order.clone(), Value::from("volume"), Value::from("amount"), Value::Undefined);
            cost = self.safe_string_n(order.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("filled-cash-amount").into(), Value::from("field-cash-amount").into(), Value::from("trade_turnover").into()])), Value::Undefined);
        };
        // same typo
        let mut filled: Value = self.safe_string_n(order.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("filled-amount").into(), Value::from("field-amount").into(), Value::from("trade_volume").into()])), Value::Undefined);
        // typo in their API, filled amount
        let mut price: Value = self.safe_string(order.clone(), Value::from("price"), Value::Undefined);
        let mut fee_cost: Value = self.safe_string_2(order.clone(), Value::from("filled-fees"), Value::from("field-fees"), Value::Undefined);
        // typo in their API, filled feeSide
        fee_cost = self.safe_string(order.clone(), Value::from("fee"), fee_cost.clone());
        let mut fee: Value = Value::Undefined;
        if fee_cost.clone().is_nonnullish() {
            let mut fee_currency: Value = Value::Undefined;
            let mut fee_currency_id: Value = self.safe_string(order.clone(), Value::from("fee_asset"), Value::Undefined);
            if fee_currency_id.clone().is_nonnullish() {
                fee_currency = Huobi::safe_currency_code(self, fee_currency_id.clone(), Value::Undefined);
            } else {
                fee_currency = if side.clone() == Value::from("sell") { market.get(Value::from("quote")) } else { market.get(Value::from("base")) };
            };
            fee = Value::Json(normalize(&Value::Json(json!({
                "cost": fee_cost,
                "currency": fee_currency
            }))).unwrap());
        };
        let mut stop_price: Value = self.safe_string(order.clone(), Value::from("stop-price"), Value::Undefined);
        let mut average: Value = self.safe_string(order.clone(), Value::from("trade_avg_price"), Value::Undefined);
        let mut trades: Value = self.safe_value(order.clone(), Value::from("trades"), Value::Undefined);
        return Huobi::safe_order(self, Value::Json(normalize(&Value::Json(json!({
            "info": order,
            "id": id,
            "clientOrderId": client_order_id,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "lastTradeTimestamp": Value::Undefined,
            "symbol": market.get(Value::from("symbol")),
            "type": r#type,
            "timeInForce": Value::Undefined,
            "postOnly": Value::Undefined,
            "side": side,
            "price": price,
            "stopPrice": stop_price,
            "average": average,
            "cost": cost,
            "amount": amount,
            "filled": filled,
            "remaining": Value::Undefined,
            "status": status,
            "fee": fee,
            "trades": trades
        }))).unwrap()), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Create a trade order
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to create an order in
    /// * `type` {string} - 'market' or 'limit'
    /// * `side` {string} - 'buy' or 'sell'
    /// * `amount` {float} - how much of currency you want to trade in units of base currency
    /// * `price` {float|undefined} - the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn create_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let (mut market_type, mut query) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("createOrder"), market.clone(), params.clone()));
        let mut method: Value = Huobi::get_supported_mapping(self, market_type.clone(), Value::Json(normalize(&Value::Json(json!({
            "spot": "createSpotOrder",
            "swap": "createContractOrder",
            "future": "createContractOrder"
        }))).unwrap()));
        if method.clone().is_nullish() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createOrder() does not support ") + market_type.clone() + Value::from(" markets yet"))"###);
        };
        return Huobi::dispatch(self, method, symbol.clone(), r#type.clone()).await;
    }

    async fn create_spot_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        Huobi::load_accounts(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let mut account_id: Value = Huobi::fetch_account_id_by_type(self, market.get(Value::from("type")), Value::Undefined).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "account-id": account_id,
            "symbol": market.get(Value::from("id"))
        }))).unwrap());
        // spot -----------------------------------------------------------
        // 'type': side + '-' + type, // buy-market, sell-market, buy-limit, sell-limit, buy-ioc, sell-ioc, buy-limit-maker, sell-limit-maker, buy-stop-limit, sell-stop-limit, buy-limit-fok, sell-limit-fok, buy-stop-limit-fok, sell-stop-limit-fok
        // 'amount': this.amountToPrecision (symbol, amount), // for buy market orders it's the order cost
        // 'price': this.priceToPrecision (symbol, price),
        // 'source': 'spot-api', // optional, spot-api, margin-api = isolated margin, super-margin-api = cross margin, c2c-margin-api
        // 'client-order-id': clientOrderId, // optional, max 64 chars, must be unique within 8 hours
        // 'stop-price': this.priceToPrecision (symbol, stopPrice), // trigger price for stop limit orders
        // 'operator': 'gte', // gte, lte, trigger price condition
        let mut order_type: Value = r#type.replace(Value::from("buy-"), Value::from(""));
        order_type = order_type.replace(Value::from("sell-"), Value::from(""));
        let mut options: Value = self.safe_value(self.get("options".into()), market.get(Value::from("type")), Value::new_object());
        let mut stop_price: Value = self.safe_string_2(params.clone(), Value::from("stopPrice"), Value::from("stop-price"), Value::Undefined);
        if stop_price.clone().is_nullish() {
            let mut stop_order_types: Value = self.safe_value(options.clone(), Value::from("stopOrderTypes"), Value::new_object());
            if stop_order_types.contains_key(order_type.clone()) {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" createOrder() requires a stopPrice or a stop-price parameter for a stop order"))"###);
            };
        } else {
            let mut stop_operator: Value = self.safe_string(params.clone(), Value::from("operator"), Value::Undefined);
            if stop_operator.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(r#" createOrder() requires an operator parameter "gte" or "lte" for a stop order"#))"###);
            };
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("stopPrice").into(), Value::from("stop-price").into()])));
            request.set("stop-price".into(), Huobi::price_to_precision(self, symbol.clone(), stop_price.clone()));
            request.set("operator".into(), stop_operator.clone());
            if order_type.clone() == Value::from("limit") || order_type.clone() == Value::from("limit-fok") {
                order_type = Value::from("stop-") + order_type.clone();
            } else if order_type.clone() != Value::from("stop-limit") && order_type.clone() != Value::from("stop-limit-fok") {
                panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createOrder() does not support ") + r#type.clone() + Value::from(" orders"))"###);
            };
        };
        let mut post_only: Value = self.safe_value(params.clone(), Value::from("postOnly"), false.into());
        if post_only.is_truthy() {
            order_type = Value::from("limit-maker");
        };
        request.set("type".into(), side.clone() + Value::from("-") + order_type.clone());
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("clientOrderId"), Value::from("client-order-id"), Value::Undefined);
        // must be 64 chars max and unique within 24 hours
        if client_order_id.clone().is_nullish() {
            let mut broker: Value = self.safe_value(self.get("options".into()), Value::from("broker"), Value::new_object());
            let mut broker_id: Value = self.safe_string(broker.clone(), Value::from("id"), Value::Undefined);
            request.set("client-order-id".into(), broker_id.clone() + self.uuid(Value::Undefined));
        } else {
            request.set("client-order-id".into(), client_order_id.clone());
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("clientOrderId").into(), Value::from("client-order-id").into(), Value::from("postOnly").into()])));
        if order_type.clone() == Value::from("market") && side.clone() == Value::from("buy") {
            if self.get("options".into()).get(Value::from("createMarketBuyOrderRequiresPrice")).is_truthy() {
                if price.clone().is_nullish() {
                    panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market buy order requires price argument to calculate cost (total amount of quote currency to spend for buying, amount * price). To switch off this warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing."))"###);
                } else {
                    // despite that cost = amount * price is in quote currency and should have quote precision
                    // the exchange API requires the cost supplied in 'amount' to be of base precision
                    // more about it here:
                    // https://github.com/ccxt/ccxt/pull/4395
                    // https://github.com/ccxt/ccxt/issues/7611
                    // we use amountToPrecision here because the exchange requires cost in base precision
                    request.set("amount".into(), Huobi::cost_to_precision(self, symbol.clone(), parse_float(amount.clone()) * parse_float(price.clone())));
                };
            } else {
                request.set("amount".into(), Huobi::cost_to_precision(self, symbol.clone(), amount.clone()));
            };
        } else {
            request.set("amount".into(), Huobi::amount_to_precision(self, symbol.clone(), amount.clone()));
        };
        let mut limit_order_types: Value = self.safe_value(options.clone(), Value::from("limitOrderTypes"), Value::new_object());
        if limit_order_types.contains_key(order_type.clone()) {
            request.set("price".into(), Huobi::price_to_precision(self, symbol.clone(), price.clone()));
        };
        let mut response: Value = Huobi::dispatch(self, "spotPrivatePostV1OrderOrdersPlace".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {"status":"ok","data":"438398393065481"}
        //
        let mut id: Value = self.safe_string(response.clone(), Value::from("data"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": response,
            "id": id,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "lastTradeTimestamp": Value::Undefined,
            "status": Value::Undefined,
            "symbol": Value::Undefined,
            "type": Value::Undefined,
            "side": Value::Undefined,
            "price": Value::Undefined,
            "amount": Value::Undefined,
            "filled": Value::Undefined,
            "remaining": Value::Undefined,
            "cost": Value::Undefined,
            "trades": Value::Undefined,
            "fee": Value::Undefined,
            "clientOrderId": Value::Undefined,
            "average": Value::Undefined
        }))).unwrap());
    }

    async fn create_contract_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut offset: Value = self.safe_string(params.clone(), Value::from("offset"), Value::Undefined);
        if offset.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" createOrder() requires a string offset parameter for contract orders, open or close"))"###);
        };
        let mut stop_price: Value = self.safe_string(params.clone(), Value::from("stopPrice"), Value::Undefined);
        if stop_price.clone().is_nonnullish() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createOrder() supports tp_trigger_price + tp_order_price for take profit orders and/or sl_trigger_price + sl_order price for stop loss orders, stop orders are supported only with open long orders and open short orders"))"###);
        };
        let mut market: Value = Huobi::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "contract_code": market.get(Value::from("id")),
            "volume": Huobi::amount_to_precision(self, symbol.clone(), amount.clone()),
            "direction": side,
            "offset": offset,
            "lever_rate": 1
        }))).unwrap());
        // 'symbol': 'BTC', // optional, case-insenstive, both uppercase and lowercase are supported, "BTC", "ETH", ...
        // 'contract_type': 'this_week', // optional, this_week, next_week, quarter, next_quarter
        // optional BTC180914
        // 'client_order_id': clientOrderId, // optional, must be less than 9223372036854775807
        // 'price': this.priceToPrecision (symbol, price), // optional
        // buy, sell
        // open, close
        //
        //     direction buy, offset open = open long
        //     direction sell, offset close = close long
        //     direction sell, offset open = open short
        //     direction buy, offset close = close short
        //
        // 'reduce_only': 0, // 1 or 0, in hedge mode it is invalid, and in one-way mode its value is 0 when not filled
        // required, using leverage greater than 20x requires prior approval of high-leverage agreement
        // 'order_price_type': 'limit', // required
        //
        //     order_price_type can be:
        //
        //     limit
        //     opponent // BBO
        //     post_only
        //     optimal_5
        //     optimal_10
        //     optimal_20
        //     ioc
        //     fok
        //     opponent_ioc // IOC order using the BBO price
        //     optimal_5_ioc
        //     optimal_10_ioc
        //     optimal_20_ioc
        //     opponent_fok // FOR order using the BBO price
        //     optimal_5_fok
        //     optimal_10_fok
        //     optimal_20_fok
        //
        // 'tp_trigger_price': this.priceToPrecision (symbol, triggerPrice),
        // 'tp_order_price': this.priceToPrecision (symbol, price),
        // 'tp_order_price_type': 'limit', // limitoptimal_5optimal_10optimal_20
        // 'sl_trigger_price': this.priceToPrecision (symbol, stopLossPrice),
        // 'sl_order_price': this.priceToPrecision (symbol, price),
        // 'sl_order_price_type': 'limit', // limitoptimal_5optimal_10optimal_20
        let mut stop_loss_order_price: Value = self.safe_string(params.clone(), Value::from("sl_order_price"), Value::Undefined);
        let mut stop_loss_trigger_price: Value = self.safe_string(params.clone(), Value::from("sl_trigger_price"), Value::Undefined);
        let mut take_profit_order_price: Value = self.safe_string(params.clone(), Value::from("tp_order_price"), Value::Undefined);
        let mut take_profit_trigger_price: Value = self.safe_string(params.clone(), Value::from("tp_trigger_price"), Value::Undefined);
        let mut is_open_order: Value = (offset.clone() == Value::from("open")).into();
        let mut is_stop_order: Value = false.into();
        if stop_loss_trigger_price.clone().is_nonnullish() {
            request.set("sl_trigger_price".into(), Huobi::price_to_precision(self, symbol.clone(), stop_loss_trigger_price.clone()));
            is_stop_order = true.into();
            if price.clone().is_nonnullish() {
                request.set("sl_order_price".into(), Huobi::price_to_precision(self, symbol.clone(), price.clone()));
            };
        };
        if stop_loss_order_price.clone().is_nonnullish() {
            request.set("sl_order_price".into(), Huobi::price_to_precision(self, symbol.clone(), stop_loss_order_price.clone()));
            is_stop_order = true.into();
        };
        if take_profit_trigger_price.clone().is_nonnullish() {
            request.set("tp_trigger_price".into(), Huobi::price_to_precision(self, symbol.clone(), take_profit_trigger_price.clone()));
            is_stop_order = true.into();
            if price.clone().is_nonnullish() {
                request.set("tp_order_price".into(), Huobi::price_to_precision(self, symbol.clone(), price.clone()));
            };
        };
        if take_profit_order_price.clone().is_nonnullish() {
            request.set("tp_order_price".into(), Huobi::price_to_precision(self, symbol.clone(), take_profit_order_price.clone()));
            is_stop_order = true.into();
        };
        if is_stop_order.is_truthy() && !is_open_order.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createOrder() supports tp_trigger_price + tp_order_price for take profit orders and/or sl_trigger_price + sl_order price for stop loss orders, stop orders are supported only with open long orders and open short orders"))"###);
        };
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("sl_order_price").into(), Value::from("sl_trigger_price").into(), Value::from("tp_order_price").into(), Value::from("tp_trigger_price").into()])));
        let mut post_only: Value = self.safe_value(params.clone(), Value::from("postOnly"), false.into());
        if post_only.is_truthy() {
            r#type = Value::from("post_only");
        };
        if r#type.clone() == Value::from("limit") || r#type.clone() == Value::from("ioc") || r#type.clone() == Value::from("fok") || r#type.clone() == Value::from("post_only") {
            request.set("price".into(), Huobi::price_to_precision(self, symbol.clone(), price.clone()));
        };
        request.set("order_price_type".into(), r#type.clone());
        let mut broker: Value = self.safe_value(self.get("options".into()), Value::from("broker"), Value::new_object());
        let mut broker_id: Value = self.safe_string(broker.clone(), Value::from("id"), Value::Undefined);
        request.set("channel_code".into(), broker_id.clone());
        let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("client_order_id"), Value::from("clientOrderId"), Value::Undefined);
        if client_order_id.clone().is_nonnullish() {
            request.set("client_order_id".into(), client_order_id.clone());
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("client_order_id").into(), Value::from("clientOrderId").into()])));
        };
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("linear")).is_truthy() {
            let mut margin_mode: Value = Value::Undefined;
            (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("createOrder"), params.clone()));
            margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
            if margin_mode.clone() == Value::from("isolated") {
                method = Value::from("contractPrivatePostLinearSwapApiV1SwapOrder");
            } else if margin_mode.clone() == Value::from("cross") {
                method = Value::from("contractPrivatePostLinearSwapApiV1SwapCrossOrder");
            };
        } else if market.get(Value::from("inverse")).is_truthy() {
            if market.get(Value::from("swap")).is_truthy() {
                method = Value::from("contractPrivatePostSwapApiV1SwapOrder");
            } else if market.get(Value::from("future")).is_truthy() {
                method = Value::from("contractPrivatePostApiV1ContractOrder");
            };
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // linear swap cross margin
        //
        //     {
        //         "status":"ok",
        //         "data":{
        //             "order_id":924660854912552960,
        //             "order_id_str":"924660854912552960"
        //         },
        //         "ts":1640497927185
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Huobi::parse_order(self, data.clone(), market.clone());
    }

    /// Returns an [order structure](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancels an open order
    ///
    /// # Arguments
    ///
    /// * `id` {string} - order id
    /// * `symbol` {string|undefined} - unified symbol of the market the order was made in
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn cancel_order(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Huobi::market(self, symbol.clone());
        };
        let mut market_type: Value = Value::Undefined;
        (market_type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("cancelOrder"), market.clone(), params.clone()));
        let mut request: Value = Value::new_object();
        // spot -----------------------------------------------------------
        // 'order-id': 'id',
        // 'symbol': market['id'],
        // 'client-order-id': clientOrderId,
        // contracts ------------------------------------------------------
        // 'order_id': id,
        // 'client_order_id': clientOrderId,
        // 'contract_code': market['id'],
        // 'pair': 'BTC-USDT',
        // 'contract_type': 'this_week', // swap, this_week, next_week, quarter, next_ quarter
        let mut method: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("client-order-id"), Value::from("clientOrderId"), Value::Undefined);
            method = Value::from("spotPrivatePostV1OrderOrdersOrderIdSubmitcancel");
            if client_order_id.clone().is_nullish() {
                request.set("order-id".into(), id.clone());
            } else {
                request.set("client-order-id".into(), client_order_id.clone());
                method = Value::from("spotPrivatePostV1OrderOrdersSubmitCancelClientOrder");
                params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("client-order-id").into(), Value::from("clientOrderId").into()])));
            };
        } else {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelOrder() requires a symbol for ") + market_type.clone() + Value::from(" orders"))"###);
            };
            request.set("contract_code".into(), market.get(Value::from("id")));
            if market.get(Value::from("linear")).is_truthy() {
                let mut margin_mode: Value = Value::Undefined;
                (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("cancelOrder"), params.clone()));
                margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
                if margin_mode.clone() == Value::from("isolated") {
                    method = Value::from("contractPrivatePostLinearSwapApiV1SwapCancel");
                } else if margin_mode.clone() == Value::from("cross") {
                    method = Value::from("contractPrivatePostLinearSwapApiV1SwapCrossCancel");
                };
            } else if market.get(Value::from("inverse")).is_truthy() {
                if market.get(Value::from("future")).is_truthy() {
                    method = Value::from("contractPrivatePostApiV1ContractCancel");
                    request.set("symbol".into(), market.get(Value::from("settleId")));
                } else if market.get(Value::from("swap")).is_truthy() {
                    method = Value::from("contractPrivatePostSwapApiV1SwapCancel");
                };
            } else {
                panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" cancelOrder() does not support ") + market_type.clone() + Value::from(" markets"))"###);
            };
            let mut client_order_id: Value = self.safe_string_2(params.clone(), Value::from("client_order_id"), Value::from("clientOrderId"), Value::Undefined);
            if client_order_id.clone().is_nullish() {
                request.set("order_id".into(), id.clone());
            } else {
                request.set("client_order_id".into(), client_order_id.clone());
                params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("client_order_id").into(), Value::from("clientOrderId").into()])));
            };
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         'status': 'ok',
        //         'data': '10138899000',
        //     }
        //
        // linear swap cross margin
        //
        //     {
        //         "status":"ok",
        //         "data":{
        //             "errors":[],
        //             "successes":"924660854912552960"
        //         },
        //         "ts":1640504486089
        //     }
        //
        return extend_2(Huobi::parse_order(self, response.clone(), market.clone()), Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "status": "canceled"
        }))).unwrap()));
    }

    /// Returns an list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel multiple orders
    ///
    /// # Arguments
    ///
    /// * `ids` {[string]} - order ids
    /// * `symbol` {string|undefined} - unified market symbol, default is undefined
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn cancel_orders(&mut self, mut ids: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Huobi::market(self, symbol.clone());
        };
        let mut market_type: Value = Value::Undefined;
        (market_type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("cancelOrders"), market.clone(), params.clone()));
        let mut request: Value = Value::new_object();
        // spot -----------------------------------------------------------
        // 'order-ids': ids.jsoin (','), // max 50
        // 'client-order-ids': ids.join (','), // max 50
        // contracts ------------------------------------------------------
        // 'order_id': id, // comma separated, max 10
        // 'client_order_id': clientOrderId, // comma separated, max 10
        // 'contract_code': market['id'],
        // 'symbol': market['settleId'],
        let mut method: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            let mut client_order_ids: Value = self.safe_value_2(params.clone(), Value::from("client-order-id"), Value::from("clientOrderId"), Value::Undefined);
            client_order_ids = self.safe_value_2(params.clone(), Value::from("client-order-ids"), Value::from("clientOrderIds"), client_order_ids.clone());
            if client_order_ids.clone().is_nullish() {
                if client_order_ids.typeof_() == Value::from("string") {
                    request.set("order-ids".into(), ids.clone());
                } else {
                    request.set("order-ids".into(), ids.join(Value::from(",")));
                };
            } else {
                if client_order_ids.typeof_() == Value::from("string") {
                    request.set("client-order-ids".into(), client_order_ids.clone());
                } else {
                    request.set("client-order-ids".into(), client_order_ids.join(Value::from(",")));
                };
                params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("client-order-id").into(), Value::from("client-order-ids").into(), Value::from("clientOrderId").into(), Value::from("clientOrderIds").into()])));
            };
            method = Value::from("spotPrivatePostV1OrderOrdersBatchcancel");
        } else {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelOrders() requires a symbol for ") + market_type.clone() + Value::from(" orders"))"###);
            };
            let mut market: Value = Huobi::market(self, symbol.clone());
            request.set("contract_code".into(), market.get(Value::from("id")));
            if market.get(Value::from("linear")).is_truthy() {
                let mut margin_mode: Value = Value::Undefined;
                (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("cancelOrders"), params.clone()));
                margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
                if margin_mode.clone() == Value::from("isolated") {
                    method = Value::from("contractPrivatePostLinearSwapApiV1SwapCancel");
                } else if margin_mode.clone() == Value::from("cross") {
                    method = Value::from("contractPrivatePostLinearSwapApiV1SwapCrossCancel");
                };
            } else if market.get(Value::from("inverse")).is_truthy() {
                if market.get(Value::from("future")).is_truthy() {
                    method = Value::from("contractPrivatePostApiV1ContractCancel");
                    request.set("symbol".into(), market.get(Value::from("settleId")));
                } else if market.get(Value::from("swap")).is_truthy() {
                    method = Value::from("contractPrivatePostSwapApiV1SwapCancel");
                } else {
                    panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" cancelOrders() does not support ") + market_type.clone() + Value::from(" markets"))"###);
                };
            };
            let mut client_order_ids: Value = self.safe_string_2(params.clone(), Value::from("client_order_id"), Value::from("clientOrderId"), Value::Undefined);
            client_order_ids = self.safe_string_2(params.clone(), Value::from("client_order_ids"), Value::from("clientOrderIds"), client_order_ids.clone());
            if client_order_ids.clone().is_nullish() {
                request.set("order_id".into(), ids.join(Value::from(",")));
            } else {
                request.set("client_order_id".into(), client_order_ids.clone());
                params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("client_order_id").into(), Value::from("client_order_ids").into(), Value::from("clientOrderId").into(), Value::from("clientOrderIds").into()])));
            };
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // spot
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "success": [
        //                 "5983466"
        //             ],
        //             "failed": [
        //                 {
        //                     "err-msg": "Incorrect order state",
        //                     "order-state": 7,
        //                     "order-id": "",
        //                     "err-code": "order-orderstate-error",
        //                     "client-order-id": "first"
        //                 },
        //                 {
        //                     "err-msg": "Incorrect order state",
        //                     "order-state": 7,
        //                     "order-id": "",
        //                     "err-code": "order-orderstate-error",
        //                     "client-order-id": "second"
        //                 },
        //                 {
        //                     "err-msg": "The record is not found.",
        //                     "order-id": "",
        //                     "err-code": "base-not-found",
        //                     "client-order-id": "third"
        //                 }
        //             ]
        //         }
        //     }
        //
        // contracts
        //
        //     {
        //         "status": "ok",
        //         "data": {
        //             "errors": [
        //                 {
        //                     "order_id": "769206471845261312",
        //                     "err_code": 1061,
        //                     "err_msg": "This order doesnt exist."
        //                 }
        //             ],
        //             "successes": "773120304138219520"
        //         },
        //         "ts": 1604367997451
        //     }
        //
        return response.clone();
    }

    /// Returns a list of [order structures](https://docs.ccxt.com/en/latest/manual.html#order-structure)
    ///
    /// Cancel all open orders
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn cancel_all_orders(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Value::Undefined;
        if symbol.clone().is_nonnullish() {
            market = Huobi::market(self, symbol.clone());
        };
        let mut market_type: Value = Value::Undefined;
        (market_type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("cancelAllOrders"), market.clone(), params.clone()));
        let mut request: Value = Value::new_object();
        // spot -----------------------------------------------------------
        // 'account-id': account['id'],
        // 'symbol': market['id'], // a list of comma-separated symbols, all symbols by default
        // 'types' 'string', buy-market, sell-market, buy-limit, sell-limit, buy-ioc, sell-ioc, buy-stop-limit, sell-stop-limit, buy-limit-fok, sell-limit-fok, buy-stop-limit-fok, sell-stop-limit-fok
        // 'side': 'buy', // or 'sell'
        // 'size': 100, // the number of orders to cancel 1-100
        // contract -------------------------------------------------------
        // 'symbol': market['settleId'], // required
        // 'contract_code': market['id'],
        // 'contract_type': 'this_week', // swap, this_week, next_week, quarter, next_ quarter
        // 'direction': 'buy': // buy, sell
        // 'offset': 'open', // open, close
        let mut method: Value = Value::Undefined;
        if market_type.clone() == Value::from("spot") {
            if symbol.clone().is_nonnullish() {
                market = Huobi::market(self, symbol.clone());
                request.set("symbol".into(), market.get(Value::from("id")));
            };
            method = Value::from("spotPrivatePostV1OrderOrdersBatchCancelOpenOrders");
        } else {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" cancelAllOrders() requires a symbol for ") + market_type.clone() + Value::from(" orders"))"###);
            };
            let mut market: Value = Huobi::market(self, symbol.clone());
            request.set("contract_code".into(), market.get(Value::from("id")));
            if market.get(Value::from("linear")).is_truthy() {
                let mut margin_mode: Value = Value::Undefined;
                (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("cancelAllOrders"), params.clone()));
                margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
                if margin_mode.clone() == Value::from("isolated") {
                    method = Value::from("contractPrivatePostLinearSwapApiV1SwapCancelallall");
                } else if margin_mode.clone() == Value::from("cross") {
                    method = Value::from("contractPrivatePostLinearSwapApiV1SwapCrossCancelall");
                };
            } else if market.get(Value::from("inverse")).is_truthy() {
                if market_type.clone() == Value::from("future") {
                    method = Value::from("contractPrivatePostApiV1ContractCancelall");
                    request.set("symbol".into(), market.get(Value::from("settleId")));
                } else if market_type.clone() == Value::from("swap") {
                    method = Value::from("contractPrivatePostSwapApiV1SwapCancelall");
                } else {
                    panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" cancelAllOrders() does not support ") + market_type.clone() + Value::from(" markets"))"###);
                };
            };
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: 200,
        //         data: {
        //             "success-count": 2,
        //             "failed-count": 0,
        //             "next-id": 5454600
        //         }
        //     }
        //
        return response.clone();
    }

    fn safe_network(&self, mut network_id: Value) -> Value {
        let mut last_character_index: Value = network_id.len().into() - Value::from(1);
        let mut last_character: Value = network_id.get(last_character_index.clone());
        if last_character.clone() == Value::from("1") {
            network_id = network_id.slice(Value::from(0), last_character_index.clone());
        };
        let mut networks_by_id: Value = Value::new_object();
        return self.safe_string(networks_by_id.clone(), network_id.clone(), network_id.clone());
    }

    fn parse_deposit_address(&self, mut deposit_address: Value, mut currency: Value) -> Value {
        //
        //     {
        //         currency: "usdt",
        //         address: "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //         addressTag: "",
        //         chain: "usdterc20", // trc20usdt, hrc20usdt, usdt, algousdt
        //     }
        //
        let mut address: Value = self.safe_string(deposit_address.clone(), Value::from("address"), Value::Undefined);
        let mut tag: Value = self.safe_string(deposit_address.clone(), Value::from("addressTag"), Value::Undefined);
        let mut currency_id: Value = self.safe_string(deposit_address.clone(), Value::from("currency"), Value::Undefined);
        currency = Huobi::safe_currency(self, currency_id.clone(), currency.clone());
        let mut code: Value = Huobi::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut network_id: Value = self.safe_string(deposit_address.clone(), Value::from("chain"), Value::Undefined);
        let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
        let mut networks_by_id: Value = self.index_by(networks.clone(), Value::from("id"), Value::Undefined);
        let mut network_value: Value = self.safe_value(networks_by_id.clone(), network_id.clone(), network_id.clone());
        let mut network: Value = self.safe_string(network_value.clone(), Value::from("network"), Value::Undefined);
        let mut note: Value = self.safe_string(deposit_address.clone(), Value::from("note"), Value::Undefined);
        self.check_address(address.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "currency": code,
            "address": address,
            "tag": tag,
            "network": network,
            "note": note,
            "info": deposit_address
        }))).unwrap());
    }

    /// Returns a dictionary of [address structures](https://docs.ccxt.com/en/latest/manual.html#address-structure) indexed by the network
    ///
    /// Fetch a dictionary of addresses for a currency, indexed by network
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency for the deposit address
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_deposit_addresses_by_network(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Huobi::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Huobi::dispatch(self, "spotPrivateGetV2AccountDepositAddress".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: 200,
        //         data: [
        //             {
        //                 currency: "eth",
        //                 address: "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //                 addressTag: "",
        //                 chain: "eth"
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut parsed: Value = Huobi::parse_deposit_addresses(self, data.clone(), Value::Json(serde_json::Value::Array(vec![code.clone().into()])), false.into(), Value::Undefined);
        return self.index_by(parsed.clone(), Value::from("network"), Value::Undefined);
    }

    /// Returns an [address structure](https://docs.ccxt.com/en/latest/manual.html#address-structure)
    ///
    /// Fetch the deposit address for a currency associated with this account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_deposit_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut raw_network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string_upper(networks.clone(), raw_network.clone(), raw_network.clone());
        params = self.omit(params.clone(), Value::from("network"));
        let mut response: Value = Huobi::fetch_deposit_addresses_by_network(self, code.clone(), params.clone()).await;
        let mut result: Value = Value::Undefined;
        if network.clone().is_nullish() {
            result = self.safe_value(response.clone(), code.clone(), Value::Undefined);
            if result.clone().is_nullish() {
                let mut alias: Value = self.safe_string(networks.clone(), code.clone(), code.clone());
                result = self.safe_value(response.clone(), alias.clone(), Value::Undefined);
                if result.clone().is_nullish() {
                    let mut default_network: Value = self.safe_string(self.get("options".into()), Value::from("defaultNetwork"), Value::from("ERC20"));
                    result = self.safe_value(response.clone(), default_network.clone(), Value::Undefined);
                    if result.clone().is_nullish() {
                        let mut values: Value = Object::values(response.clone());
                        result = self.safe_value(values.clone(), Value::from(0), Value::Undefined);
                        if result.clone().is_nullish() {
                            panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchDepositAddress() cannot find deposit address for ") + code.clone())"###);
                        };
                    };
                };
            };
            return result.clone();
        };
        result = self.safe_value(response.clone(), network.clone(), Value::Undefined);
        if result.clone().is_nullish() {
            panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchDepositAddress() cannot find ") + network.clone() + Value::from(" deposit address for ") + code.clone())"###);
        };
        return result.clone();
    }

    async fn fetch_withdraw_addresses_by_network(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Huobi::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Huobi::dispatch(self, "spotPrivateGetV2AccountWithdrawAddress".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         code: 200,
        //         data: [
        //             {
        //                 currency: "eth",
        //                 chain: "eth"
        //                 note: "Binance - TRC20",
        //                 addressTag: "",
        //                 address: "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut parsed: Value = Huobi::parse_deposit_addresses(self, data.clone(), Value::Json(serde_json::Value::Array(vec![code.clone().into()])), false.into(), Value::Undefined);
        return self.index_by(parsed.clone(), Value::from("network"), Value::Undefined);
    }

    async fn fetch_withdraw_address(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut raw_network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string_upper(networks.clone(), raw_network.clone(), raw_network.clone());
        params = self.omit(params.clone(), Value::from("network"));
        let mut response: Value = Huobi::fetch_withdraw_addresses_by_network(self, code.clone(), params.clone()).await;
        let mut result: Value = Value::Undefined;
        if network.clone().is_nullish() {
            result = self.safe_value(response.clone(), code.clone(), Value::Undefined);
            if result.clone().is_nullish() {
                let mut alias: Value = self.safe_string(networks.clone(), code.clone(), code.clone());
                result = self.safe_value(response.clone(), alias.clone(), Value::Undefined);
                if result.clone().is_nullish() {
                    let mut default_network: Value = self.safe_string(self.get("options".into()), Value::from("defaultNetwork"), Value::from("ERC20"));
                    result = self.safe_value(response.clone(), default_network.clone(), Value::Undefined);
                    if result.clone().is_nullish() {
                        let mut values: Value = Object::values(response.clone());
                        result = self.safe_value(values.clone(), Value::from(0), Value::Undefined);
                        if result.clone().is_nullish() {
                            panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchWithdrawAddress() cannot find withdraw address for ") + code.clone())"###);
                        };
                    };
                };
            };
            return result.clone();
        };
        result = self.safe_value(response.clone(), network.clone(), Value::Undefined);
        if result.clone().is_nullish() {
            panic!(r###"InvalidAddress::new(self.get("id".into()) + Value::from(" fetchWithdrawAddress() cannot find ") + network.clone() + Value::from(" withdraw address for ") + code.clone())"###);
        };
        return result.clone();
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all deposits made to an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch deposits for
    /// * `limit` {int|undefined} - the maximum number of deposits structures to retrieve
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_deposits(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if limit.clone().is_nullish() || limit.clone() > Value::from(100) {
            limit = Value::from(100);
        };
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Huobi::currency(self, code.clone());
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "type": "deposit",
            "from": 0
        }))).unwrap());
        // From 'id' ... if you want to get results after a particular transaction id, pass the id in params.from
        if currency.clone().is_nonnullish() {
            request.set("currency".into(), currency.get(Value::from("id")));
        };
        if limit.clone().is_nonnullish() {
            request.set("size".into(), limit.clone());
        };
        // max 100
        let mut response: Value = Huobi::dispatch(self, "spotPrivateGetV1QueryDepositWithdraw".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        // return response
        return Huobi::parse_transactions(self, response.get(Value::from("data")), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of [transaction structures](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Fetch all withdrawals made from an account
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `since` {int|undefined} - the earliest time in ms to fetch withdrawals for
    /// * `limit` {int|undefined} - the maximum number of withdrawals structures to retrieve
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_withdrawals(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if limit.clone().is_nullish() || limit.clone() > Value::from(100) {
            limit = Value::from(100);
        };
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Huobi::currency(self, code.clone());
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "type": "withdraw",
            "from": 0
        }))).unwrap());
        // From 'id' ... if you want to get results after a particular transaction id, pass the id in params.from
        if currency.clone().is_nonnullish() {
            request.set("currency".into(), currency.get(Value::from("id")));
        };
        if limit.clone().is_nonnullish() {
            request.set("size".into(), limit.clone());
        };
        // max 100
        let mut response: Value = Huobi::dispatch(self, "spotPrivateGetV1QueryDepositWithdraw".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        // return response
        return Huobi::parse_transactions(self, response.get(Value::from("data")), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_transaction(&self, mut transaction: Value, mut currency: Value) -> Value {
        //
        // fetchDeposits
        //
        //     {
        //         'id': 8211029,
        //         'type': 'deposit',
        //         'currency': 'eth',
        //         'chain': 'eth',
        //         'tx-hash': 'bd315....',
        //         'amount': 0.81162421,
        //         'address': '4b8b....',
        //         'address-tag': '',
        //         'fee': 0,
        //         'state': 'safe',
        //         'created-at': 1542180380965,
        //         'updated-at': 1542180788077
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         'id': 6908275,
        //         'type': 'withdraw',
        //         'currency': 'btc',
        //         'chain': 'btc',
        //         'tx-hash': 'c1a1a....',
        //         'amount': 0.80257005,
        //         'address': '1QR....',
        //         'address-tag': '',
        //         'fee': 0.0005,
        //         'state': 'confirmed',
        //         'created-at': 1552107295685,
        //         'updated-at': 1552108032859
        //     }
        //
        // withdraw
        //
        //     {
        //         "status": "ok",
        //         "data": "99562054"
        //     }
        //
        let mut timestamp: Value = self.safe_integer(transaction.clone(), Value::from("created-at"), Value::Undefined);
        let mut updated: Value = self.safe_integer(transaction.clone(), Value::from("updated-at"), Value::Undefined);
        let mut code: Value = Huobi::safe_currency_code(self, self.safe_string(transaction.clone(), Value::from("currency"), Value::Undefined), Value::Undefined);
        let mut r#type: Value = self.safe_string(transaction.clone(), Value::from("type"), Value::Undefined);
        if r#type.clone() == Value::from("withdraw") {
            r#type = Value::from("withdrawal");
        };
        let mut status: Value = Huobi::parse_transaction_status(self, self.safe_string(transaction.clone(), Value::from("state"), Value::Undefined));
        let mut tag: Value = self.safe_string(transaction.clone(), Value::from("address-tag"), Value::Undefined);
        let mut fee_cost: Value = Huobi::safe_number(self, transaction.clone(), Value::from("fee"), Value::Undefined);
        if fee_cost.clone().is_nonnullish() {
            fee_cost = Math::abs(fee_cost.clone());
        };
        let mut address: Value = self.safe_string(transaction.clone(), Value::from("address"), Value::Undefined);
        let mut network: Value = self.safe_string_upper(transaction.clone(), Value::from("chain"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": transaction,
            "id": self.safe_string_2(transaction.clone(), Value::from("id"), Value::from("data"), Value::Undefined),
            "txid": self.safe_string(transaction.clone(), Value::from("tx-hash"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "network": network,
            "address": address,
            "addressTo": Value::Undefined,
            "addressFrom": Value::Undefined,
            "tag": tag,
            "tagTo": Value::Undefined,
            "tagFrom": Value::Undefined,
            "type": r#type,
            "amount": Huobi::safe_number(self, transaction.clone(), Value::from("amount"), Value::Undefined),
            "currency": code,
            "status": status,
            "updated": updated,
            "fee": Value::Json(normalize(&Value::Json(json!({
                "currency": code,
                "cost": fee_cost,
                "rate": Value::Undefined
            }))).unwrap())
        }))).unwrap());
    }

    fn parse_transaction_status(&self, mut status: Value) -> Value {
        let mut statuses: Value = Value::Json(normalize(&Value::Json(json!({
            "unknown": "failed",
            "confirming": "pending",
            "confirmed": "ok",
            "safe": "ok",
            "orphan": "failed",
            "submitted": "pending",
            "canceled": "canceled",
            "reexamine": "pending",
            "reject": "failed",
            "pass": "pending",
            "wallet-reject": "failed",
            "confirm-error": "failed",
            "repealed": "failed",
            "wallet-transfer": "pending",
            "pre-transfer": "pending"
        }))).unwrap());
        // deposit statuses
        // withdrawal statuses
        // 'confirmed': 'ok', // present in deposit statuses
        return self.safe_string(statuses.clone(), status.clone(), status.clone());
    }

    /// Returns a [transaction structure](https://docs.ccxt.com/en/latest/manual.html#transaction-structure)
    ///
    /// Make a withdrawal
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - the amount to withdraw
    /// * `address` {string} - the address to withdraw to
    /// * `tag` {string|undefined} - 
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn withdraw(&mut self, mut code: Value, mut amount: Value, mut address: Value, mut tag: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        (tag, params) = shift_2(Huobi::handle_withdraw_tag_and_params(self, tag.clone(), params.clone()));
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        self.check_address(address.clone());
        let mut currency: Value = Huobi::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "address": address,
            "amount": amount,
            "currency": currency.get(Value::from("id")).to_lower_case()
        }))).unwrap());
        // only supports existing addresses in your withdraw address list
        if tag.clone().is_nonnullish() {
            request.set("addr-tag".into(), tag.clone());
        };
        // only for XRP?
        let mut networks: Value = self.safe_value(self.get("options".into()), Value::from("networks"), Value::new_object());
        let mut network: Value = self.safe_string_upper(params.clone(), Value::from("network"), Value::Undefined);
        // this line allows the user to specify either ERC20 or ETH
        network = self.safe_string_lower(networks.clone(), network.clone(), network.clone());
        // handle ETH>ERC20 alias
        if network.clone().is_nonnullish() {
            // possible chains - usdterc20, trc20usdt, hrc20usdt, usdt, algousdt
            if network.clone() == Value::from("erc20") {
                request.set("chain".into(), currency.get(Value::from("id")) + network.clone());
            } else {
                request.set("chain".into(), network.clone() + currency.get(Value::from("id")));
            };
            params = self.omit(params.clone(), Value::from("network"));
        };
        let mut response: Value = Huobi::dispatch(self, "spotPrivatePostV1DwWithdrawApiCreate".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "status": "ok",
        //         "data": "99562054"
        //     }
        //
        return Huobi::parse_transaction(self, response.clone(), currency.clone());
    }

    fn parse_transfer(&self, mut transfer: Value, mut currency: Value) -> Value {
        //
        // transfer
        //
        //     {
        //         "data": 12345,
        //         "status": "ok"
        //     }
        //
        let mut id: Value = self.safe_string(transfer.clone(), Value::from("data"), Value::Undefined);
        let mut code: Value = Huobi::safe_currency_code(self, Value::Undefined, currency.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "info": transfer,
            "id": id,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "currency": code,
            "amount": Value::Undefined,
            "fromAccount": Value::Undefined,
            "toAccount": Value::Undefined,
            "status": Value::Undefined
        }))).unwrap());
    }

    /// Returns a [transfer structure](https://docs.ccxt.com/en/latest/manual.html#transfer-structure)
    ///
    /// Transfer currency internally between wallets on the same account
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code
    /// * `amount` {float} - amount to transfer
    /// * `fromAccount` {string} - account to transfer from
    /// * `toAccount` {string} - account to transfer to
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn transfer(&mut self, mut code: Value, mut amount: Value, mut from_account: Value, mut to_account: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Huobi::currency(self, code.clone());
        let mut r#type: Value = self.safe_string(params.clone(), Value::from("type"), Value::Undefined);
        if r#type.clone().is_nullish() {
            let mut accounts_by_type: Value = self.safe_value(self.get("options".into()), Value::from("accountsByType"), Value::new_object());
            from_account = from_account.to_lower_case();
            // pro, futures
            to_account = to_account.to_lower_case();
            // pro, futures
            let mut from_id: Value = self.safe_string(accounts_by_type.clone(), from_account.clone(), from_account.clone());
            let mut to_id: Value = self.safe_string(accounts_by_type.clone(), to_account.clone(), to_account.clone());
            r#type = from_id.clone() + Value::from("-to-") + to_id.clone();
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "amount": parse_float(Huobi::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)),
            "type": r#type
        }))).unwrap());
        let mut response: Value = self.spot_private_post_futures_transfer(extend_2(request.clone(), params.clone())).await;
        //
        //     {
        //         "data": 12345,
        //         "status": "ok"
        //     }
        //
        let mut transfer: Value = Huobi::parse_transfer(self, response.clone(), currency.clone());
        return extend_2(transfer.clone(), Value::Json(normalize(&Value::Json(json!({
            "amount": amount,
            "currency": code,
            "fromAccount": from_account,
            "toAccount": to_account
        }))).unwrap()));
    }

    /// Returns a dictionary of [borrow rate structures](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure) indexed by market symbol
    ///
    /// Fetch borrow rates for currencies within individual markets
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_borrow_rates_per_symbol(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Huobi::dispatch(self, "spotPrivateGetV1MarginLoanInfo".into(), params.clone(), Value::Undefined).await;
        //
        //    {
        //        "status": "ok",
        //        "data": [
        //            {
        //                "symbol": "1inchusdt",
        //                "currencies": [
        //                    {
        //                        "currency": "1inch",
        //                        "interest-rate": "0.00098",
        //                        "min-loan-amt": "90.000000000000000000",
        //                        "max-loan-amt": "1000.000000000000000000",
        //                        "loanable-amt": "0.0",
        //                        "actual-rate": "0.00098"
        //                    },
        //                    {
        //                        "currency": "usdt",
        //                        "interest-rate": "0.00098",
        //                        "min-loan-amt": "100.000000000000000000",
        //                        "max-loan-amt": "1000.000000000000000000",
        //                        "loanable-amt": "0.0",
        //                        "actual-rate": "0.00098"
        //                    }
        //                ]
        //            },
        //            ...
        //        ]
        //    }
        //
        let mut timestamp: Value = self.milliseconds();
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut rates: Value = Value::Json(normalize(&Value::Json(json!({
            "info": response
        }))).unwrap());
        let mut i: usize = 0;
        while i < data.len() {
            let mut rate: Value = data.get(i.into());
            let mut currencies: Value = self.safe_value(rate.clone(), Value::from("currencies"), Value::new_array());
            let mut symbol_rates: Value = Value::new_object();
            let mut j: usize = 0;
            while j < currencies.len() {
                let mut currency: Value = currencies.get(j.into());
                let mut currency_id: Value = self.safe_string(currency.clone(), Value::from("currency"), Value::Undefined);
                let mut code: Value = Huobi::safe_currency_code(self, currency_id.clone(), Value::from("currency"));
                symbol_rates.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                    "currency": code,
                    "rate": Huobi::safe_number(self, currency.clone(), Value::from("actual-rate"), Value::Undefined),
                    "span": 86400000,
                    "timestamp": timestamp,
                    "datetime": self.iso8601(timestamp.clone())
                }))).unwrap()));
                j += 1;
            };
            let mut market: Value = self.get("markets_by_id".into()).get(self.safe_string(rate.clone(), Value::from("symbol"), Value::Undefined).clone());
            let mut symbol: Value = market.get(Value::from("symbol"));
            rates.set(symbol.clone(), symbol_rates.clone());
            i += 1;
        };
        return rates.clone();
    }

    /// Returns a list of [borrow rate structures](https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure)
    ///
    /// Fetch the borrow interest rates of all currencies
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_borrow_rates(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Huobi::dispatch(self, "spotPrivateGetV1MarginLoanInfo".into(), params.clone(), Value::Undefined).await;
        // {
        //     "status": "ok",
        //     "data": [
        //         {
        //             "symbol": "1inchusdt",
        //             "currencies": [
        //                 {
        //                     "currency": "1inch",
        //                     "interest-rate": "0.00098",
        //                     "min-loan-amt": "90.000000000000000000",
        //                     "max-loan-amt": "1000.000000000000000000",
        //                     "loanable-amt": "0.0",
        //                     "actual-rate": "0.00098"
        //                 },
        //                 {
        //                     "currency": "usdt",
        //                     "interest-rate": "0.00098",
        //                     "min-loan-amt": "100.000000000000000000",
        //                     "max-loan-amt": "1000.000000000000000000",
        //                     "loanable-amt": "0.0",
        //                     "actual-rate": "0.00098"
        //                 }
        //             ]
        //         },
        //         ...
        //     ]
        // }
        let mut timestamp: Value = self.milliseconds();
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut rates: Value = Value::new_object();
        let mut i: usize = 0;
        while i < data.len() {
            let mut market: Value = data.get(i.into());
            let mut currencies: Value = self.safe_value(market.clone(), Value::from("currencies"), Value::new_array());
            let mut j: usize = 0;
            while j < currencies.len() {
                let mut currency: Value = currencies.get(j.into());
                let mut currency_id: Value = self.safe_string(currency.clone(), Value::from("currency"), Value::Undefined);
                let mut code: Value = Huobi::safe_currency_code(self, currency_id.clone(), Value::from("currency"));
                rates.set(code.clone(), Value::Json(normalize(&Value::Json(json!({
                    "currency": code,
                    "rate": Huobi::safe_number(self, currency.clone(), Value::from("actual-rate"), Value::Undefined),
                    "span": 86400000,
                    "timestamp": timestamp,
                    "datetime": self.iso8601(timestamp.clone()),
                    "info": Value::Undefined
                }))).unwrap()));
                j += 1;
            };
            i += 1;
        };
        return rates.clone();
    }

    /// Returns a list of [funding rate structures](https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure)
    ///
    /// Fetches historical funding rate prices
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified symbol of the market to fetch the funding rate history for
    /// * `since` {int|undefined} - not used by huobi, but filtered internally by ccxt
    /// * `limit` {int|undefined} - not used by huobi, but filtered internally by ccxt
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_funding_rate_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchFundingRateHistory() requires a symbol argument"))"###);
        };
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "contract_code": market.get(Value::from("id"))
        }))).unwrap());
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("inverse")).is_truthy() {
            method = Value::from("contractPublicGetSwapApiV1SwapHistoricalFundingRate");
        } else if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("contractPublicGetLinearSwapApiV1SwapHistoricalFundingRate");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingRateHistory() supports inverse and linear swaps only"))"###);
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // {
        //     "status": "ok",
        //     "data": {
        //         "total_page": 62,
        //         "current_page": 1,
        //         "total_size": 1237,
        //         "data": [
        //             {
        //                 "avg_premium_index": "-0.000208064395065541",
        //                 "funding_rate": "0.000100000000000000",
        //                 "realized_rate": "0.000100000000000000",
        //                 "funding_time": "1638921600000",
        //                 "contract_code": "BTC-USDT",
        //                 "symbol": "BTC",
        //                 "fee_asset": "USDT"
        //             },
        //         ]
        //     },
        //     "ts": 1638939294277
        // }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut result: Value = self.safe_value(data.clone(), Value::from("data"), Value::new_array());
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < result.len() {
            let mut entry: Value = result.get(i.into());
            let mut market_id: Value = self.safe_string(entry.clone(), Value::from("contract_code"), Value::Undefined);
            let mut symbol: Value = Huobi::safe_symbol(self, market_id.clone(), Value::Undefined, Value::Undefined);
            let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("funding_time"), Value::Undefined);
            rates.push(Value::Json(normalize(&Value::Json(json!({
                "info": entry,
                "symbol": symbol,
                "fundingRate": Huobi::safe_number(self, entry.clone(), Value::from("funding_rate"), Value::Undefined),
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone())
            }))).unwrap()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return Huobi::filter_by_symbol_since_limit(self, sorted.clone(), market.get(Value::from("symbol")), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_funding_rate(&self, mut contract: Value, mut market: Value) -> Value {
        //
        // {
        //      "status": "ok",
        //      "data": {
        //         "estimated_rate": "0.000100000000000000",
        //         "funding_rate": "0.000100000000000000",
        //         "contract_code": "BCH-USD",
        //         "symbol": "BCH",
        //         "fee_asset": "BCH",
        //         "funding_time": "1639094400000",
        //         "next_funding_time": "1639123200000"
        //     },
        //     "ts": 1639085854775
        // }
        //
        let mut next_funding_rate: Value = Huobi::safe_number(self, contract.clone(), Value::from("estimated_rate"), Value::Undefined);
        let mut funding_timestamp: Value = self.safe_integer(contract.clone(), Value::from("funding_time"), Value::Undefined);
        let mut next_funding_timestamp: Value = self.safe_integer(contract.clone(), Value::from("next_funding_time"), Value::Undefined);
        let mut market_id: Value = self.safe_string(contract.clone(), Value::from("contract_code"), Value::Undefined);
        let mut symbol: Value = Huobi::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": contract,
            "symbol": symbol,
            "markPrice": Value::Undefined,
            "indexPrice": Value::Undefined,
            "interestRate": Value::Undefined,
            "estimatedSettlePrice": Value::Undefined,
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined,
            "fundingRate": Huobi::safe_number(self, contract.clone(), Value::from("funding_rate"), Value::Undefined),
            "fundingTimestamp": funding_timestamp,
            "fundingDatetime": self.iso8601(funding_timestamp.clone()),
            "nextFundingRate": next_funding_rate,
            "nextFundingTimestamp": next_funding_timestamp,
            "nextFundingDatetime": self.iso8601(next_funding_timestamp.clone()),
            "previousFundingRate": Value::Undefined,
            "previousFundingTimestamp": Value::Undefined,
            "previousFundingDatetime": Value::Undefined
        }))).unwrap());
    }

    /// Returns a [funding rate structure](https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure)
    ///
    /// Fetch the current funding rate
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_funding_rate(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("inverse")).is_truthy() {
            method = Value::from("contractPublicGetSwapApiV1SwapFundingRate");
        } else if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("contractPublicGetLinearSwapApiV1SwapFundingRate");
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchFundingRate() supports inverse and linear swaps only"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "contract_code": market.get(Value::from("id"))
        }))).unwrap());
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // {
        //     "status": "ok",
        //     "data": {
        //         "estimated_rate": "0.000100000000000000",
        //         "funding_rate": "0.000100000000000000",
        //         "contract_code": "BTC-USDT",
        //         "symbol": "BTC",
        //         "fee_asset": "USDT",
        //         "funding_time": "1603699200000",
        //         "next_funding_time": "1603728000000"
        //     },
        //     "ts": 1603696494714
        // }
        //
        let mut result: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        return Huobi::parse_funding_rate(self, result.clone(), market.clone());
    }

    /// Returns a dictionary of [funding rates structures](https://docs.ccxt.com/en/latest/manual.html#funding-rates-structure), indexe by market symbols
    ///
    /// Fetch the funding rate for multiple markets
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_funding_rates(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Huobi::market_symbols(self, symbols.clone());
        let mut options: Value = self.safe_value(self.get("options".into()), Value::from("fetchFundingRates"), Value::new_object());
        let mut default_sub_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultSubType"), Value::from("inverse"));
        let mut sub_type: Value = self.safe_string(options.clone(), Value::from("subType"), default_sub_type.clone());
        sub_type = self.safe_string(params.clone(), Value::from("subType"), sub_type.clone());
        let mut request: Value = Value::new_object();
        // 'contract_code': market['id'],
        let mut method: Value = Huobi::get_supported_mapping(self, sub_type.clone(), Value::Json(normalize(&Value::Json(json!({
            "linear": "contractPublicGetLinearSwapApiV1SwapBatchFundingRate",
            "inverse": "contractPublicGetSwapApiV1SwapBatchFundingRate"
        }))).unwrap()));
        params = self.omit(params.clone(), Value::from("subType"));
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "status": "ok",
        //         "data": [
        //             {
        //                 "estimated_rate": "0.000100000000000000",
        //                 "funding_rate": "0.000100000000000000",
        //                 "contract_code": "MANA-USDT",
        //                 "symbol": "MANA",
        //                 "fee_asset": "USDT",
        //                 "funding_time": "1643356800000",
        //                 "next_funding_time": "1643385600000",
        //                 "trade_partition":"USDT"
        //             },
        //         ],
        //         "ts": 1643346173103
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut result: Value = Huobi::parse_funding_rates(self, data.clone(), Value::Undefined);
        return Huobi::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    /// Returns a list of [borrow interest structures](https://docs.ccxt.com/en/latest/manual.html#borrow-interest-structure)
    ///
    /// Fetch the interest owed by the user for borrowing currency for margin trading
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code
    /// * `symbol` {string|undefined} - unified market symbol when fetch interest in isolated markets
    /// * `since` {int|undefined} - the earliest time in ms to fetch borrrow interest for
    /// * `limit` {int|undefined} - the maximum number of structures to retrieve
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_borrow_interest(&mut self, mut code: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut margin_mode: Value = Value::Undefined;
        (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("fetchBorrowInterest"), params.clone()));
        margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
        let mut request: Value = Value::new_object();
        if since.clone().is_nonnullish() {
            request.set("start-date".into(), self.yyyymmdd(since.clone(), Value::Undefined));
        };
        if limit.clone().is_nonnullish() {
            request.set("size".into(), limit.clone());
        };
        let mut market: Value = Value::Undefined;
        let mut method: Value = Value::Undefined;
        if margin_mode.clone() == Value::from("isolated") {
            method = Value::from("privateGetMarginLoanOrders");
            if symbol.clone().is_nonnullish() {
                market = Huobi::market(self, symbol.clone());
                request.set("symbol".into(), market.get(Value::from("id")));
            };
        } else {
            // Cross
            method = Value::from("privateGetCrossMarginLoanOrders");
            if code.clone().is_nonnullish() {
                let mut currency: Value = Huobi::currency(self, code.clone());
                request.set("currency".into(), currency.get(Value::from("id")));
            };
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "status":"ok",
        //        "data":[
        //            {
        //                "loan-balance":"0.100000000000000000",
        //                "interest-balance":"0.000200000000000000",
        //                "loan-amount":"0.100000000000000000",
        //                "accrued-at":1511169724531,
        //                "interest-amount":"0.000200000000000000",
        //                "filled-points":"0.2",
        //                "filled-ht":"0.2",
        //                "currency":"btc",
        //                "id":394,
        //                "state":"accrual",
        //                "account-id":17747,
        //                "user-id":119913,
        //                "created-at":1511169724531
        //            }
        //        ]
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut interest: Value = Huobi::parse_borrow_interests(self, data.clone(), market.clone());
        return Huobi::filter_by_currency_since_limit(self, interest.clone(), code.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn parse_borrow_interest(&self, mut info: Value, mut market: Value) -> Value {
        // isolated
        //    {
        //        "interest-rate":"0.000040830000000000",
        //        "user-id":35930539,
        //        "account-id":48916071,
        //        "updated-at":1649320794195,
        //        "deduct-rate":"1",
        //        "day-interest-rate":"0.000980000000000000",
        //        "hour-interest-rate":"0.000040830000000000",
        //        "loan-balance":"100.790000000000000000",
        //        "interest-balance":"0.004115260000000000",
        //        "loan-amount":"100.790000000000000000",
        //        "paid-coin":"0.000000000000000000",
        //        "accrued-at":1649320794148,
        //        "created-at":1649320794148,
        //        "interest-amount":"0.004115260000000000",
        //        "deduct-amount":"0",
        //        "deduct-currency":"",
        //        "paid-point":"0.000000000000000000",
        //        "currency":"usdt",
        //        "symbol":"ltcusdt",
        //        "id":20242721,
        //    }
        //
        // cross
        //   {
        //       "id":3416576,
        //       "user-id":35930539,
        //       "account-id":48956839,
        //       "currency":"usdt",
        //       "loan-amount":"102",
        //       "loan-balance":"102",
        //       "interest-amount":"0.00416466",
        //       "interest-balance":"0.00416466",
        //       "created-at":1649322735333,
        //       "accrued-at":1649322735382,
        //       "state":"accrual",
        //       "filled-points":"0",
        //       "filled-ht":"0"
        //   }
        //
        let mut market_id: Value = self.safe_string(info.clone(), Value::from("symbol"), Value::Undefined);
        let mut margin_mode: Value = if market_id.clone().is_nullish() { Value::from("cross") } else { Value::from("isolated") };
        market = Huobi::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        let mut timestamp: Value = Huobi::safe_number(self, info.clone(), Value::from("accrued-at"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "account": if margin_mode.clone() == Value::from("isolated") { symbol.clone() } else { Value::from("cross") },
            "symbol": symbol,
            "marginMode": margin_mode,
            "currency": Huobi::safe_currency_code(self, self.safe_string(info.clone(), Value::from("currency"), Value::Undefined), Value::Undefined),
            "interest": Huobi::safe_number(self, info.clone(), Value::from("interest-amount"), Value::Undefined),
            "interestRate": Huobi::safe_number(self, info.clone(), Value::from("interest-rate"), Value::Undefined),
            "amountBorrowed": Huobi::safe_number(self, info.clone(), Value::from("loan-amount"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    fn sign(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        let mut url: Value = Value::from("/");
        let mut query: Value = self.omit(params.clone(), self.extract_params(path.clone()));
        if api.typeof_() == Value::from("string") {
            // signing implementation for the old endpoints
            if api.clone() == Value::from("market") {
                url = url +  api.clone();
            } else if api.clone() == Value::from("public") || api.clone() == Value::from("private") {
                url = url +  self.get("version".into());
            } else if api.clone() == Value::from("v2Public") || api.clone() == Value::from("v2Private") {
                url = url +  Value::from("v2");
            };
            url = url +  Value::from("/") + self.implode_params(path.clone(), params.clone());
            if api.clone() == Value::from("private") || api.clone() == Value::from("v2Private") {
                Huobi::check_required_credentials(self, Value::Undefined);
                let mut timestamp: Value = self.ymdhms(self.milliseconds(), Value::from("T"));
                let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                    "SignatureMethod": "HmacSHA256",
                    "SignatureVersion": "2",
                    "AccessKeyId": self.get("apiKey".into()),
                    "Timestamp": timestamp
                }))).unwrap());
                if method.clone() != Value::from("POST") {
                    request = extend_2(request.clone(), query.clone());
                };
                request = self.keysort(request.clone(), Value::Undefined);
                let mut auth: Value = self.urlencode(request.clone());
                // unfortunately, PHP demands double quotes for the escaped newline symbol
                let mut payload: Value = Value::Json(serde_json::Value::Array(vec![method.clone().into(), self.get("hostname".into()).into(), url.clone().into(), auth.clone().into()])).join(Value::from("
"));
                // eslint-disable-line quotes
                let mut signature: Value = self.hmac(self.encode(payload.clone()), self.encode(self.get("secret".into())), Value::from("sha256"), Value::from("base64"));
                auth = auth +  Value::from("&") + self.urlencode(Value::Json(normalize(&Value::Json(json!({
                    "Signature": signature
                }))).unwrap()));
                url = url +  Value::from("?") + auth.clone();
                if method.clone() == Value::from("POST") {
                    body = self.json(query.clone(), Value::Undefined);
                    headers = Value::Json(normalize(&Value::Json(json!({
                        "Content-Type": "application/json"
                    }))).unwrap());
                } else {
                    headers = Value::Json(normalize(&Value::Json(json!({
                        "Content-Type": "application/x-www-form-urlencoded"
                    }))).unwrap());
                };
            } else {
                if Object::keys(query.clone()).len() > 0 {
                    url = url +  Value::from("?") + self.urlencode(query.clone());
                };
            };
            url = self.implode_params(self.get("urls".into()).get(Value::from("api")).get(api.clone()), Value::Json(normalize(&Value::Json(json!({
                "hostname": self.get("hostname".into())
            }))).unwrap())) + url.clone();
        } else {
            // signing implementation for the new endpoints
            // const [ type, access ] = api;
            let mut r#type: Value = self.safe_string(api.clone(), Value::from(0), Value::Undefined);
            let mut access: Value = self.safe_string(api.clone(), Value::from(1), Value::Undefined);
            let mut level_one_nested_path: Value = self.safe_string(api.clone(), Value::from(2), Value::Undefined);
            let mut level_two_nested_path: Value = self.safe_string(api.clone(), Value::from(3), Value::Undefined);
            let mut hostname: Value = Value::Undefined;
            let mut hostnames: Value = self.safe_value(self.get("urls".into()).get(Value::from("hostnames")), r#type.clone(), Value::Undefined);
            if hostnames.typeof_() != Value::from("string") {
                hostnames = self.safe_value(hostnames.clone(), level_one_nested_path.clone(), Value::Undefined);
                if hostname.typeof_() != Value::from("string") && level_two_nested_path.clone().is_nonnullish() {
                    hostnames = self.safe_value(hostnames.clone(), level_two_nested_path.clone(), Value::Undefined);
                };
            };
            hostname = hostnames.clone();
            url = url +  self.implode_params(path.clone(), params.clone());
            if access.clone() == Value::from("public") {
                if Object::keys(query.clone()).len() > 0 {
                    url = url +  Value::from("?") + self.urlencode(query.clone());
                };
            } else if access.clone() == Value::from("private") {
                Huobi::check_required_credentials(self, Value::Undefined);
                let mut timestamp: Value = self.ymdhms(self.milliseconds(), Value::from("T"));
                let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                    "SignatureMethod": "HmacSHA256",
                    "SignatureVersion": "2",
                    "AccessKeyId": self.get("apiKey".into()),
                    "Timestamp": timestamp
                }))).unwrap());
                if method.clone() != Value::from("POST") {
                    request = extend_2(request.clone(), query.clone());
                };
                request = self.keysort(request.clone(), Value::Undefined);
                let mut auth: Value = self.urlencode(request.clone());
                // unfortunately, PHP demands double quotes for the escaped newline symbol
                let mut payload: Value = Value::Json(serde_json::Value::Array(vec![method.clone().into(), hostname.clone().into(), url.clone().into(), auth.clone().into()])).join(Value::from("
"));
                // eslint-disable-line quotes
                let mut signature: Value = self.hmac(self.encode(payload.clone()), self.encode(self.get("secret".into())), Value::from("sha256"), Value::from("base64"));
                auth = auth +  Value::from("&") + self.urlencode(Value::Json(normalize(&Value::Json(json!({
                    "Signature": signature
                }))).unwrap()));
                url = url +  Value::from("?") + auth.clone();
                if method.clone() == Value::from("POST") {
                    body = self.json(query.clone(), Value::Undefined);
                    if body.len() == 2 {
                        body = Value::from("{}");
                    };
                    headers = Value::Json(normalize(&Value::Json(json!({
                        "Content-Type": "application/json"
                    }))).unwrap());
                } else {
                    headers = Value::Json(normalize(&Value::Json(json!({
                        "Content-Type": "application/x-www-form-urlencoded"
                    }))).unwrap());
                };
            };
            url = self.implode_params(self.get("urls".into()).get(Value::from("api")).get(r#type.clone()), Value::Json(normalize(&Value::Json(json!({
                "hostname": hostname
            }))).unwrap())) + url.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "url": url,
            "method": method,
            "body": body,
            "headers": headers
        }))).unwrap());
    }

    fn handle_errors(&mut self, mut http_code: Value, mut reason: Value, mut url: Value, mut method: Value, mut headers: Value, mut body: Value, mut response: Value, mut request_headers: Value, mut request_body: Value) -> Value {
        if response.clone().is_nullish() {
            return Value::Undefined;
        };
        // fallback to default error handler
        if response.contains_key(Value::from("status")) {
            //
            //     {"status":"error","err-code":"order-limitorder-amount-min-error","err-msg":"limit order amount error, min: `0.001`","data":null}
            //
            let mut status: Value = self.safe_string(response.clone(), Value::from("status"), Value::Undefined);
            if status.clone() == Value::from("error") {
                let mut code: Value = self.safe_string_2(response.clone(), Value::from("err-code"), Value::from("err_code"), Value::Undefined);
                let mut feedback: Value = self.get("id".into()) + Value::from(" ") + body.clone();
                Huobi::throw_broadly_matched_exception(self, self.get("exceptions".into()).get(Value::from("broad")), body.clone(), feedback.clone());
                Huobi::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), code.clone(), feedback.clone());
                let mut message: Value = self.safe_string_2(response.clone(), Value::from("err-msg"), Value::from("err_msg"), Value::Undefined);
                Huobi::throw_exactly_matched_exception(self, self.get("exceptions".into()).get(Value::from("exact")), message.clone(), feedback.clone());
                panic!(r###"ExchangeError::new(feedback)"###);
            };
        };
        Value::Undefined
    }

    /// Returns a [funding history structure](https://docs.ccxt.com/en/latest/manual.html#funding-history-structure)
    ///
    /// Fetch the history of funding payments paid and received on this account
    ///
    /// # Arguments
    ///
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `since` {int|undefined} - the earliest time in ms to fetch funding history for
    /// * `limit` {int|undefined} - the maximum number of funding history structures to retrieve
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_funding_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let (mut market_type, mut query) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchFundingHistory"), market.clone(), params.clone()));
        let mut method: Value = Value::Undefined;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "type": "30,31"
        }))).unwrap());
        if market.get(Value::from("linear")).is_truthy() {
            method = Value::from("contractPrivatePostLinearSwapApiV1SwapFinancialRecordExact");
            //
            // {
            //   status: 'ok',
            //   data: {
            //     financial_record: [
            //       {
            //         id: '1320088022',
            //         type: '30',
            //         amount: '0.004732510000000000',
            //         ts: '1641168019321',
            //         contract_code: 'BTC-USDT',
            //         asset: 'USDT',
            //         margin_account: 'BTC-USDT',
            //         face_margin_account: ''
            //       },
            //     ],
            //     remain_size: '0',
            //     next_id: null
            //   },
            //   ts: '1641189898425'
            // }
            let mut margin_mode: Value = Value::Undefined;
            (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("fetchFundingHistory"), params.clone()));
            margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
            if margin_mode.clone() == Value::from("isolated") {
                request.set("margin_account".into(), market.get(Value::from("id")));
            } else {
                request.set("margin_account".into(), market.get(Value::from("quoteId")));
            };
        } else {
            if market_type.clone() == Value::from("swap") {
                method = Value::from("contractPrivatePostSwapApiV1SwapFinancialRecordExact");
                request.set("contract_code".into(), market.get(Value::from("id")));
            } else {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchFundingHistory() only makes sense for swap contracts"))"###);
            };
        };
        //
        // swap
        //     {
        //       status: 'ok',
        //       data: {
        //         financial_record: [
        //           {
        //             id: '1667436164',
        //             symbol: 'BTC',
        //             type: '30',
        //             amount: '3.9755491985E-8',
        //             ts: '1641168097323',
        //             contract_code: 'BTC-USD'
        //           },
        //         ],
        //         remain_size: '0',
        //         next_id: null
        //       },
        //       ts: '1641190296379'
        //     }
        //
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_object());
        let mut financial_record: Value = self.safe_value(data.clone(), Value::from("financial_record"), Value::new_array());
        return Huobi::parse_incomes(self, financial_record.clone(), market.clone(), since.clone(), limit.clone());
    }

    /// Returns response from the exchange
    ///
    /// Set the level of leverage for a market
    ///
    /// # Arguments
    ///
    /// * `leverage` {float} - the rate of leverage
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn set_leverage(&mut self, mut leverage: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" setLeverage() requires a symbol argument"))"###);
        };
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let (mut market_type, mut query) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("setLeverage"), market.clone(), params.clone()));
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("linear")).is_truthy() {
            let mut margin_mode: Value = Value::Undefined;
            (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("setLeverage"), params.clone()));
            margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
            method = Huobi::get_supported_mapping(self, margin_mode.clone(), Value::Json(normalize(&Value::Json(json!({
                "isolated": "contractPrivatePostLinearSwapApiV1SwapSwitchLeverRate",
                "cross": "contractPrivatePostLinearSwapApiV1SwapCrossSwitchLeverRate"
            }))).unwrap()));
        } else {
            //
            //     {
            //       status: 'ok',
            //       data: {
            //         contract_code: 'BTC-USDT',
            //         lever_rate: '100',
            //         margin_mode: 'isolated'
            //       },
            //       ts: '1641184710649'
            //     }
            //
            method = Huobi::get_supported_mapping(self, market_type.clone(), Value::Json(normalize(&Value::Json(json!({
                "future": "contractPrivatePostApiV1ContractSwitchLeverRate",
                "swap": "contractPrivatePostSwapApiV1SwapSwitchLeverRate"
            }))).unwrap()));
        };
        //
        // future
        //     {
        //       status: 'ok',
        //       data: { symbol: 'BTC', lever_rate: 5 },
        //       ts: 1641184578678
        //     }
        //
        // swap
        //
        //     {
        //       status: 'ok',
        //       data: { contract_code: 'BTC-USD', lever_rate: '5' },
        //       ts: '1641184652979'
        //     }
        //
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "lever_rate": leverage
        }))).unwrap());
        if market_type.clone() == Value::from("future") && market.get(Value::from("inverse")).is_truthy() {
            request.set("symbol".into(), market.get(Value::from("settleId")));
        } else {
            request.set("contract_code".into(), market.get(Value::from("id")));
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        return response.clone();
    }

    fn parse_income(&self, mut income: Value, mut market: Value) -> Value {
        //
        //     {
        //       id: '1667161118',
        //       symbol: 'BTC',
        //       type: '31',
        //       amount: '-2.11306593188E-7',
        //       ts: '1641139308983',
        //       contract_code: 'BTC-USD'
        //     }
        //
        let mut market_id: Value = self.safe_string(income.clone(), Value::from("contract_code"), Value::Undefined);
        let mut symbol: Value = Huobi::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined);
        let mut amount: Value = Huobi::safe_number(self, income.clone(), Value::from("amount"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(income.clone(), Value::from("ts"), Value::Undefined);
        let mut id: Value = self.safe_string(income.clone(), Value::from("id"), Value::Undefined);
        let mut currency_id: Value = self.safe_string_2(income.clone(), Value::from("symbol"), Value::from("asset"), Value::Undefined);
        let mut code: Value = Huobi::safe_currency_code(self, currency_id.clone(), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": income,
            "symbol": symbol,
            "code": code,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "id": id,
            "amount": amount
        }))).unwrap());
    }

    fn parse_incomes(&self, mut incomes: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < incomes.len() {
            let mut entry: Value = incomes.get(i.into());
            let mut parsed: Value = Huobi::parse_income(self, entry.clone(), market.clone());
            result.push(parsed.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from("timestamp"), Value::Undefined);
    }

    fn parse_position(&self, mut position: Value, mut market: Value) -> Value {
        //
        //     {
        //       symbol: 'BTC',
        //       contract_code: 'BTC-USDT',
        //       volume: '1.000000000000000000',
        //       available: '1.000000000000000000',
        //       frozen: '0E-18',
        //       cost_open: '47162.000000000000000000',
        //       cost_hold: '47151.300000000000000000',
        //       profit_unreal: '0.007300000000000000',
        //       profit_rate: '-0.000144183876850008',
        //       lever_rate: '2',
        //       position_margin: '23.579300000000000000',
        //       direction: 'buy',
        //       profit: '-0.003400000000000000',
        //       last_price: '47158.6',
        //       margin_asset: 'USDT',
        //       margin_mode: 'isolated',
        //       margin_account: 'BTC-USDT',
        //       margin_balance: '24.973020070000000000',
        //       margin_position: '23.579300000000000000',
        //       margin_frozen: '0',
        //       margin_available: '1.393720070000000000',
        //       profit_real: '0E-18',
        //       risk_rate: '1.044107779705080303',
        //       withdraw_available: '1.386420070000000000000000000000000000',
        //       liquidation_price: '22353.229148614609571788',
        //       adjust_factor: '0.015000000000000000',
        //       margin_static: '24.965720070000000000'
        //     }
        //
        market = Huobi::safe_market(self, self.safe_string(position.clone(), Value::from("contract_code"), Value::Undefined), Value::Undefined, Value::Undefined);
        let mut symbol: Value = market.get(Value::from("symbol"));
        let mut contracts: Value = self.safe_string(position.clone(), Value::from("volume"), Value::Undefined);
        let mut contract_size: Value = self.safe_value(market.clone(), Value::from("contractSize"), Value::Undefined);
        let mut contract_size_string: Value = self.number_to_string(contract_size.clone());
        let mut entry_price: Value = Huobi::safe_number(self, position.clone(), Value::from("cost_open"), Value::Undefined);
        let mut initial_margin: Value = self.safe_string(position.clone(), Value::from("position_margin"), Value::Undefined);
        let mut raw_side: Value = self.safe_string(position.clone(), Value::from("direction"), Value::Undefined);
        let mut side: Value = if raw_side.clone() == Value::from("buy") { Value::from("long") } else { Value::from("short") };
        let mut unrealized_profit: Value = Huobi::safe_number(self, position.clone(), Value::from("profit_unreal"), Value::Undefined);
        let mut margin_mode: Value = self.safe_string(position.clone(), Value::from("margin_mode"), Value::Undefined);
        let mut leverage: Value = self.safe_string(position.clone(), Value::from("lever_rate"), Value::Undefined);
        let mut percentage: Value = Precise::string_mul(self.safe_string(position.clone(), Value::from("profit_rate"), Value::Undefined), Value::from("100"));
        let mut last_price: Value = self.safe_string(position.clone(), Value::from("last_price"), Value::Undefined);
        let mut face_value: Value = Precise::string_mul(contracts.clone(), contract_size_string.clone());
        let mut notional: Value = Value::Undefined;
        if market.get(Value::from("linear")).is_truthy() {
            notional = Precise::string_mul(face_value.clone(), last_price.clone());
        } else {
            notional = Precise::string_div(face_value.clone(), last_price.clone(), Value::Undefined);
            margin_mode = Value::from("cross");
        };
        let mut intial_margin_percentage: Value = Precise::string_div(initial_margin.clone(), notional.clone(), Value::Undefined);
        let mut collateral: Value = self.safe_string(position.clone(), Value::from("margin_balance"), Value::Undefined);
        let mut liquidation_price: Value = Huobi::safe_number(self, position.clone(), Value::from("liquidation_price"), Value::Undefined);
        let mut adjustment_factor: Value = self.safe_string(position.clone(), Value::from("adjust_factor"), Value::Undefined);
        let mut maintenance_margin_percentage: Value = Precise::string_div(adjustment_factor.clone(), leverage.clone(), Value::Undefined);
        let mut maintenance_margin: Value = Precise::string_mul(maintenance_margin_percentage.clone(), notional.clone());
        let mut margin_ratio: Value = Precise::string_div(maintenance_margin.clone(), collateral.clone(), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": position,
            "symbol": symbol,
            "contracts": self.parse_number(contracts.clone(), Value::Undefined),
            "contractSize": contract_size,
            "entryPrice": entry_price,
            "collateral": self.parse_number(collateral.clone(), Value::Undefined),
            "side": side,
            "unrealizedProfit": unrealized_profit,
            "leverage": self.parse_number(leverage.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "marginMode": margin_mode,
            "notional": self.parse_number(notional.clone(), Value::Undefined),
            "markPrice": Value::Undefined,
            "liquidationPrice": liquidation_price,
            "initialMargin": self.parse_number(initial_margin.clone(), Value::Undefined),
            "initialMarginPercentage": self.parse_number(intial_margin_percentage.clone(), Value::Undefined),
            "maintenanceMargin": self.parse_number(maintenance_margin.clone(), Value::Undefined),
            "maintenanceMarginPercentage": self.parse_number(maintenance_margin_percentage.clone(), Value::Undefined),
            "marginRatio": self.parse_number(margin_ratio.clone(), Value::Undefined),
            "timestamp": Value::Undefined,
            "datetime": Value::Undefined
        }))).unwrap());
    }

    /// Returns a list of [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch all open positions
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_positions(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        symbols = Huobi::market_symbols(self, symbols.clone());
        let mut margin_mode: Value = Value::Undefined;
        (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("fetchPositions"), params.clone()));
        margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
        let mut default_sub_type: Value = self.safe_string(self.get("options".into()), Value::from("defaultSubType"), Value::from("inverse"));
        let mut market_type: Value = Value::Undefined;
        (market_type, params) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchPositions"), Value::Undefined, params.clone()));
        if market_type.clone() == Value::from("spot") {
            market_type = Value::from("future");
        };
        let mut method: Value = Value::Undefined;
        if default_sub_type.clone() == Value::from("linear") {
            method = Huobi::get_supported_mapping(self, margin_mode.clone(), Value::Json(normalize(&Value::Json(json!({
                "isolated": "contractPrivatePostLinearSwapApiV1SwapPositionInfo",
                "cross": "contractPrivatePostLinearSwapApiV1SwapCrossPositionInfo"
            }))).unwrap()));
        } else {
            //
            //     {
            //       status: 'ok',
            //       data: [
            //         {
            //           symbol: 'BTC',
            //           contract_code: 'BTC-USDT',
            //           volume: '1.000000000000000000',
            //           available: '1.000000000000000000',
            //           frozen: '0E-18',
            //           cost_open: '47162.000000000000000000',
            //           cost_hold: '47162.000000000000000000',
            //           profit_unreal: '0.047300000000000000',
            //           profit_rate: '0.002005852169119206',
            //           lever_rate: '2',
            //           position_margin: '23.604650000000000000',
            //           direction: 'buy',
            //           profit: '0.047300000000000000',
            //           last_price: '47209.3',
            //           margin_asset: 'USDT',
            //           margin_mode: 'isolated',
            //           margin_account: 'BTC-USDT'
            //         }
            //       ],
            //       ts: '1641108676768'
            //     }
            //
            method = Huobi::get_supported_mapping(self, market_type.clone(), Value::Json(normalize(&Value::Json(json!({
                "future": "contractPrivatePostApiV1ContractPositionInfo",
                "swap": "contractPrivatePostSwapApiV1SwapPositionInfo"
            }))).unwrap()));
        };
        //
        // future
        //     {
        //       status: 'ok',
        //       data: [
        //         {
        //           symbol: 'BTC',
        //           contract_code: 'BTC220624',
        //           contract_type: 'next_quarter',
        //           volume: '1.000000000000000000',
        //           available: '1.000000000000000000',
        //           frozen: '0E-18',
        //           cost_open: '49018.880000000009853343',
        //           cost_hold: '49018.880000000009853343',
        //           profit_unreal: '-8.62360608500000000000000000000000000000000000000E-7',
        //           profit_rate: '-0.000845439023678622',
        //           lever_rate: '2',
        //           position_margin: '0.001019583964880634',
        //           direction: 'sell',
        //           profit: '-8.62360608500000000000000000000000000000000000000E-7',
        //           last_price: '49039.61'
        //         }
        //       ],
        //       ts: '1641109895199'
        //     }
        //
        // swap
        //     {
        //       status: 'ok',
        //       data: [
        //         {
        //           symbol: 'BTC',
        //           contract_code: 'BTC-USD',
        //           volume: '1.000000000000000000',
        //           available: '1.000000000000000000',
        //           frozen: '0E-18',
        //           cost_open: '47150.000000000012353300',
        //           cost_hold: '47150.000000000012353300',
        //           profit_unreal: '0E-54',
        //           profit_rate: '-7.86E-16',
        //           lever_rate: '3',
        //           position_margin: '0.000706963591375044',
        //           direction: 'buy',
        //           profit: '0E-54',
        //           last_price: '47150'
        //         }
        //       ],
        //       ts: '1641109636572'
        //     }
        //
        let mut response: Value = Huobi::dispatch(self, method, params.clone(), Value::Undefined).await;
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        let mut timestamp: Value = self.safe_integer(response.clone(), Value::from("ts"), Value::Undefined);
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < data.len() {
            let mut position: Value = data.get(i.into());
            let mut parsed: Value = Huobi::parse_position(self, position.clone(), Value::Undefined);
            result.push(extend_2(parsed.clone(), Value::Json(normalize(&Value::Json(json!({
                "timestamp": timestamp,
                "datetime": self.iso8601(timestamp.clone())
            }))).unwrap())));
            i += 1;
        };
        return Huobi::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    /// Returns a [position structure](https://docs.ccxt.com/en/latest/manual.html#position-structure)
    ///
    /// Fetch data on a single open contract trade position
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol of the market the position is held in, default is undefined
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_position(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut market: Value = Huobi::market(self, symbol.clone());
        let mut margin_mode: Value = Value::Undefined;
        (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("fetchPosition"), params.clone()));
        margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
        let (mut market_type, mut query) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchPosition"), market.clone(), params.clone()));
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("linear")).is_truthy() {
            method = Huobi::get_supported_mapping(self, margin_mode.clone(), Value::Json(normalize(&Value::Json(json!({
                "isolated": "contractPrivatePostLinearSwapApiV1SwapAccountPositionInfo",
                "cross": "contractPrivatePostLinearSwapApiV1SwapCrossAccountPositionInfo"
            }))).unwrap()));
        } else {
            //
            // isolated
            //
            //     {
            //         "status": "ok",
            //         "data": [
            //             {
            //                 "positions": [],
            //                 "symbol": "BTC",
            //                 "margin_balance": 1.949728350000000000,
            //                 "margin_position": 0,
            //                 "margin_frozen": 0E-18,
            //                 "margin_available": 1.949728350000000000,
            //                 "profit_real": -0.050271650000000000,
            //                 "profit_unreal": 0,
            //                 "risk_rate": null,
            //                 "withdraw_available": 1.949728350000000000,
            //                 "liquidation_price": null,
            //                 "lever_rate": 20,
            //                 "adjust_factor": 0.150000000000000000,
            //                 "margin_static": 1.949728350000000000,
            //                 "contract_code": "BTC-USDT",
            //                 "margin_asset": "USDT",
            //                 "margin_mode": "isolated",
            //                 "margin_account": "BTC-USDT",
            //                 "trade_partition": "USDT",
            //                 "position_mode": "dual_side"
            //             },
            //             ... opposite side position can be present here too (if hedge)
            //         ],
            //         "ts": 1653605008286
            //     }
            //
            // cross
            //
            //     {
            //         "status": "ok",
            //         "data": {
            //             "positions": [
            //                 {
            //                     "symbol": "BTC",
            //                     "contract_code": "BTC-USDT",
            //                     "volume": "1.000000000000000000",
            //                     "available": "1.000000000000000000",
            //                     "frozen": "0E-18",
            //                     "cost_open": "29530.000000000000000000",
            //                     "cost_hold": "29530.000000000000000000",
            //                     "profit_unreal": "-0.010000000000000000",
            //                     "profit_rate": "-0.016931933626820200",
            //                     "lever_rate": "50",
            //                     "position_margin": "0.590400000000000000",
            //                     "direction": "buy",
            //                     "profit": "-0.010000000000000000",
            //                     "last_price": "29520",
            //                     "margin_asset": "USDT",
            //                     "margin_mode": "cross",
            //                     "margin_account": "USDT",
            //                     "contract_type": "swap",
            //                     "pair": "BTC-USDT",
            //                     "business_type": "swap",
            //                     "trade_partition": "USDT",
            //                     "position_mode": "dual_side"
            //                 },
            //                 ... opposite side position can be present here too (if hedge)
            //             ],
            //             "futures_contract_detail": [
            //                 {
            //                     "symbol": "BTC",
            //                     "contract_code": "BTC-USDT-220624",
            //                     "margin_position": "0",
            //                     "margin_frozen": "0E-18",
            //                     "margin_available": "1.497799766913531118",
            //                     "profit_unreal": "0",
            //                     "liquidation_price": null,
            //                     "lever_rate": "30",
            //                     "adjust_factor": "0.250000000000000000",
            //                     "contract_type": "quarter",
            //                     "pair": "BTC-USDT",
            //                     "business_type": "futures",
            //                     "trade_partition": "USDT"
            //                 },
            //                 ... other items listed with different expiration (contract_code)
            //             ],
            //             "margin_mode": "cross",
            //             "margin_account": "USDT",
            //             "margin_asset": "USDT",
            //             "margin_balance": "2.088199766913531118",
            //             "margin_static": "2.098199766913531118",
            //             "margin_position": "0.590400000000000000",
            //             "margin_frozen": "0E-18",
            //             "profit_real": "-0.016972710000000000",
            //             "profit_unreal": "-0.010000000000000000",
            //             "withdraw_available": "1.497799766913531118",
            //             "risk_rate": "9.105496355562965147",
            //             "contract_detail": [
            //                {
            //                     "symbol": "BTC",
            //                     "contract_code": "BTC-USDT",
            //                     "margin_position": "0.590400000000000000",
            //                     "margin_frozen": "0E-18",
            //                     "margin_available": "1.497799766913531118",
            //                     "profit_unreal": "-0.010000000000000000",
            //                     "liquidation_price": "27625.176468365024050352",
            //                     "lever_rate": "50",
            //                     "adjust_factor": "0.350000000000000000",
            //                     "contract_type": "swap",
            //                     "pair": "BTC-USDT",
            //                     "business_type": "swap",
            //                     "trade_partition": "USDT"
            //                 },
            //                 ... all symbols listed
            //             ],
            //             "position_mode": "dual_side"
            //         },
            //         "ts": "1653604697466"
            //     }
            //
            method = Huobi::get_supported_mapping(self, market_type.clone(), Value::Json(normalize(&Value::Json(json!({
                "future": "contractPrivatePostApiV1ContractAccountPositionInfo",
                "swap": "contractPrivatePostSwapApiV1SwapAccountPositionInfo"
            }))).unwrap()));
        };
        //
        // future, swap
        //
        //     {
        //       "status": "ok",
        //       "data": [
        //         {
        //             "symbol": "XRP",
        //             "contract_code": "XRP-USD", // only present in swap
        //             "margin_balance": 12.186361450698276582,
        //             "margin_position": 5.036261079774375503,
        //             "margin_frozen": 0E-18,
        //             "margin_available": 7.150100370923901079,
        //             "profit_real": -0.012672343876723438,
        //             "profit_unreal": 0.163382354575000020,
        //             "risk_rate": 2.344723929650649798,
        //             "withdraw_available": 6.986718016348901059,
        //             "liquidation_price": 0.271625200493799547,
        //             "lever_rate": 5,
        //             "adjust_factor": 0.075000000000000000,
        //             "margin_static": 12.022979096123276562,
        //             "positions": [
        //                 {
        //                     "symbol": "XRP",
        //                     "contract_code": "XRP-USD",
        //                     // "contract_type": "this_week", // only present in future
        //                     "volume": 1.0,
        //                     "available": 1.0,
        //                     "frozen": 0E-18,
        //                     "cost_open": 0.394560000000000000,
        //                     "cost_hold": 0.394560000000000000,
        //                     "profit_unreal": 0.163382354575000020,
        //                     "profit_rate": 0.032232070910556005,
        //                     "lever_rate": 5,
        //                     "position_margin": 5.036261079774375503,
        //                     "direction": "buy",
        //                     "profit": 0.163382354575000020,
        //                     "last_price": 0.39712
        //                 },
        //                 ... opposite side position can be present here too (if hedge)
        //             ]
        //         }
        //       ],
        //       "ts": 1653600470199
        //     }
        //
        // cross usdt swap
        //
        //     {
        //         "status":"ok",
        //         "data":{
        //             "positions":[],
        //             "futures_contract_detail":[]
        //             "margin_mode":"cross",
        //             "margin_account":"USDT",
        //             "margin_asset":"USDT",
        //             "margin_balance":"1.000000000000000000",
        //             "margin_static":"1.000000000000000000",
        //             "margin_position":"0",
        //             "margin_frozen":"1.000000000000000000",
        //             "profit_real":"0E-18",
        //             "profit_unreal":"0",
        //             "withdraw_available":"0",
        //             "risk_rate":"15.666666666666666666",
        //             "contract_detail":[]
        //         },
        //         "ts":"1645521118946"
        //     }
        //
        let mut request: Value = Value::new_object();
        if market.get(Value::from("future")).is_truthy() && market.get(Value::from("inverse")).is_truthy() {
            request.set("symbol".into(), market.get(Value::from("settleId")));
        } else {
            if margin_mode.clone() == Value::from("cross") {
                request.set("margin_account".into(), Value::from("USDT"));
            };
            // only allowed value
            request.set("contract_code".into(), market.get(Value::from("id")));
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut account: Value = Value::Undefined;
        if margin_mode.clone() == Value::from("cross") {
            account = data.clone();
        } else {
            account = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        };
        let mut omitted: Value = self.omit(account.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("positions").into()])));
        let mut positions: Value = self.safe_value(account.clone(), Value::from("positions"), Value::Undefined);
        let mut position: Value = Value::Undefined;
        if market.get(Value::from("future")).is_truthy() && market.get(Value::from("inverse")).is_truthy() {
            let mut i: usize = 0;
            while i < positions.len() {
                let mut entry: Value = positions.get(i.into());
                if entry.get(Value::from("contract_code")) == market.get(Value::from("id")) {
                    position = entry.clone();
                    break;
                };
                i += 1;
            };
        } else {
            position = self.safe_value(positions.clone(), Value::from(0), Value::Undefined);
        };
        let mut timestamp: Value = self.safe_integer(response.clone(), Value::from("ts"), Value::Undefined);
        let mut parsed: Value = Huobi::parse_position(self, extend_2(position.clone(), omitted.clone()), Value::Undefined);
        return extend_2(parsed.clone(), Value::Json(normalize(&Value::Json(json!({
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone())
        }))).unwrap()));
    }

    fn parse_ledger_entry_type(&self, mut r#type: Value) -> Value {
        let mut types: Value = Value::Json(normalize(&Value::Json(json!({
            "trade": "trade",
            "etf": "trade",
            "transact-fee": "fee",
            "fee-deduction": "fee",
            "transfer": "transfer",
            "credit": "credit",
            "liquidation": "trade",
            "interest": "credit",
            "deposit": "deposit",
            "withdraw": "withdrawal",
            "withdraw-fee": "fee",
            "exchange": "exchange",
            "other-types": "transfer",
            "rebate": "rebate"
        }))).unwrap());
        return self.safe_string(types.clone(), r#type.clone(), r#type.clone());
    }

    fn parse_ledger_entry(&self, mut item: Value, mut currency: Value) -> Value {
        //
        //     {
        //         "accountId": 10000001,
        //         "currency": "usdt",
        //         "transactAmt": 10.000000000000000000,
        //         "transactType": "transfer",
        //         "transferType": "margin-transfer-out",
        //         "transactId": 0,
        //         "transactTime": 1629882331066,
        //         "transferer": 28483123,
        //         "transferee": 13496526
        //     }
        //
        let mut id: Value = self.safe_string(item.clone(), Value::from("transactId"), Value::Undefined);
        let mut currency_id: Value = self.safe_string(item.clone(), Value::from("currency"), Value::Undefined);
        let mut code: Value = Huobi::safe_currency_code(self, currency_id.clone(), currency.clone());
        let mut amount: Value = Huobi::safe_number(self, item.clone(), Value::from("transactAmt"), Value::Undefined);
        let mut transfer_type: Value = self.safe_string(item.clone(), Value::from("transferType"), Value::Undefined);
        let mut r#type: Value = Huobi::parse_ledger_entry_type(self, transfer_type.clone());
        let mut direction: Value = self.safe_string(item.clone(), Value::from("direction"), Value::Undefined);
        let mut timestamp: Value = self.safe_integer(item.clone(), Value::from("transactTime"), Value::Undefined);
        let mut datetime: Value = self.iso8601(timestamp.clone());
        let mut account: Value = self.safe_string(item.clone(), Value::from("accountId"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": id,
            "direction": direction,
            "account": account,
            "referenceId": id,
            "referenceAccount": account,
            "type": r#type,
            "currency": code,
            "amount": amount,
            "timestamp": timestamp,
            "datetime": datetime,
            "before": Value::Undefined,
            "after": Value::Undefined,
            "status": Value::Undefined,
            "fee": Value::Undefined,
            "info": item
        }))).unwrap());
    }

    /// Returns a [ledger structure](https://docs.ccxt.com/en/latest/manual.html#ledger-structure)
    ///
    /// Fetch the history of changes, actions done by the user or operations that altered balance of the user
    ///
    /// # Arguments
    ///
    /// * `code` {string|undefined} - unified currency code, default is undefined
    /// * `since` {int|undefined} - timestamp in ms of the earliest ledger entry, default is undefined
    /// * `limit` {int|undefined} - max number of ledger entrys to return, default is undefined
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_ledger(&mut self, mut code: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut account_id: Value = Huobi::fetch_account_id_by_type(self, Value::from("spot"), params.clone()).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "accountId": account_id
        }))).unwrap());
        // 'currency': code,
        // 'transactTypes': 'all', // default all
        // 'startTime': 1546272000000,
        // 'endTime': 1546272000000,
        // 'sort': asc, // asc, desc
        // 'limit': 100, // range 1-500
        // 'fromId': 323 // first record ID in this query for pagination
        let mut currency: Value = Value::Undefined;
        if code.clone().is_nonnullish() {
            currency = Huobi::currency(self, code.clone());
            request.set("currency".into(), currency.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("startTime".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("limit".into(), limit.clone());
        };
        // max 500
        let mut response: Value = Huobi::dispatch(self, "spotPrivateGetV2AccountLedger".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code": 200,
        //         "message": "success",
        //         "data": [
        //             {
        //                 "accountId": 10000001,
        //                 "currency": "usdt",
        //                 "transactAmt": 10.000000000000000000,
        //                 "transactType": "transfer",
        //                 "transferType": "margin-transfer-out",
        //                 "transactId": 0,
        //                 "transactTime": 1629882331066,
        //                 "transferer": 28483123,
        //                 "transferee": 13496526
        //             },
        //             {
        //                 "accountId": 10000001,
        //                 "currency": "usdt",
        //                 "transactAmt": -10.000000000000000000,
        //                 "transactType": "transfer",
        //                 "transferType": "margin-transfer-in",
        //                 "transactId": 0,
        //                 "transactTime": 1629882096562,
        //                 "transferer": 13496526,
        //                 "transferee": 28483123
        //             }
        //         ],
        //         "nextId": 1624316679,
        //         "ok": true
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::new_array());
        return Huobi::parse_ledger(self, data.clone(), currency.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a dictionary of [leverage tiers structures](https://docs.ccxt.com/en/latest/manual.html#leverage-tiers-structure), indexed by market symbols
    ///
    /// Retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
    ///
    /// # Arguments
    ///
    /// * `symbols` {[string]|undefined} - list of unified market symbols
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_leverage_tiers(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut response: Value = Huobi::dispatch(self, "contractPublicGetLinearSwapApiV1SwapAdjustfactor".into(), params.clone(), Value::Undefined).await;
        //
        //    {
        //        "status": "ok",
        //        "data": [
        //            {
        //                "symbol": "MANA",
        //                "contract_code": "MANA-USDT",
        //                "margin_mode": "isolated",
        //                "trade_partition": "USDT",
        //                "list": [
        //                    {
        //                        "lever_rate": 75,
        //                        "ladders": [
        //                            {
        //                                "ladder": 0,
        //                                "min_size": 0,
        //                                "max_size": 999,
        //                                "adjust_factor": 0.7
        //                            },
        //                            ...
        //                        ]
        //                    }
        //                    ...
        //                ]
        //            },
        //            ...
        //        ]
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        return Huobi::parse_leverage_tiers(self, data.clone(), symbols.clone(), Value::from("contract_code"));
    }

    /// Returns a [leverage tiers structure](https://docs.ccxt.com/en/latest/manual.html#leverage-tiers-structure)
    ///
    /// Retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified market symbol
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn fetch_market_leverage_tiers(&mut self, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut request: Value = Value::new_object();
        if symbol.clone().is_nonnullish() {
            let mut market: Value = Huobi::market(self, symbol.clone());
            if !market.get(Value::from("contract")).is_truthy() {
                panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchMarketLeverageTiers() symbol supports contract markets only"))"###);
            };
            request.set("contract_code".into(), market.get(Value::from("id")));
        };
        let mut response: Value = Huobi::dispatch(self, "contractPublicGetLinearSwapApiV1SwapAdjustfactor".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //    {
        //        "status": "ok",
        //        "data": [
        //            {
        //                "symbol": "MANA",
        //                "contract_code": "MANA-USDT",
        //                "margin_mode": "isolated",
        //                "trade_partition": "USDT",
        //                "list": [
        //                    {
        //                        "lever_rate": 75,
        //                        "ladders": [
        //                            {
        //                                "ladder": 0,
        //                                "min_size": 0,
        //                                "max_size": 999,
        //                                "adjust_factor": 0.7
        //                            },
        //                            ...
        //                        ]
        //                    }
        //                    ...
        //                ]
        //            },
        //            ...
        //        ]
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut tiers: Value = Huobi::parse_leverage_tiers(self, data.clone(), Value::Json(serde_json::Value::Array(vec![symbol.clone().into()])), Value::from("contract_code"));
        return self.safe_value(tiers.clone(), symbol.clone(), Value::Undefined);
    }

    fn parse_leverage_tiers(&self, mut response: Value, mut symbols: Value, mut market_id_key: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut item: Value = response.get(i.into());
            let mut list: Value = self.safe_value(item.clone(), Value::from("list"), Value::new_array());
            let mut tiers: Value = Value::new_array();
            let mut currency: Value = self.safe_string(item.clone(), Value::from("trade_partition"), Value::Undefined);
            let mut id: Value = self.safe_string(item.clone(), market_id_key.clone(), Value::Undefined);
            let mut symbol: Value = Huobi::safe_symbol(self, id.clone(), Value::Undefined, Value::Undefined);
            if self.in_array(symbols.clone(), symbol.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < list.len() {
                    let mut obj: Value = list.get(j.into());
                    let mut leverage: Value = self.safe_string(obj.clone(), Value::from("lever_rate"), Value::Undefined);
                    let mut ladders: Value = self.safe_value(obj.clone(), Value::from("ladders"), Value::new_array());
                    let mut k: usize = 0;
                    while k < ladders.len() {
                        let mut bracket: Value = ladders.get(k.into());
                        let mut adjust_factor: Value = self.safe_string(bracket.clone(), Value::from("adjust_factor"), Value::Undefined);
                        tiers.push(Value::Json(normalize(&Value::Json(json!({
                            "tier": self.safe_integer(bracket.clone(), Value::from("ladder"), Value::Undefined),
                            "currency": Huobi::safe_currency_code(self, currency.clone(), Value::Undefined),
                            "minNotional": Huobi::safe_number(self, bracket.clone(), Value::from("min_size"), Value::Undefined),
                            "maxNotional": Huobi::safe_number(self, bracket.clone(), Value::from("max_size"), Value::Undefined),
                            "maintenanceMarginRate": self.parse_number(Precise::string_div(adjust_factor.clone(), leverage.clone(), Value::Undefined), Value::Undefined),
                            "maxLeverage": self.parse_number(leverage.clone(), Value::Undefined),
                            "info": bracket
                        }))).unwrap()));
                        k += 1;
                    };
                    j += 1;
                };
                result.set(symbol.clone(), tiers.clone());
            };
            i += 1;
        };
        return result.clone();
    }

    /// Returns an array of [open interest structures](https://docs.ccxt.com/en/latest/manual.html#open-interest-structure)
    ///
    /// Retrieves the open intestest history of a currency
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - Unified CCXT market symbol
    /// * `timeframe` {string} - '1h', '4h', '12h', or '1d'
    /// * `since` {int|undefined} - Not used by huobi api, but response parsed by CCXT
    /// * `limit` {int|undefined} - Default48Data Range [1,200]
    /// * `params` {object} - Exchange specific parameters
    /// * `params.amount_type` {int} - *required* Open interest unit. 1-cont2-cryptocurrenty
    /// * `params.pair` {int|undefined} - eg BTC-USDT *Only for USDT-M*
    async fn fetch_open_interest_history(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1h"));
        params = params.or_default(Value::new_object());
        if timeframe.clone() != Value::from("1h") && timeframe.clone() != Value::from("4h") && timeframe.clone() != Value::from("12h") && timeframe.clone() != Value::from("1d") {
            panic!(r###"BadRequest::new(self.get("id".into()) + Value::from(" fetchOpenInterestHistory cannot only use the 1h, 4h, 12h and 1d timeframe"))"###);
        };
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut timeframes: Value = Value::Json(normalize(&Value::Json(json!({
            "1h": "60min",
            "4h": "4hour",
            "12h": "12hour",
            "1d": "1day"
        }))).unwrap());
        let mut market: Value = Huobi::market(self, symbol.clone());
        let mut amount_type: Value = Huobi::safe_number_2(self, params.clone(), Value::from("amount_type"), Value::from("amountType"), Value::Undefined);
        if amount_type.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" fetchOpenInterestHistory requires parameter params.amountType to be either 1 (cont), or 2 (cryptocurrenty)"))"###);
        };
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "period": timeframes.get(timeframe.clone()),
            "amount_type": amount_type
        }))).unwrap());
        let mut method: Value = Value::Undefined;
        if market.get(Value::from("future")).is_truthy() {
            request.set("contract_type".into(), self.safe_string(market.get(Value::from("info")), Value::from("contract_type"), Value::Undefined));
            request.set("symbol".into(), market.get(Value::from("baseId")));
            // currency code on coin-m futures
            method = Value::from("contractPublicGetApiV1ContractHisOpenInterest");
        } else if market.get(Value::from("linear")).is_truthy() {
            // coin-m futures
            request.set("contract_type".into(), Value::from("swap"));
            request.set("contract_code".into(), market.get(Value::from("id")));
            request.set("contract_code".into(), market.get(Value::from("id")));
            method = Value::from("contractPublicGetLinearSwapApiV1SwapHisOpenInterest");
        } else {
            // USDT-M
            request.set("contract_code".into(), market.get(Value::from("id")));
            method = Value::from("contractPublicGetSwapApiV1SwapHisOpenInterest");
        };
        // coin-m swaps
        if limit.clone().is_nonnullish() {
            request.set("size".into(), limit.clone());
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //  contractPublicGetlinearSwapApiV1SwapHisOpenInterest
        //    {
        //        status: 'ok',
        //        data: {
        //            symbol: 'BTC',
        //            tick: [
        //                {
        //                    volume: '4385.4350000000000000',
        //                    amount_type: '2',
        //                    ts: '1648220400000',
        //                    value: '194059884.1850000000000000'
        //                },
        //                ...
        //            ],
        //            contract_code: 'BTC-USDT',
        //            business_type: 'swap',
        //            pair: 'BTC-USDT',
        //            contract_type: 'swap',
        //            trade_partition: 'USDT'
        //        },
        //        ts: '1648223733007'
        //    }
        //
        //  contractPublicGetSwapApiV1SwapHisOpenInterest
        //    {
        //        "status": "ok",
        //        "data": {
        //            "symbol": "CRV",
        //            "tick": [
        //                {
        //                    "volume": 19174.0000000000000000,
        //                    "amount_type": 1,
        //                    "ts": 1648224000000
        //                },
        //                ...
        //            ],
        //            "contract_code": "CRV-USD"
        //        },
        //        "ts": 1648226554260
        //    }
        //
        //  contractPublicGetApiV1ContractHisOpenInterest
        //    {
        //         "status": "ok",
        //         "data": {
        //             "symbol": "BTC",
        //             "contract_type": "this_week",
        //             "tick": [
        //                {
        //                     "volume": "48419.0000000000000000",
        //                     "amount_type": 1,
        //                     "ts": 1648224000000
        //                },
        //                ...
        //            ]
        //        },
        //        "ts": 1648227062944
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut tick: Value = self.safe_value(data.clone(), Value::from("tick"), Value::Undefined);
        return Huobi::parse_open_interests(self, tick.clone(), Value::Undefined, since.clone(), limit.clone());
    }

    fn parse_open_interest(&self, mut interest: Value, mut market: Value) -> Value {
        //
        //    {
        //        volume: '4385.4350000000000000',
        //        amount_type: '2',
        //        ts: '1648220400000',
        //        value: '194059884.1850000000000000'
        //    }
        //
        let mut timestamp: Value = Huobi::safe_number(self, interest.clone(), Value::from("ts"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined),
            "baseVolume": Huobi::safe_number(self, interest.clone(), Value::from("volume"), Value::Undefined),
            "quoteVolume": self.safe_value(interest.clone(), Value::from("value"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": interest
        }))).unwrap());
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Create a loan to borrow margin
    /// @see https://huobiapi.github.io/docs/spot/v1/en/#request-a-margin-loan-isolated
    /// @see https://huobiapi.github.io/docs/spot/v1/en/#request-a-margin-loan-cross
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to borrow
    /// * `amount` {float} - the amount to borrow
    /// * `symbol` {string|undefined} - unified market symbol, required for isolated margin
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn borrow_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Huobi::currency(self, code.clone());
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "amount": Huobi::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined)
        }))).unwrap());
        let mut margin_mode: Value = Value::Undefined;
        (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("borrowMargin"), params.clone()));
        margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
        let mut method: Value = Value::Undefined;
        if margin_mode.clone() == Value::from("isolated") {
            if symbol.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" borrowMargin() requires a symbol argument for isolated margin"))"###);
            };
            let mut market: Value = Huobi::market(self, symbol.clone());
            request.set("symbol".into(), market.get(Value::from("id")));
            method = Value::from("privatePostMarginOrders");
        } else if margin_mode.clone() == Value::from("cross") {
            method = Value::from("privatePostCrossMarginOrders");
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        // Cross
        //
        //     {
        //         "status": "ok",
        //         "data": null
        //     }
        //
        // Isolated
        //
        //     {
        //         "data": 1000
        //     }
        //
        let mut transaction: Value = Huobi::parse_margin_loan(self, response.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "amount": amount,
            "symbol": symbol
        }))).unwrap()));
    }

    /// Returns a [margin loan structure](https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure)
    ///
    /// Repay borrowed margin and interest
    /// @see https://huobiapi.github.io/docs/spot/v1/en/#repay-margin-loan-cross-isolated
    ///
    /// # Arguments
    ///
    /// * `code` {string} - unified currency code of the currency to repay
    /// * `amount` {float} - the amount to repay
    /// * `symbol` {string|undefined} - unified market symbol
    /// * `params` {object} - extra parameters specific to the huobi api endpoint
    async fn repay_margin(&mut self, mut code: Value, mut amount: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut currency: Value = Huobi::currency(self, code.clone());
        let mut margin_mode: Value = Value::Undefined;
        (margin_mode, params) = shift_2(Huobi::handle_margin_mode_and_params(self, Value::from("repayMargin"), params.clone()));
        margin_mode = if margin_mode.clone().is_nullish() { Value::from("cross") } else { margin_mode.clone() };
        let mut margin_accounts: Value = self.safe_value(self.get("options".into()), Value::from("marginAccounts"), Value::new_object());
        let mut account_type: Value = Huobi::get_supported_mapping(self, margin_mode.clone(), margin_accounts.clone());
        let mut account_id: Value = Huobi::fetch_account_id_by_type(self, account_type.clone(), params.clone()).await;
        let mut request: Value = Value::Json(normalize(&Value::Json(json!({
            "currency": currency.get(Value::from("id")),
            "amount": Huobi::currency_to_precision(self, code.clone(), amount.clone(), Value::Undefined),
            "accountId": account_id
        }))).unwrap());
        let mut response: Value = Huobi::dispatch(self, "v2PrivatePostAccountRepayment".into(), extend_2(request.clone(), params.clone()), Value::Undefined).await;
        //
        //     {
        //         "code":200,
        //         "data": [
        //             {
        //                 "repayId":1174424,
        //                 "repayTime":1600747722018
        //             }
        //         ]
        //     }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("Data"), Value::new_array());
        let mut loan: Value = self.safe_value(data.clone(), Value::from(0), Value::Undefined);
        let mut transaction: Value = Huobi::parse_margin_loan(self, loan.clone(), currency.clone());
        return extend_2(transaction.clone(), Value::Json(normalize(&Value::Json(json!({
            "amount": amount,
            "symbol": symbol
        }))).unwrap()));
    }

    fn parse_margin_loan(&self, mut info: Value, mut currency: Value) -> Value {
        //
        // borrowMargin cross
        //
        //     {
        //         "status": "ok",
        //         "data": null
        //     }
        //
        // borrowMargin isolated
        //
        //     {
        //         "data": 1000
        //     }
        //
        // repayMargin
        //
        //     {
        //         "repayId":1174424,
        //         "repayTime":1600747722018
        //     }
        //
        let mut timestamp: Value = self.safe_integer(info.clone(), Value::from("repayTime"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_integer_2(info.clone(), Value::from("repayId"), Value::from("data"), Value::Undefined),
            "currency": Huobi::safe_currency_code(self, Value::Undefined, currency.clone()),
            "amount": Value::Undefined,
            "symbol": Value::Undefined,
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "info": info
        }))).unwrap());
    }

    /// Returns a list of settlement history objects
    ///
    /// Fetches historical settlement records
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch the settlement history for
    /// * `since` {int} - timestamp in ms, value range = current time - 90 daysdefault = current time - 90 days
    /// * `limit` {int} - page items, default 20, shall not exceed 50
    /// * `params` {object} - exchange specific params
    /// * `params.until` {int} - timestamp in ms, value range = start_time -> current timedefault = current time
    /// * `params.page_index` {int} - page index, default page 1 if not filled
    /// * `params.code` {int} - unified currency code, can be used when symbol is undefined
    async fn fetch_settlement_history(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut code: Value = self.safe_string(params.clone(), Value::from("code"), Value::Undefined);
        let mut until: Value = self.safe_integer_2(params.clone(), Value::from("until"), Value::from("till"), Value::Undefined);
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("until").into(), Value::from("till").into()])));
        let mut market: Value = if symbol.clone().is_nullish() { Value::Undefined } else { Huobi::market(self, symbol.clone()) };
        let (mut r#type, mut query) = shift_2(Huobi::handle_market_type_and_params(self, Value::from("fetchSettlementHistory"), market.clone(), params.clone()));
        if r#type.clone() == Value::from("future") {
            if symbol.clone().is_nullish() && code.clone().is_nullish() {
                panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(r#" requires a symbol argument or params["code"] for fetchSettlementHistory future"#))"###);
            };
        } else if symbol.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" requires a symbol argument for fetchSettlementHistory swap"))"###);
        };
        let mut request: Value = Value::new_object();
        if market.get(Value::from("future")).is_truthy() {
            request.set("symbol".into(), market.get(Value::from("baseId")));
        } else {
            request.set("contract_code".into(), market.get(Value::from("id")));
        };
        if since.clone().is_nonnullish() {
            request.set("start_at".into(), since.clone());
        };
        if limit.clone().is_nonnullish() {
            request.set("page_size".into(), limit.clone());
        };
        if until.clone().is_nonnullish() {
            request.set("end_at".into(), until.clone());
        };
        let mut method: Value = Value::from("contractPublicGetApiV1ContractSettlementRecords");
        if market.get(Value::from("swap")).is_truthy() {
            if market.get(Value::from("linear")).is_truthy() {
                method = Value::from("contractPublicGetLinearSwapApiV1SwapSettlementRecords");
            } else {
                method = Value::from("contractPublicGetSwapApiV1SwapSettlementRecords");
            };
        };
        let mut response: Value = Huobi::dispatch(self, method, extend_2(request.clone(), query.clone()), Value::Undefined).await;
        //
        // linear swap, coin-m swap
        //
        //    {
        //        "status": "ok",
        //        "data": {
        //        "total_page": 14,
        //        "current_page": 1,
        //        "total_size": 270,
        //        "settlement_record": [
        //            {
        //                "symbol": "ADA",
        //                "contract_code": "ADA-USDT",
        //                "settlement_time": 1652313600000,
        //                "clawback_ratio": 0E-18,
        //                "settlement_price": 0.512303000000000000,
        //                "settlement_type": "settlement",
        //                "business_type": "swap",
        //                "pair": "ADA-USDT",
        //                "trade_partition": "USDT"
        //            },
        //            ...
        //        ],
        //        "ts": 1652338693256
        //    }
        //
        // coin-m future
        //
        //    {
        //        "status": "ok",
        //        "data": {
        //            "total_page": 5,
        //            "current_page": 1,
        //            "total_size": 90,
        //            "settlement_record": [
        //                {
        //                    "symbol": "FIL",
        //                    "settlement_time": 1652342400000,
        //                    "clawback_ratio": 0E-18,
        //                    "list": [
        //                        {
        //                            "contract_code": "FIL220513",
        //                            "settlement_price": 7.016000000000000000,
        //                            "settlement_type": "settlement"
        //                        },
        //                        ...
        //                    ]
        //                },
        //            ]
        //        }
        //    }
        //
        let mut data: Value = self.safe_value(response.clone(), Value::from("data"), Value::Undefined);
        let mut settlement_record: Value = self.safe_value(data.clone(), Value::from("settlement_record"), Value::Undefined);
        let mut settlements: Value = Huobi::parse_settlements(self, settlement_record.clone(), market.clone());
        return self.sort_by(settlements.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
    }

    fn parse_settlements(&self, mut settlements: Value, mut market: Value) -> Value {
        //
        // linear swap, coin-m swap, fetchSettlementHistory
        //
        //    [
        //        {
        //            "symbol": "ADA",
        //            "contract_code": "ADA-USDT",
        //            "settlement_time": 1652313600000,
        //            "clawback_ratio": 0E-18,
        //            "settlement_price": 0.512303000000000000,
        //            "settlement_type": "settlement",
        //            "business_type": "swap",
        //            "pair": "ADA-USDT",
        //            "trade_partition": "USDT"
        //        },
        //        ...
        //    ]
        //
        // coin-m future, fetchSettlementHistory
        //
        //    [
        //        {
        //            "symbol": "FIL",
        //            "settlement_time": 1652342400000,
        //            "clawback_ratio": 0E-18,
        //            "list": [
        //                {
        //                    "contract_code": "FIL220513",
        //                    "settlement_price": 7.016000000000000000,
        //                    "settlement_type": "settlement"
        //                },
        //                ...
        //            ]
        //        },
        //    ]
        //
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < settlements.len() {
            let mut settlement: Value = settlements.get(i.into());
            let mut list: Value = self.safe_value(settlement.clone(), Value::from("list"), Value::Undefined);
            if list.clone().is_nonnullish() {
                let mut timestamp: Value = self.safe_integer(settlement.clone(), Value::from("settlement_time"), Value::Undefined);
                let mut timestamp_details: Value = Value::Json(normalize(&Value::Json(json!({
                    "timestamp": timestamp,
                    "datetime": self.iso8601(timestamp.clone())
                }))).unwrap());
                let mut j: usize = 0;
                while j < list.len() {
                    let mut item: Value = list.get(j.into());
                    let mut parsed_settlement: Value = Huobi::parse_settlement(self, item.clone(), market.clone());
                    result.push(extend_2(parsed_settlement.clone(), timestamp_details.clone()));
                    j += 1;
                };
            } else {
                result.push(Huobi::parse_settlement(self, settlements.get(i.into()), market.clone()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn parse_settlement(&self, mut settlement: Value, mut market: Value) -> Value {
        //
        // linear swap, coin-m swap, fetchSettlementHistory
        //
        //    {
        //        "symbol": "ADA",
        //        "contract_code": "ADA-USDT",
        //        "settlement_time": 1652313600000,
        //        "clawback_ratio": 0E-18,
        //        "settlement_price": 0.512303000000000000,
        //        "settlement_type": "settlement",
        //        "business_type": "swap",
        //        "pair": "ADA-USDT",
        //        "trade_partition": "USDT"
        //    }
        //
        // coin-m future, fetchSettlementHistory
        //
        //    {
        //        "contract_code": "FIL220513",
        //        "settlement_price": 7.016000000000000000,
        //        "settlement_type": "settlement"
        //    }
        //
        let mut timestamp: Value = self.safe_integer(settlement.clone(), Value::from("settlement_time"), Value::Undefined);
        let mut market_id: Value = self.safe_string(settlement.clone(), Value::from("contract_code"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "info": settlement,
            "symbol": Huobi::safe_symbol(self, market_id.clone(), market.clone(), Value::Undefined),
            "price": Huobi::safe_number(self, settlement.clone(), Value::from("settlement_price"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone())
        }))).unwrap());
    }

    fn safe_ledger_entry(&self, mut entry: Value, mut currency: Value) -> Value {
        currency = Huobi::safe_currency(self, Value::Undefined, currency.clone());
        let mut direction: Value = self.safe_string(entry.clone(), Value::from("direction"), Value::Undefined);
        let mut before: Value = self.safe_string(entry.clone(), Value::from("before"), Value::Undefined);
        let mut after: Value = self.safe_string(entry.clone(), Value::from("after"), Value::Undefined);
        let mut amount: Value = self.safe_string(entry.clone(), Value::from("amount"), Value::Undefined);
        if amount.clone().is_nonnullish() {
            if before.clone().is_nullish() && after.clone().is_nonnullish() {
                before = Precise::string_sub(after.clone(), amount.clone());
            } else if before.clone().is_nonnullish() && after.clone().is_nullish() {
                after = Precise::string_add(before.clone(), amount.clone());
            };
        };
        if before.clone().is_nonnullish() && after.clone().is_nonnullish() {
            if direction.clone().is_nullish() {
                if Precise::string_gt(before.clone(), after.clone()) {
                    direction = Value::from("out");
                };
                if Precise::string_gt(after.clone(), before.clone()) {
                    direction = Value::from("in");
                };
            };
        };
        let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::Undefined);
        if fee.clone().is_nonnullish() {
            fee.set("cost".into(), Huobi::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
        };
        let mut timestamp: Value = self.safe_integer(entry.clone(), Value::from("timestamp"), Value::Undefined);
        return Value::Json(normalize(&Value::Json(json!({
            "id": self.safe_string(entry.clone(), Value::from("id"), Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "direction": direction,
            "account": self.safe_string(entry.clone(), Value::from("account"), Value::Undefined),
            "referenceId": self.safe_string(entry.clone(), Value::from("referenceId"), Value::Undefined),
            "referenceAccount": self.safe_string(entry.clone(), Value::from("referenceAccount"), Value::Undefined),
            "type": self.safe_string(entry.clone(), Value::from("type"), Value::Undefined),
            "currency": currency.get(Value::from("code")),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "before": self.parse_number(before.clone(), Value::Undefined),
            "after": self.parse_number(after.clone(), Value::Undefined),
            "status": self.safe_string(entry.clone(), Value::from("status"), Value::Undefined),
            "fee": fee,
            "info": entry
        }))).unwrap());
    }

    fn set_markets(&mut self, mut markets: Value, mut currencies: Value) -> Value {
        let mut values: Value = Value::new_array();
        let mut market_values: Value = self.to_array(markets.clone());
        let mut i: usize = 0;
        while i < market_values.len() {
            let mut market: Value = self.deep_extend_4(Huobi::safe_market(self, Value::Undefined, Value::Undefined, Value::Undefined), Value::Json(normalize(&Value::Json(json!({
                "precision": self.get("precision".into()),
                "limits": self.get("limits".into())
            }))).unwrap()), self.get("fees".into()).get(Value::from("trading")), market_values.get(i.into()));
            values.push(market.clone());
            i += 1;
        };
        self.set("markets".into(), self.index_by(values.clone(), Value::from("symbol"), Value::Undefined));
        self.set("markets_by_id".into(), self.index_by(markets.clone(), Value::from("id"), Value::Undefined));
        let mut markets_sorted_by_symbol: Value = self.keysort(self.get("markets".into()), Value::Undefined);
        let mut markets_sorted_by_id: Value = self.keysort(self.get("markets_by_id".into()), Value::Undefined);
        self.set("symbols".into(), Object::keys(markets_sorted_by_symbol.clone()));
        self.set("ids".into(), Object::keys(markets_sorted_by_id.clone()));
        if currencies.clone().is_nonnullish() {
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), currencies.clone()));
        } else {
            let mut base_currencies: Value = Value::new_array();
            let mut quote_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < values.len() {
                let mut market: Value = values.get(i.into());
                let mut default_currency_precision: Value = if self.get("precision_mode".into()) == DECIMAL_PLACES.into() { Value::from(8) } else { self.parse_number(Value::from("0.00000001"), Value::Undefined) };
                let mut market_precision: Value = self.safe_value(market.clone(), Value::from("precision"), Value::new_object());
                if market.contains_key(Value::from("base")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("base"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("baseId"), Value::from("base"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("baseNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("base"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    base_currencies.push(currency.clone());
                };
                if market.contains_key(Value::from("quote")) {
                    let mut currency_precision: Value = self.safe_value_2(market_precision.clone(), Value::from("quote"), Value::from("amount"), default_currency_precision.clone());
                    let mut currency: Value = Value::Json(normalize(&Value::Json(json!({
                        "id": self.safe_string_2(market.clone(), Value::from("quoteId"), Value::from("quote"), Value::Undefined),
                        "numericId": self.safe_string(market.clone(), Value::from("quoteNumericId"), Value::Undefined),
                        "code": self.safe_string(market.clone(), Value::from("quote"), Value::Undefined),
                        "precision": currency_precision
                    }))).unwrap());
                    quote_currencies.push(currency.clone());
                };
                i += 1;
            };
            base_currencies = self.sort_by(base_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            quote_currencies = self.sort_by(quote_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("base_currencies".into(), self.index_by(base_currencies.clone(), Value::from("code"), Value::Undefined));
            self.set("quote_currencies".into(), self.index_by(quote_currencies.clone(), Value::from("code"), Value::Undefined));
            let mut all_currencies: Value = self.array_concat(base_currencies.clone(), quote_currencies.clone());
            let mut grouped_currencies: Value = self.group_by(all_currencies.clone(), Value::from("code"), Value::Undefined);
            let mut codes: Value = Object::keys(grouped_currencies.clone());
            let mut resulting_currencies: Value = Value::new_array();
            let mut i: usize = 0;
            while i < codes.len() {
                let mut code: Value = codes.get(i.into());
                let mut grouped_currencies_code: Value = self.safe_value(grouped_currencies.clone(), code.clone(), Value::new_array());
                let mut highest_precision_currency: Value = self.safe_value(grouped_currencies_code.clone(), Value::from(0), Value::Undefined);
                let mut j: usize = 1;
                while j < grouped_currencies_code.len() {
                    let mut current_currency: Value = grouped_currencies_code.get(j.into());
                    if self.get("precision_mode".into()) == TICK_SIZE.into() {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) < highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    } else {
                        highest_precision_currency = if current_currency.get(Value::from("precision")) > highest_precision_currency.get(Value::from("precision")) { current_currency.clone() } else { highest_precision_currency.clone() };
                    };
                    j += 1;
                };
                resulting_currencies.push(highest_precision_currency.clone());
                i += 1;
            };
            let mut sorted_currencies: Value = self.sort_by(resulting_currencies.clone(), Value::from("code"), Value::Undefined, Value::Undefined);
            self.set("currencies".into(), self.deep_extend_2(self.get("currencies".into()), self.index_by(sorted_currencies.clone(), Value::from("code"), Value::Undefined)));
        };
        self.set("currencies_by_id".into(), self.index_by(self.get("currencies".into()), Value::from("id"), Value::Undefined));
        let mut currencies_sorted_by_code: Value = self.keysort(self.get("currencies".into()), Value::Undefined);
        self.set("codes".into(), Object::keys(currencies_sorted_by_code.clone()));
        return self.get("markets".into());
    }

    fn safe_balance(&self, mut balance: Value) -> Value {
        let mut balances: Value = self.omit(balance.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("info").into(), Value::from("timestamp").into(), Value::from("datetime").into(), Value::from("free").into(), Value::from("used").into(), Value::from("total").into()])));
        let mut codes: Value = Object::keys(balances.clone());
        balance.set("free".into(), Value::new_object());
        balance.set("used".into(), Value::new_object());
        balance.set("total".into(), Value::new_object());
        let mut i: usize = 0;
        while i < codes.len() {
            let mut code: Value = codes.get(i.into());
            let mut total: Value = self.safe_string(balance.get(code.clone()), Value::from("total"), Value::Undefined);
            let mut free: Value = self.safe_string(balance.get(code.clone()), Value::from("free"), Value::Undefined);
            let mut used: Value = self.safe_string(balance.get(code.clone()), Value::from("used"), Value::Undefined);
            if total.clone().is_nullish() && free.clone().is_nonnullish() && used.clone().is_nonnullish() {
                total = Precise::string_add(free.clone(), used.clone());
            };
            if free.clone().is_nullish() && total.clone().is_nonnullish() && used.clone().is_nonnullish() {
                free = Precise::string_sub(total.clone(), used.clone());
            };
            if used.clone().is_nullish() && total.clone().is_nonnullish() && free.clone().is_nonnullish() {
                used = Precise::string_sub(total.clone(), free.clone());
            };
            balance.get(code.clone()).set("free".into(), self.parse_number(free.clone(), Value::Undefined));
            balance.get(code.clone()).set("used".into(), self.parse_number(used.clone(), Value::Undefined));
            balance.get(code.clone()).set("total".into(), self.parse_number(total.clone(), Value::Undefined));
            balance.get(Value::from("free")).set(code.clone(), balance.get(code.clone()).get(Value::from("free")));
            balance.get(Value::from("used")).set(code.clone(), balance.get(code.clone()).get(Value::from("used")));
            balance.get(Value::from("total")).set(code.clone(), balance.get(code.clone()).get(Value::from("total")));
            i += 1;
        };
        return balance.clone();
    }

    fn safe_order(&mut self, mut order: Value, mut market: Value) -> Value {
        // parses numbers as strings
        // it is important pass the trades as unparsed rawTrades
        let mut amount: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("amount"), Value::Undefined));
        let mut remaining: Value = self.safe_string(order.clone(), Value::from("remaining"), Value::Undefined);
        let mut filled: Value = self.safe_string(order.clone(), Value::from("filled"), Value::Undefined);
        let mut cost: Value = self.safe_string(order.clone(), Value::from("cost"), Value::Undefined);
        let mut average: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("average"), Value::Undefined));
        let mut price: Value = self.omit_zero(self.safe_string(order.clone(), Value::from("price"), Value::Undefined));
        let mut last_trade_time_timestamp: Value = self.safe_integer(order.clone(), Value::from("lastTradeTimestamp"), Value::Undefined);
        let mut parse_filled: Value = (filled.clone().is_nullish()).into();
        let mut parse_cost: Value = (cost.clone().is_nullish()).into();
        let mut parse_last_trade_time_timestamp: Value = (last_trade_time_timestamp.clone().is_nullish()).into();
        let mut fee: Value = self.safe_value(order.clone(), Value::from("fee"), Value::Undefined);
        let mut parse_fee: Value = (fee.clone().is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(order.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = self.safe_value(order.clone(), Value::from("fees"), Value::new_array());
        let mut trades: Value = Value::new_array();
        if parse_filled.is_truthy() || parse_cost.is_truthy() || should_parse_fees.is_truthy() {
            let mut raw_trades: Value = self.safe_value(order.clone(), Value::from("trades"), trades.clone());
            let mut old_number: Value = self.get("number".into());
            // we parse trades as strings here!
            self.set_number_mode("String".into());
            trades = Huobi::parse_trades(self, raw_trades.clone(), market.clone(), Value::Undefined, Value::Undefined, Value::Json(normalize(&Value::Json(json!({
                "symbol": order.get(Value::from("symbol")),
                "side": order.get(Value::from("side")),
                "type": order.get(Value::from("type")),
                "order": order.get(Value::from("id"))
            }))).unwrap()));
            self.set("number".into(), old_number.clone());
            let mut trades_length: Value = Value::from(0);
            let mut is_array: Value = Array::is_array(trades.clone());
            if is_array.is_truthy() {
                trades_length = trades.len().into();
            };
            if is_array.is_truthy() && trades_length.clone() > Value::from(0) {
                // move properties that are defined in trades up into the order
                if order.get(Value::from("symbol")).is_nullish() {
                    order.set("symbol".into(), trades.get(Value::from(0)).get(Value::from("symbol")));
                };
                if order.get(Value::from("side")).is_nullish() {
                    order.set("side".into(), trades.get(Value::from(0)).get(Value::from("side")));
                };
                if order.get(Value::from("type")).is_nullish() {
                    order.set("type".into(), trades.get(Value::from(0)).get(Value::from("type")));
                };
                if order.get(Value::from("id")).is_nullish() {
                    order.set("id".into(), trades.get(Value::from(0)).get(Value::from("order")));
                };
                if parse_filled.is_truthy() {
                    filled = Value::from("0");
                };
                if parse_cost.is_truthy() {
                    cost = Value::from("0");
                };
                let mut i: usize = 0;
                while i < trades.len() {
                    let mut trade: Value = trades.get(i.into());
                    let mut trade_amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
                    if parse_filled.is_truthy() && trade_amount.clone().is_nonnullish() {
                        filled = Precise::string_add(filled.clone(), trade_amount.clone());
                    };
                    let mut trade_cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
                    if parse_cost.is_truthy() && trade_cost.clone().is_nonnullish() {
                        cost = Precise::string_add(cost.clone(), trade_cost.clone());
                    };
                    let mut trade_timestamp: Value = self.safe_value(trade.clone(), Value::from("timestamp"), Value::Undefined);
                    if parse_last_trade_time_timestamp.is_truthy() && trade_timestamp.clone().is_nonnullish() {
                        if last_trade_time_timestamp.clone().is_nullish() {
                            last_trade_time_timestamp = trade_timestamp.clone();
                        } else {
                            last_trade_time_timestamp = Math::max(last_trade_time_timestamp.clone(), trade_timestamp.clone());
                        };
                    };
                    if should_parse_fees.is_truthy() {
                        let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
                        if trade_fees.clone().is_nonnullish() {
                            let mut j: usize = 0;
                            while j < trade_fees.len() {
                                let mut trade_fee: Value = trade_fees.get(j.into());
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                                j += 1;
                            };
                        } else {
                            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                            if trade_fee.clone().is_nonnullish() {
                                fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                            };
                        };
                    };
                    i += 1;
                };
            };
        };
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Huobi::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Huobi::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Huobi::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Huobi::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Huobi::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            order.set("fees".into(), reduced_fees.clone());
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                order.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
        };
        if amount.clone().is_nullish() {
            // ensure amount = filled + remaining
            if filled.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                amount = Precise::string_add(filled.clone(), remaining.clone());
            } else if self.safe_string(order.clone(), Value::from("status"), Value::Undefined) == Value::from("closed") {
                amount = filled.clone();
            };
        };
        if filled.clone().is_nullish() {
            if amount.clone().is_nonnullish() && remaining.clone().is_nonnullish() {
                filled = Precise::string_sub(amount.clone(), remaining.clone());
            };
        };
        if remaining.clone().is_nullish() {
            if amount.clone().is_nonnullish() && filled.clone().is_nonnullish() {
                remaining = Precise::string_sub(amount.clone(), filled.clone());
            };
        };
        // ensure that the average field is calculated correctly
        if average.clone().is_nullish() {
            if filled.clone().is_nonnullish() && cost.clone().is_nonnullish() && Precise::string_gt(filled.clone(), Value::from("0")) {
                average = Precise::string_div(cost.clone(), filled.clone(), Value::Undefined);
            };
        };
        // also ensure the cost field is calculated correctly
        let mut cost_price_exists: Value = (average.clone().is_nonnullish() || price.clone().is_nonnullish()).into();
        if parse_cost.is_truthy() && filled.clone().is_nonnullish() && cost_price_exists.is_truthy() {
            let mut multiply_price: Value = Value::Undefined;
            if average.clone().is_nullish() {
                multiply_price = price.clone();
            } else {
                multiply_price = average.clone();
            };
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), multiply_price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), filled.clone());
        };
        // support for market orders
        let mut order_type: Value = self.safe_value(order.clone(), Value::from("type"), Value::Undefined);
        let mut empty_price: Value = (price.clone().is_nullish() || Precise::string_equals(price.clone(), Value::from("0"))).into();
        if empty_price.is_truthy() && order_type.clone() == Value::from("market") {
            price = average.clone();
        };
        // we have trades with string values at this point so we will mutate them
        let mut i: usize = 0;
        while i < trades.len() {
            let mut entry: Value = trades.get(i.into());
            entry.set("amount".into(), Huobi::safe_number(self, entry.clone(), Value::from("amount"), Value::Undefined));
            entry.set("price".into(), Huobi::safe_number(self, entry.clone(), Value::from("price"), Value::Undefined));
            entry.set("cost".into(), Huobi::safe_number(self, entry.clone(), Value::from("cost"), Value::Undefined));
            let mut fee: Value = self.safe_value(entry.clone(), Value::from("fee"), Value::new_object());
            fee.set("cost".into(), Huobi::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
            if fee.contains_key(Value::from("rate")) {
                fee.set("rate".into(), Huobi::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
            };
            entry.set("fee".into(), fee.clone());
            i += 1;
        };
        // timeInForceHandling
        let mut time_in_force: Value = self.safe_string(order.clone(), Value::from("timeInForce"), Value::Undefined);
        if time_in_force.clone().is_nullish() {
            if self.safe_string(order.clone(), Value::from("type"), Value::Undefined) == Value::from("market") {
                time_in_force = Value::from("IOC");
            };
            // allow postOnly override
            if self.safe_value(order.clone(), Value::from("postOnly"), false.into()).is_truthy() {
                time_in_force = Value::from("PO");
            };
        };
        return extend_2(order.clone(), Value::Json(normalize(&Value::Json(json!({
            "lastTradeTimestamp": last_trade_time_timestamp,
            "price": self.parse_number(price.clone(), Value::Undefined),
            "amount": self.parse_number(amount.clone(), Value::Undefined),
            "cost": self.parse_number(cost.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "filled": self.parse_number(filled.clone(), Value::Undefined),
            "remaining": self.parse_number(remaining.clone(), Value::Undefined),
            "timeInForce": time_in_force,
            "trades": trades
        }))).unwrap()));
    }

    fn parse_orders(&mut self, mut orders: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(orders.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < orders.len() {
                let mut order: Value = extend_2(Huobi::parse_order(self, orders.get(i.into()), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        } else {
            let mut ids: Value = Object::keys(orders.clone());
            let mut i: usize = 0;
            while i < ids.len() {
                let mut id: Value = ids.get(i.into());
                let mut order: Value = extend_2(Huobi::parse_order(self, extend_2(Value::Json(normalize(&Value::Json(json!({
                    "id": id
                }))).unwrap()), orders.get(id.clone())), market.clone()), params.clone());
                results.push(order.clone());
                i += 1;
            };
        };
        results = self.sort_by(results.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Huobi::filter_by_symbol_since_limit(self, results.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn calculate_fee(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut taker_or_maker: Value, mut params: Value) -> Value {
        taker_or_maker = taker_or_maker.or_default(Value::from("taker"));
        params = params.or_default(Value::new_object());
        let mut market: Value = self.get("markets".into()).get(symbol.clone());
        let mut fee_side: Value = self.safe_string(market.clone(), Value::from("feeSide"), Value::from("quote"));
        let mut key: Value = Value::from("quote");
        let mut cost: Value = Value::Undefined;
        if fee_side.clone() == Value::from("quote") {
            // the fee is always in quote currency
            cost = amount.clone() * price.clone();
        } else if fee_side.clone() == Value::from("base") {
            // the fee is always in base currency
            cost = amount.clone();
        } else if fee_side.clone() == Value::from("get") {
            // the fee is always in the currency you get
            cost = amount.clone();
            if side.clone() == Value::from("sell") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        } else if fee_side.clone() == Value::from("give") {
            // the fee is always in the currency you give
            cost = amount.clone();
            if side.clone() == Value::from("buy") {
                cost = cost *  price.clone();
            } else {
                key = Value::from("base");
            };
        };
        let mut rate: Value = market.get(taker_or_maker.clone());
        if cost.clone().is_nonnullish() {
            cost = cost *  rate.clone();
        };
        return Value::Json(normalize(&Value::Json(json!({
            "type": taker_or_maker,
            "currency": market.get(key.clone()),
            "rate": rate,
            "cost": cost
        }))).unwrap());
    }

    fn safe_trade(&mut self, mut trade: Value, mut market: Value) -> Value {
        let mut amount: Value = self.safe_string(trade.clone(), Value::from("amount"), Value::Undefined);
        let mut price: Value = self.safe_string(trade.clone(), Value::from("price"), Value::Undefined);
        let mut cost: Value = self.safe_string(trade.clone(), Value::from("cost"), Value::Undefined);
        if cost.clone().is_nullish() {
            // contract trading
            let mut contract_size: Value = self.safe_string(market.clone(), Value::from("contractSize"), Value::Undefined);
            let mut multiply_price: Value = price.clone();
            if contract_size.clone().is_nonnullish() {
                let mut inverse: Value = self.safe_value(market.clone(), Value::from("inverse"), false.into());
                if inverse.is_truthy() {
                    multiply_price = Precise::string_div(Value::from("1"), price.clone(), Value::Undefined);
                };
                multiply_price = Precise::string_mul(multiply_price.clone(), contract_size.clone());
            };
            cost = Precise::string_mul(multiply_price.clone(), amount.clone());
        };
        let mut parse_fee: Value = (self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined).is_nullish()).into();
        let mut parse_fees: Value = (self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined).is_nullish()).into();
        let mut should_parse_fees: Value = (parse_fee.is_truthy() || parse_fees.is_truthy()).into();
        let mut fees: Value = Value::new_array();
        if should_parse_fees.is_truthy() {
            let mut trade_fees: Value = self.safe_value(trade.clone(), Value::from("fees"), Value::Undefined);
            if trade_fees.clone().is_nonnullish() {
                let mut j: usize = 0;
                while j < trade_fees.len() {
                    let mut trade_fee: Value = trade_fees.get(j.into());
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                    j += 1;
                };
            } else {
                let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
                if trade_fee.clone().is_nonnullish() {
                    fees.push(extend_2(Value::new_object(), trade_fee.clone()));
                };
            };
        };
        let mut fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
        if should_parse_fees.is_truthy() {
            let mut reduced_fees: Value = if self.get("reduce_fees".into()).is_truthy() { Huobi::reduce_fees_by_currency(self, fees.clone()) } else { fees.clone() };
            let mut reduced_length: Value = reduced_fees.len().into();
            let mut i: usize = 0;
            while i < reduced_length.clone().into() {
                reduced_fees.get(i.into()).set("cost".into(), Huobi::safe_number(self, reduced_fees.get(i.into()), Value::from("cost"), Value::Undefined));
                if reduced_fees.get(i.into()).contains_key(Value::from("rate")) {
                    reduced_fees.get(i.into()).set("rate".into(), Huobi::safe_number(self, reduced_fees.get(i.into()), Value::from("rate"), Value::Undefined));
                };
                i += 1;
            };
            if !parse_fee.is_truthy() && reduced_length.clone() == Value::from(0) {
                fee.set("cost".into(), Huobi::safe_number(self, fee.clone(), Value::from("cost"), Value::Undefined));
                if fee.contains_key(Value::from("rate")) {
                    fee.set("rate".into(), Huobi::safe_number(self, fee.clone(), Value::from("rate"), Value::Undefined));
                };
                reduced_fees.push(fee.clone());
            };
            if parse_fees.is_truthy() {
                trade.set("fees".into(), reduced_fees.clone());
            };
            if parse_fee.is_truthy() && reduced_length.clone() == Value::from(1) {
                trade.set("fee".into(), reduced_fees.get(Value::from(0)));
            };
            let mut trade_fee: Value = self.safe_value(trade.clone(), Value::from("fee"), Value::Undefined);
            if trade_fee.clone().is_nonnullish() {
                trade_fee.set("cost".into(), Huobi::safe_number(self, trade_fee.clone(), Value::from("cost"), Value::Undefined));
                if trade_fee.contains_key(Value::from("rate")) {
                    trade_fee.set("rate".into(), Huobi::safe_number(self, trade_fee.clone(), Value::from("rate"), Value::Undefined));
                };
                trade.set("fee".into(), trade_fee.clone());
            };
        };
        trade.set("amount".into(), self.parse_number(amount.clone(), Value::Undefined));
        trade.set("price".into(), self.parse_number(price.clone(), Value::Undefined));
        trade.set("cost".into(), self.parse_number(cost.clone(), Value::Undefined));
        return trade.clone();
    }

    fn reduce_fees_by_currency(&mut self, mut fees: Value) -> Value {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        let mut reduced: Value = Value::new_object();
        let mut i: usize = 0;
        while i < fees.len() {
            let mut fee: Value = fees.get(i.into());
            let mut fee_currency_code: Value = self.safe_string(fee.clone(), Value::from("currency"), Value::Undefined);
            if fee_currency_code.clone().is_nonnullish() {
                let mut rate: Value = self.safe_string(fee.clone(), Value::from("rate"), Value::Undefined);
                let mut cost: Value = self.safe_value(fee.clone(), Value::from("cost"), Value::Undefined);
                if Precise::string_eq(cost.clone(), Value::from("0")) {
                    // omit zero cost fees
                    continue;
                };
                if !reduced.contains_key(fee_currency_code.clone()) {
                    reduced.set(fee_currency_code.clone(), Value::new_object());
                };
                let mut rate_key: Value = if rate.clone().is_nullish() { Value::from("") } else { rate.clone() };
                if reduced.get(fee_currency_code.clone()).contains_key(rate_key.clone()) {
                    reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("cost".into(), Precise::string_add(reduced.get(fee_currency_code.clone()).get(rate_key.clone()).get(Value::from("cost")), cost.clone()));
                } else {
                    reduced.get(fee_currency_code.clone()).set(rate_key.clone(), Value::Json(normalize(&Value::Json(json!({
                        "currency": fee_currency_code,
                        "cost": cost
                    }))).unwrap()));
                    if rate.clone().is_nonnullish() {
                        reduced.get(fee_currency_code.clone()).get(rate_key.clone()).set("rate".into(), rate.clone());
                    };
                };
            };
            i += 1;
        };
        let mut result: Value = Value::new_array();
        let mut fee_values: Value = Object::values(reduced.clone());
        let mut i: usize = 0;
        while i < fee_values.len() {
            let mut reduced_fee_values: Value = Object::values(fee_values.get(i.into()));
            result = self.array_concat(result.clone(), reduced_fee_values.clone());
            i += 1;
        };
        return result.clone();
    }

    fn safe_ticker(&self, mut ticker: Value, mut market: Value) -> Value {
        let mut open: Value = self.safe_value(ticker.clone(), Value::from("open"), Value::Undefined);
        let mut close: Value = self.safe_value(ticker.clone(), Value::from("close"), Value::Undefined);
        let mut last: Value = self.safe_value(ticker.clone(), Value::from("last"), Value::Undefined);
        let mut change: Value = self.safe_value(ticker.clone(), Value::from("change"), Value::Undefined);
        let mut percentage: Value = self.safe_value(ticker.clone(), Value::from("percentage"), Value::Undefined);
        let mut average: Value = self.safe_value(ticker.clone(), Value::from("average"), Value::Undefined);
        let mut vwap: Value = self.safe_value(ticker.clone(), Value::from("vwap"), Value::Undefined);
        let mut base_volume: Value = self.safe_value(ticker.clone(), Value::from("baseVolume"), Value::Undefined);
        let mut quote_volume: Value = self.safe_value(ticker.clone(), Value::from("quoteVolume"), Value::Undefined);
        if vwap.clone().is_nullish() {
            vwap = Precise::string_div(quote_volume.clone(), base_volume.clone(), Value::Undefined);
        };
        if last.clone().is_nonnullish() && close.clone().is_nullish() {
            close = last.clone();
        } else if last.clone().is_nullish() && close.clone().is_nonnullish() {
            last = close.clone();
        };
        if last.clone().is_nonnullish() && open.clone().is_nonnullish() {
            if change.clone().is_nullish() {
                change = Precise::string_sub(last.clone(), open.clone());
            };
            if average.clone().is_nullish() {
                average = Precise::string_div(Precise::string_add(last.clone(), open.clone()), Value::from("2"), Value::Undefined);
            };
        };
        if percentage.clone().is_nullish() && change.clone().is_nonnullish() && open.clone().is_nonnullish() && Precise::string_gt(open.clone(), Value::from("0")) {
            percentage = Precise::string_mul(Precise::string_div(change.clone(), open.clone(), Value::Undefined), Value::from("100"));
        };
        if change.clone().is_nullish() && percentage.clone().is_nonnullish() && open.clone().is_nonnullish() {
            change = Precise::string_div(Precise::string_mul(percentage.clone(), open.clone()), Value::from("100"), Value::Undefined);
        };
        if open.clone().is_nullish() && last.clone().is_nonnullish() && change.clone().is_nonnullish() {
            open = Precise::string_sub(last.clone(), change.clone());
        };
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return extend_2(ticker.clone(), Value::Json(normalize(&Value::Json(json!({
            "bid": Huobi::safe_number(self, ticker.clone(), Value::from("bid"), Value::Undefined),
            "bidVolume": Huobi::safe_number(self, ticker.clone(), Value::from("bidVolume"), Value::Undefined),
            "ask": Huobi::safe_number(self, ticker.clone(), Value::from("ask"), Value::Undefined),
            "askVolume": Huobi::safe_number(self, ticker.clone(), Value::from("askVolume"), Value::Undefined),
            "high": Huobi::safe_number(self, ticker.clone(), Value::from("high"), Value::Undefined),
            "low": Huobi::safe_number(self, ticker.clone(), Value::from("low"), Value::Undefined),
            "open": self.parse_number(open.clone(), Value::Undefined),
            "close": self.parse_number(close.clone(), Value::Undefined),
            "last": self.parse_number(last.clone(), Value::Undefined),
            "change": self.parse_number(change.clone(), Value::Undefined),
            "percentage": self.parse_number(percentage.clone(), Value::Undefined),
            "average": self.parse_number(average.clone(), Value::Undefined),
            "vwap": self.parse_number(vwap.clone(), Value::Undefined),
            "baseVolume": self.parse_number(base_volume.clone(), Value::Undefined),
            "quoteVolume": self.parse_number(quote_volume.clone(), Value::Undefined),
            "previousClose": Huobi::safe_number(self, ticker.clone(), Value::from("previousClose"), Value::Undefined)
        }))).unwrap()));
    }

    fn convert_trading_view_to_ohlcv(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_array();
        let mut timestamps: Value = self.safe_value(ohlcvs.clone(), timestamp.clone(), Value::new_array());
        let mut opens: Value = self.safe_value(ohlcvs.clone(), open.clone(), Value::new_array());
        let mut highs: Value = self.safe_value(ohlcvs.clone(), high.clone(), Value::new_array());
        let mut lows: Value = self.safe_value(ohlcvs.clone(), low.clone(), Value::new_array());
        let mut closes: Value = self.safe_value(ohlcvs.clone(), close.clone(), Value::new_array());
        let mut volumes: Value = self.safe_value(ohlcvs.clone(), volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < timestamps.len() {
            result.push(Value::Json(serde_json::Value::Array(vec![if ms.is_truthy() { self.safe_integer(timestamps.clone(), Value::from(i), Value::Undefined) } else { self.safe_timestamp(timestamps.clone(), Value::from(i), Value::Undefined) }.into(), self.safe_value(opens.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(highs.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(lows.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(closes.clone(), Value::from(i), Value::Undefined).into(), self.safe_value(volumes.clone(), Value::from(i), Value::Undefined).into()])));
            i += 1;
        };
        return result.clone();
    }

    fn convert_ohlcv_to_trading_view(&self, mut ohlcvs: Value, mut timestamp: Value, mut open: Value, mut high: Value, mut low: Value, mut close: Value, mut volume: Value, mut ms: Value) -> Value {
        timestamp = timestamp.or_default(Value::from("t"));
        open = open.or_default(Value::from("o"));
        high = high.or_default(Value::from("h"));
        low = low.or_default(Value::from("l"));
        close = close.or_default(Value::from("c"));
        volume = volume.or_default(Value::from("v"));
        ms = ms.or_default(false.into());
        let mut result: Value = Value::new_object();
        result.set(timestamp.clone(), Value::new_array());
        result.set(open.clone(), Value::new_array());
        result.set(high.clone(), Value::new_array());
        result.set(low.clone(), Value::new_array());
        result.set(close.clone(), Value::new_array());
        result.set(volume.clone(), Value::new_array());
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            let mut ts: Value = if ms.is_truthy() { ohlcvs.get(i.into()).get(Value::from(0)) } else { parse_int(ohlcvs.get(i.into()).get(Value::from(0)) / Value::from(1000)) };
            result.get(timestamp.clone()).push(ts.clone());
            result.get(open.clone()).push(ohlcvs.get(i.into()).get(Value::from(1)));
            result.get(high.clone()).push(ohlcvs.get(i.into()).get(Value::from(2)));
            result.get(low.clone()).push(ohlcvs.get(i.into()).get(Value::from(3)));
            result.get(close.clone()).push(ohlcvs.get(i.into()).get(Value::from(4)));
            result.get(volume.clone()).push(ohlcvs.get(i.into()).get(Value::from(5)));
            i += 1;
        };
        return result.clone();
    }

    fn market_ids(&mut self, mut symbols: Value) -> Value {
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Huobi::market_id(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn market_symbols(&self, mut symbols: Value) -> Value {
        if symbols.clone().is_nullish() {
            return symbols.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < symbols.len() {
            result.push(Huobi::symbol(self, symbols.get(i.into())));
            i += 1;
        };
        return result.clone();
    }

    fn parse_bids_asks(&self, mut bidasks: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        bidasks = self.to_array(bidasks.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < bidasks.len() {
            result.push(Huobi::parse_bid_ask(self, bidasks.get(i.into()), price_key.clone(), amount_key.clone()));
            i += 1;
        };
        return result.clone();
    }

    async fn fetch_l2_order_book(&mut self, mut symbol: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut orderbook: Value = Huobi::fetch_order_book(self, symbol.clone(), limit.clone(), params.clone()).await;
        return extend_2(orderbook.clone(), Value::Json(normalize(&Value::Json(json!({
            "asks": self.sort_by(self.aggregate(orderbook.get(Value::from("asks"))), Value::from(0), Value::Undefined, Value::Undefined),
            "bids": self.sort_by(self.aggregate(orderbook.get(Value::from("bids"))), Value::from(0), true.into(), Value::Undefined)
        }))).unwrap()));
    }

    fn filter_by_symbol(&self, mut objects: Value, mut symbol: Value) -> Value {
        if symbol.clone().is_nullish() {
            return objects.clone();
        };
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            let mut object_symbol: Value = self.safe_string(objects.get(i.into()), Value::from("symbol"), Value::Undefined);
            if object_symbol.clone() == symbol.clone() {
                result.push(objects.get(i.into()));
            };
            i += 1;
        };
        return result.clone();
    }

    fn get_network(&mut self, mut network: Value, mut code: Value) -> Value {
        network = network.to_upper_case();
        let mut aliases: Value = Value::Json(normalize(&Value::Json(json!({
            "ETHEREUM": "ETH",
            "ETHER": "ETH",
            "ERC20": "ETH",
            "ETH": "ETH",
            "TRC20": "TRX",
            "TRON": "TRX",
            "TRX": "TRX",
            "BEP20": "BSC",
            "BSC": "BSC",
            "HRC20": "HT",
            "HECO": "HT",
            "SPL": "SOL",
            "SOL": "SOL",
            "TERRA": "LUNA",
            "LUNA": "LUNA",
            "POLYGON": "MATIC",
            "MATIC": "MATIC",
            "EOS": "EOS",
            "WAVES": "WAVES",
            "AVALANCHE": "AVAX",
            "AVAX": "AVAX",
            "QTUM": "QTUM",
            "CHZ": "CHZ",
            "NEO": "NEO",
            "ONT": "ONT",
            "RON": "RON"
        }))).unwrap());
        if network.clone() == code.clone() {
            return network.clone();
        } else if aliases.contains_key(network.clone()) {
            return aliases.get(network.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" network ") + network.clone() + Value::from(" is not yet supported"))"###);
        };
        Value::Undefined
    }

    fn safe_number_2(&self, mut dictionary: Value, mut key1: Value, mut key2: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_2(dictionary.clone(), key1.clone(), key2.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_order_book(&self, mut orderbook: Value, mut symbol: Value, mut timestamp: Value, mut bids_key: Value, mut asks_key: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        bids_key = bids_key.or_default(Value::from("bids"));
        asks_key = asks_key.or_default(Value::from("asks"));
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut bids: Value = Huobi::parse_bids_asks(self, self.safe_value(orderbook.clone(), bids_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        let mut asks: Value = Huobi::parse_bids_asks(self, self.safe_value(orderbook.clone(), asks_key.clone(), Value::new_array()), price_key.clone(), amount_key.clone());
        return Value::Json(normalize(&Value::Json(json!({
            "symbol": symbol,
            "bids": self.sort_by(bids.clone(), Value::from(0), true.into(), Value::Undefined),
            "asks": self.sort_by(asks.clone(), Value::from(0), Value::Undefined, Value::Undefined),
            "timestamp": timestamp,
            "datetime": self.iso8601(timestamp.clone()),
            "nonce": Value::Undefined
        }))).unwrap());
    }

    fn parse_ohlcvs(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < ohlcvs.len() {
            results.push(Huobi::parse_ohlcv(self, ohlcvs.get(i.into()), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(results.clone(), Value::from(0), Value::Undefined, Value::Undefined);
        let mut tail: Value = (since.clone().is_nullish()).into();
        return self.filter_by_since_limit(sorted.clone(), since.clone(), limit.clone(), Value::from(0), tail.clone());
    }

    async fn load_trading_limits(&mut self, mut symbols: Value, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchTradingLimits")).is_truthy() {
            if reload.is_truthy() || !self.get("options".into()).contains_key(Value::from("limitsLoaded")) {
                let mut response: Value = Huobi::fetch_trading_limits(self, symbols.clone(), Value::Undefined).await;
                let mut i: usize = 0;
                while i < symbols.len() {
                    let mut symbol: Value = symbols.get(i.into());
                    self.get("markets".into()).set(symbol.clone(), self.deep_extend_2(self.get("markets".into()).get(symbol.clone()), response.get(symbol.clone())));
                    i += 1;
                };
                self.get("options".into()).set("limitsLoaded".into(), self.milliseconds());
            };
        };
        return self.get("markets".into());
    }

    fn parse_positions(&self, mut positions: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        symbols = Huobi::market_symbols(self, symbols.clone());
        positions = self.to_array(positions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < positions.len() {
            let mut position: Value = extend_2(Huobi::parse_position(self, positions.get(i.into()), Value::Undefined), params.clone());
            result.push(position.clone());
            i += 1;
        };
        return Huobi::filter_by_array(self, result.clone(), Value::from("symbol"), symbols.clone(), false.into());
    }

    fn parse_accounts(&self, mut accounts: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        accounts = self.to_array(accounts.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < accounts.len() {
            let mut account: Value = extend_2(Huobi::parse_account(self, accounts.get(i.into())), params.clone());
            result.push(account.clone());
            i += 1;
        };
        return result.clone();
    }

    fn parse_trades(&mut self, mut trades: Value, mut market: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        trades = self.to_array(trades.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < trades.len() {
            let mut trade: Value = extend_2(Huobi::parse_trade(self, trades.get(i.into()), market.clone()), params.clone());
            result.push(trade.clone());
            i += 1;
        };
        result = self.sort_by_2(result.clone(), Value::from("timestamp"), Value::from("id"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nonnullish() { market.get(Value::from("symbol")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Huobi::filter_by_symbol_since_limit(self, result.clone(), symbol.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transactions(&self, mut transactions: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transactions = self.to_array(transactions.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transactions.len() {
            let mut transaction: Value = extend_2(Huobi::parse_transaction(self, transactions.get(i.into()), currency.clone()), params.clone());
            result.push(transaction.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Huobi::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_transfers(&self, mut transfers: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        transfers = self.to_array(transfers.clone());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < transfers.len() {
            let mut transfer: Value = extend_2(Huobi::parse_transfer(self, transfers.get(i.into()), currency.clone()), params.clone());
            result.push(transfer.clone());
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Huobi::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn parse_ledger(&self, mut data: Value, mut currency: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut array_data: Value = self.to_array(data.clone());
        let mut i: usize = 0;
        while i < array_data.len() {
            let mut item_or_items: Value = Huobi::parse_ledger_entry(self, array_data.get(i.into()), currency.clone());
            if Array::is_array(item_or_items.clone()).is_truthy() {
                let mut j: usize = 0;
                while j < item_or_items.len() {
                    result.push(extend_2(item_or_items.get(j.into()), params.clone()));
                    j += 1;
                };
            } else {
                result.push(extend_2(item_or_items.clone(), params.clone()));
            };
            i += 1;
        };
        result = self.sort_by(result.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut code: Value = if currency.clone().is_nonnullish() { currency.get(Value::from("code")) } else { Value::Undefined };
        let mut tail: Value = (since.clone().is_nullish()).into();
        return Huobi::filter_by_currency_since_limit(self, result.clone(), code.clone(), since.clone(), limit.clone(), tail.clone());
    }

    fn nonce(&self) -> Value {
        return self.seconds();
    }

    fn set_headers(&mut self, mut headers: Value) -> Value {
        return headers.clone();
    }

    fn market_id(&mut self, mut symbol: Value) -> Value {
        let mut market: Value = Huobi::market(self, symbol.clone());
        if market.clone().is_nonnullish() {
            return market.get(Value::from("id"));
        };
        return symbol.clone();
    }

    fn symbol(&self, mut symbol: Value) -> Value {
        let mut market: Value = Huobi::market(self, symbol.clone());
        return self.safe_string(market.clone(), Value::from("symbol"), symbol.clone());
    }

    fn resolve_path(&mut self, mut path: Value, mut params: Value) -> Value {
        return Value::Json(serde_json::Value::Array(vec![self.implode_params(path.clone(), params.clone()).into(), self.omit(params.clone(), self.extract_params(path.clone())).into()]));
    }

    fn filter_by_array(&self, mut objects: Value, mut key: Value, mut values: Value, mut indexed: Value) -> Value {
        indexed = indexed.or_default(true.into());
        objects = self.to_array(objects.clone());
        // return all of them if no values were passed
        if values.clone().is_nullish() || !values.is_truthy() {
            return if indexed.is_truthy() { self.index_by(objects.clone(), key.clone(), Value::Undefined) } else { objects.clone() };
        };
        let mut results: Value = Value::new_array();
        let mut i: usize = 0;
        while i < objects.len() {
            if self.in_array(objects.get(i.into()).get(key.clone()), values.clone()).is_truthy() {
                results.push(objects.get(i.into()));
            };
            i += 1;
        };
        return if indexed.is_truthy() { self.index_by(results.clone(), key.clone(), Value::Undefined) } else { results.clone() };
    }

    async fn fetch2(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        if self.get("enable_rate_limit".into()).is_truthy() {
            let mut cost: Value = Huobi::calculate_rate_limiter_cost(self, api.clone(), method.clone(), path.clone(), params.clone(), config.clone(), context.clone());
            self.throttle(cost.clone()).await;
        };
        self.set("last_rest_request_timestamp".into(), self.milliseconds());
        let mut request: Value = Huobi::sign(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone());
        return self.fetch(request.get(Value::from("url")), request.get(Value::from("method")), request.get(Value::from("headers")), request.get(Value::from("body"))).await;
    }

    async fn request(&mut self, mut path: Value, mut api: Value, mut method: Value, mut params: Value, mut headers: Value, mut body: Value, mut config: Value, mut context: Value) -> Value {
        api = api.or_default(Value::from("public"));
        method = method.or_default(Value::from("GET"));
        params = params.or_default(Value::new_object());
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return Huobi::fetch2(self, path.clone(), api.clone(), method.clone(), params.clone(), headers.clone(), body.clone(), config.clone(), context.clone()).await;
    }

    async fn load_accounts(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if reload.is_truthy() {
            self.set("accounts".into(), Huobi::fetch_accounts(self, params.clone()).await);
        } else {
            if self.get("accounts".into()).is_truthy() {
                return self.get("accounts".into());
            } else {
                self.set("accounts".into(), Huobi::fetch_accounts(self, params.clone()).await);
            };
        };
        self.set("accounts_by_id".into(), self.index_by(self.get("accounts".into()), Value::from("id"), Value::Undefined));
        return self.get("accounts".into());
    }

    async fn fetch_ohlcvc(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTrades")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchOHLCV() is not supported yet"))"###);
        };
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        let mut trades: Value = Huobi::fetch_trades(self, symbol.clone(), since.clone(), limit.clone(), params.clone()).await;
        return self.build_ohlcvc(trades.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    fn parse_trading_view_ohlcv(&self, mut ohlcvs: Value, mut market: Value, mut timeframe: Value, mut since: Value, mut limit: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        let mut result: Value = Huobi::convert_trading_view_to_ohlcv(self, ohlcvs.clone(), Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined, Value::Undefined);
        return Huobi::parse_ohlcvs(self, result.clone(), market.clone(), timeframe.clone(), since.clone(), limit.clone());
    }

    async fn edit_limit_buy_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_sell_order(&mut self, mut id: Value, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::edit_limit_order(self, id.clone(), symbol.clone(), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_limit_order(&mut self, mut id: Value, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::edit_order(self, id.clone(), symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn edit_order(&mut self, mut id: Value, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::cancel_order(self, id.clone(), symbol.clone(), Value::Undefined).await;
        return Huobi::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn fetch_permissions(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPermissions() is not supported yet"))"###);
        Value::Undefined
    }

    async fn fetch_bids_asks(&mut self, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBidsAsks() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_bid_ask(&self, mut bidask: Value, mut price_key: Value, mut amount_key: Value) -> Value {
        price_key = price_key.or_default(Value::from(0));
        amount_key = amount_key.or_default(Value::from(1));
        let mut price: Value = Huobi::safe_number(self, bidask.clone(), price_key.clone(), Value::Undefined);
        let mut amount: Value = Huobi::safe_number(self, bidask.clone(), amount_key.clone(), Value::Undefined);
        return Value::Json(serde_json::Value::Array(vec![price.clone().into(), amount.clone().into()]));
    }

    fn safe_currency(&self, mut currency_id: Value, mut currency: Value) -> Value {
        if currency_id.clone().is_nullish() && currency.clone().is_nonnullish() {
            return currency.clone();
        };
        if self.get("currencies_by_id".into()).is_nonnullish() && self.get("currencies_by_id".into()).contains_key(currency_id.clone()) {
            return self.get("currencies_by_id".into()).get(currency_id.clone());
        };
        let mut code: Value = currency_id.clone();
        if currency_id.clone().is_nonnullish() {
            code = Huobi::common_currency_code(self, currency_id.to_upper_case());
        };
        return Value::Json(normalize(&Value::Json(json!({
            "id": currency_id,
            "code": code
        }))).unwrap());
    }

    fn safe_market(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        let mut result: Value = Value::Json(normalize(&Value::Json(json!({
            "id": market_id,
            "symbol": market_id,
            "base": Value::Undefined,
            "quote": Value::Undefined,
            "baseId": Value::Undefined,
            "quoteId": Value::Undefined,
            "active": Value::Undefined,
            "type": Value::Undefined,
            "linear": Value::Undefined,
            "inverse": Value::Undefined,
            "spot": false,
            "swap": false,
            "future": false,
            "option": false,
            "margin": false,
            "contract": false,
            "contractSize": Value::Undefined,
            "expiry": Value::Undefined,
            "expiryDatetime": Value::Undefined,
            "optionType": Value::Undefined,
            "strike": Value::Undefined,
            "settle": Value::Undefined,
            "settleId": Value::Undefined,
            "precision": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Undefined,
                "price": Value::Undefined
            }))).unwrap()),
            "limits": Value::Json(normalize(&Value::Json(json!({
                "amount": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "price": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap()),
                "cost": Value::Json(normalize(&Value::Json(json!({
                    "min": Value::Undefined,
                    "max": Value::Undefined
                }))).unwrap())
            }))).unwrap()),
            "info": Value::Undefined
        }))).unwrap());
        if market_id.clone().is_nonnullish() {
            if self.get("markets_by_id".into()).is_nonnullish() && self.get("markets_by_id".into()).contains_key(market_id.clone()) {
                market = self.get("markets_by_id".into()).get(market_id.clone());
            } else if delimiter.clone().is_nonnullish() {
                let mut parts: Value = market_id.split(delimiter.clone());
                let mut parts_length: Value = parts.len().into();
                if parts_length.clone() == Value::from(2) {
                    result.set("baseId".into(), self.safe_string(parts.clone(), Value::from(0), Value::Undefined));
                    result.set("quoteId".into(), self.safe_string(parts.clone(), Value::from(1), Value::Undefined));
                    result.set("base".into(), Huobi::safe_currency_code(self, result.get(Value::from("baseId")), Value::Undefined));
                    result.set("quote".into(), Huobi::safe_currency_code(self, result.get(Value::from("quoteId")), Value::Undefined));
                    result.set("symbol".into(), result.get(Value::from("base")) + Value::from("/") + result.get(Value::from("quote")));
                    return result.clone();
                } else {
                    return result.clone();
                };
            };
        };
        if market.clone().is_nonnullish() {
            return market.clone();
        };
        return result.clone();
    }

    fn check_required_credentials(&mut self, mut error: Value) -> Value {
        error = error.or_default(true.into());
        let mut keys: Value = Object::keys(self.get("required_credentials".into()));
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if self.get("required_credentials".into()).get(key.clone()).is_truthy() && !self.get(key.clone()).is_truthy() {
                if error.is_truthy() {
                    panic!(r###"AuthenticationError::new(self.get("id".into()) + Value::from(r#" requires ""#) + key.clone() + Value::from(r#"" credential"#))"###);
                } else {
                    return error.clone();
                };
            };
            i += 1;
        };
        return true.into();
    }

    fn oath(&mut self) -> Value {
        if self.get("twofa".into()).is_nonnullish() {
            return self.totp(self.get("twofa".into()));
        } else {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" exchange.twofa has not been set for 2FA Two-Factor Authentication"))"###);
        };
        Value::Undefined
    }

    async fn fetch_partial_balance(&mut self, mut part: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut balance: Value = Huobi::fetch_balance(self, params.clone()).await;
        return balance.get(part.clone());
    }

    async fn fetch_free_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::fetch_partial_balance(self, Value::from("free"), params.clone()).await;
    }

    async fn fetch_used_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::fetch_partial_balance(self, Value::from("used"), params.clone()).await;
    }

    async fn fetch_total_balance(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::fetch_partial_balance(self, Value::from("total"), params.clone()).await;
    }

    async fn fetch_funding_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fee: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFee"), true.into());
        if warn_on_fetch_funding_fee.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options["warnOnFetchFundingFee"] = false to suppress this warning"#))"###);
        };
        return Huobi::fetch_transaction_fee(self, code.clone(), params.clone()).await;
    }

    async fn fetch_funding_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut warn_on_fetch_funding_fees: Value = self.safe_value(self.get("options".into()), Value::from("warnOnFetchFundingFees"), true.into());
        if warn_on_fetch_funding_fees.is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(r#" fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options["warnOnFetchFundingFees"] = false to suppress this warning"#))"###);
        };
        return Huobi::fetch_transaction_fees(self, codes.clone(), params.clone()).await;
    }

    async fn fetch_transaction_fee(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("fetchTransactionFees")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFee() is not supported yet"))"###);
        };
        return Huobi::fetch_transaction_fees(self, Value::Json(serde_json::Value::Array(vec![code.clone().into()])), params.clone()).await;
    }

    async fn fetch_transaction_fees(&mut self, mut codes: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactionFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn get_supported_mapping(&self, mut key: Value, mut mapping: Value) -> Value {
        mapping = mapping.or_default(Value::new_object());
        if mapping.contains_key(key.clone()) {
            return mapping.get(key.clone());
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" ") + key.clone() + Value::from(" does not have a value in mapping"))"###);
        };
        Value::Undefined
    }

    async fn fetch_borrow_rate(&mut self, mut code: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        Huobi::load_markets(self, Value::Undefined, Value::Undefined).await;
        if !self.get("has".into()).get(Value::from("fetchBorrowRates")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchBorrowRate() is not supported yet"))"###);
        };
        let mut borrow_rates: Value = Huobi::fetch_borrow_rates(self, params.clone()).await;
        let mut rate: Value = self.safe_value(borrow_rates.clone(), code.clone(), Value::Undefined);
        if rate.clone().is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" fetchBorrowRate() could not find the borrow rate for currency code ") + code.clone())"###);
        };
        return rate.clone();
    }

    fn handle_market_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_type: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultType"), Value::from("type"), Value::from("spot"));
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::Undefined);
        let mut method_type: Value = default_type.clone();
        if method_options.clone().is_nonnullish() {
            if method_options.typeof_() == Value::from("string") {
                method_type = method_options.clone();
            } else {
                method_type = self.safe_string_2(method_options.clone(), Value::from("defaultType"), Value::from("type"), method_type.clone());
            };
        };
        let mut market_type: Value = if market.clone().is_nullish() { method_type.clone() } else { market.get(Value::from("type")) };
        let mut r#type: Value = self.safe_string_2(params.clone(), Value::from("defaultType"), Value::from("type"), market_type.clone());
        params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultType").into(), Value::from("type").into()])));
        return Value::Json(serde_json::Value::Array(vec![r#type.clone().into(), params.clone().into()]));
    }

    fn handle_sub_type_and_params(&mut self, mut method_name: Value, mut market: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut sub_type: Value = Value::Undefined;
        // if set in params, it takes precedence
        let mut sub_type_in_params: Value = self.safe_string_2(params.clone(), Value::from("subType"), Value::from("subType"), Value::Undefined);
        // avoid omitting if it's not present
        if sub_type_in_params.clone().is_nonnullish() {
            sub_type = sub_type_in_params.clone();
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("defaultSubType").into(), Value::from("subType").into()])));
        } else {
            // at first, check from market object
            if market.clone().is_nonnullish() {
                if market.get(Value::from("linear")).is_truthy() {
                    sub_type = Value::from("linear");
                } else if market.get(Value::from("inverse")).is_truthy() {
                    sub_type = Value::from("inverse");
                };
            };
            // if it was not defined in market object
            if sub_type.clone().is_nullish() {
                let mut exchange_wide_value: Value = self.safe_string_2(self.get("options".into()), Value::from("defaultSubType"), Value::from("subType"), Value::from("linear"));
                let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
                sub_type = self.safe_string_2(method_options.clone(), Value::from("defaultSubType"), Value::from("subType"), exchange_wide_value.clone());
            };
        };
        return Value::Json(serde_json::Value::Array(vec![sub_type.clone().into(), params.clone().into()]));
    }

    fn throw_exactly_matched_exception(&mut self, mut exact: Value, mut string: Value, mut message: Value) -> () {
        if exact.contains_key(string.clone()) {
            panic!(r###"exact.get(string.clone())::new(message)"###);
        };
    }

    fn throw_broadly_matched_exception(&mut self, mut broad: Value, mut string: Value, mut message: Value) -> () {
        let mut broad_key: Value = Huobi::find_broadly_matched_key(self, broad.clone(), string.clone());
        if broad_key.clone().is_nonnullish() {
            panic!(r###"broad.get(broad_key.clone())::new(message)"###);
        };
    }

    fn find_broadly_matched_key(&mut self, mut broad: Value, mut string: Value) -> Value {
        // a helper for matching error strings exactly vs broadly
        let mut keys: Value = Object::keys(broad.clone());
        let mut i: usize = 0;
        while i < keys.len() {
            let mut key: Value = keys.get(i.into());
            if string.index_of(key.clone()) >= Value::from(0) {
                return key.clone();
            };
            i += 1;
        };
        return Value::Undefined;
    }

    fn calculate_rate_limiter_cost(&mut self, mut api: Value, mut method: Value, mut path: Value, mut params: Value, mut config: Value, mut context: Value) -> Value {
        config = config.or_default(Value::new_object());
        context = context.or_default(Value::new_object());
        return self.safe_value(config.clone(), Value::from("cost"), Value::from(1));
    }

    async fn fetch_order_status(&mut self, mut id: Value, mut symbol: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut order: Value = Huobi::fetch_order(self, id.clone(), symbol.clone(), params.clone()).await;
        return order.get(Value::from("status"));
    }

    async fn fetch_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::fetch_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn cancel_unified_order(&mut self, mut order: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::cancel_order(self, self.safe_value(order.clone(), Value::from("id"), Value::Undefined), self.safe_value(order.clone(), Value::from("symbol"), Value::Undefined), params.clone()).await;
    }

    async fn fetch_transactions(&mut self, mut symbol: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTransactions() is not supported yet"))"###);
        Value::Undefined
    }

    fn account(&self) -> Value {
        return Value::Json(normalize(&Value::Json(json!({
            "free": Value::Undefined,
            "used": Value::Undefined,
            "total": Value::Undefined
        }))).unwrap());
    }

    fn common_currency_code(&self, mut currency: Value) -> Value {
        if !self.get("substitute_common_currency_codes".into()).is_truthy() {
            return currency.clone();
        };
        return self.safe_string(self.get("common_currencies".into()), currency.clone(), currency.clone());
    }

    fn currency(&self, mut code: Value) -> Value {
        if self.get("currencies".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" currencies not loaded"))"###);
        };
        if code.typeof_() == Value::from("string") {
            if self.get("currencies".into()).contains_key(code.clone()) {
                return self.get("currencies".into()).get(code.clone());
            } else if self.get("currencies_by_id".into()).contains_key(code.clone()) {
                return self.get("currencies_by_id".into()).get(code.clone());
            };
        };
        panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" does not have currency code ") + code.clone())"###);
        Value::Undefined
    }

    fn market(&self, mut symbol: Value) -> Value {
        if self.get("markets".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if self.get("markets_by_id".into()).is_nullish() {
            panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(" markets not loaded"))"###);
        };
        if symbol.typeof_() == Value::from("string") {
            if self.get("markets".into()).contains_key(symbol.clone()) {
                return self.get("markets".into()).get(symbol.clone());
            } else if self.get("markets_by_id".into()).contains_key(symbol.clone()) {
                return self.get("markets_by_id".into()).get(symbol.clone());
            };
        };
        panic!(r###"BadSymbol::new(self.get("id".into()) + Value::from(" does not have market symbol ") + symbol.clone())"###);
        Value::Undefined
    }

    fn handle_withdraw_tag_and_params(&mut self, mut tag: Value, mut params: Value) -> Value {
        if tag.typeof_() == Value::from("object") {
            params = extend_2(tag.clone(), params.clone());
            tag = Value::Undefined;
        };
        if tag.clone().is_nullish() {
            tag = self.safe_string(params.clone(), Value::from("tag"), Value::Undefined);
            if tag.clone().is_nonnullish() {
                params = self.omit(params.clone(), Value::from("tag"));
            };
        };
        return Value::Json(serde_json::Value::Array(vec![tag.clone().into(), params.clone().into()]));
    }

    async fn create_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::create_order(self, symbol.clone(), Value::from("limit"), Value::from("buy"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_limit_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::create_order(self, symbol.clone(), Value::from("limit"), Value::from("sell"), amount.clone(), price.clone(), params.clone()).await;
    }

    async fn create_market_buy_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::create_order(self, symbol.clone(), Value::from("market"), Value::from("buy"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    async fn create_market_sell_order(&mut self, mut symbol: Value, mut amount: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        return Huobi::create_order(self, symbol.clone(), Value::from("market"), Value::from("sell"), amount.clone(), Value::Undefined, params.clone()).await;
    }

    fn price_to_precision(&mut self, mut symbol: Value, mut price: Value) -> Value {
        let mut market: Value = Huobi::market(self, symbol.clone());
        return self.decimal_to_precision(price.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn amount_to_precision(&mut self, mut symbol: Value, mut amount: Value) -> Value {
        let mut market: Value = Huobi::market(self, symbol.clone());
        return self.decimal_to_precision(amount.clone(), TRUNCATE.into(), market.get(Value::from("precision")).get(Value::from("amount")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn fee_to_precision(&mut self, mut symbol: Value, mut fee: Value) -> Value {
        let mut market: Value = Huobi::market(self, symbol.clone());
        return self.decimal_to_precision(fee.clone(), ROUND.into(), market.get(Value::from("precision")).get(Value::from("price")), self.get("precision_mode".into()), self.get("padding_mode".into()));
    }

    fn currency_to_precision(&mut self, mut code: Value, mut fee: Value, mut network_code: Value) -> Value {
        let mut currency: Value = self.get("currencies".into()).get(code.clone());
        let mut precision: Value = self.safe_value(currency.clone(), Value::from("precision"), Value::Undefined);
        if network_code.clone().is_nonnullish() {
            let mut networks: Value = self.safe_value(currency.clone(), Value::from("networks"), Value::new_object());
            let mut network_item: Value = self.safe_value(networks.clone(), network_code.clone(), Value::new_object());
            precision = self.safe_value(network_item.clone(), Value::from("precision"), precision.clone());
        };
        if precision.clone().is_nullish() {
            return fee.clone();
        } else {
            return self.decimal_to_precision(fee.clone(), ROUND.into(), precision.clone(), self.get("precision_mode".into()), self.get("padding_mode".into()));
        };
        Value::Undefined
    }

    fn safe_number(&self, mut object: Value, mut key: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string(object.clone(), key.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn safe_number_n(&self, mut object: Value, mut arr: Value, mut d: Value) -> Value {
        let mut value: Value = self.safe_string_n(object.clone(), arr.clone(), Value::Undefined);
        return self.parse_number(value.clone(), d.clone());
    }

    fn parse_precision(&self, mut precision: Value) -> Value {
        if precision.clone().is_nullish() {
            return Value::Undefined;
        };
        return Value::from("1e") + Precise::string_neg(precision.clone());
    }

    async fn load_time_difference(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut server_time: Value = Huobi::fetch_time(self, params.clone()).await;
        let mut after: Value = self.milliseconds();
        self.get("options".into()).set("timeDifference".into(), after.clone() - server_time.clone());
        return self.get("options".into()).get(Value::from("timeDifference"));
    }

    fn implode_hostname(&mut self, mut url: Value) -> Value {
        return self.implode_params(url.clone(), Value::Json(normalize(&Value::Json(json!({
            "hostname": self.get("hostname".into())
        }))).unwrap()));
    }

    async fn create_post_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createPostOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createPostOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "postOnly": true
        }))).unwrap()));
        return Huobi::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_reduce_only_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createReduceOnlyOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from("createReduceOnlyOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "reduceOnly": true
        }))).unwrap()));
        return Huobi::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_order(&mut self, mut symbol: Value, mut r#type: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopOrder() is not supported yet"))"###);
        };
        if stop_price.clone().is_nullish() {
            panic!(r###"ArgumentsRequired::new(self.get("id".into()) + Value::from(" create_stop_order() requires a stopPrice argument"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Huobi::create_order(self, symbol.clone(), r#type.clone(), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_limit_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut price: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopLimitOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopLimitOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Huobi::create_order(self, symbol.clone(), Value::from("limit"), side.clone(), amount.clone(), price.clone(), query.clone()).await;
    }

    async fn create_stop_market_order(&mut self, mut symbol: Value, mut side: Value, mut amount: Value, mut stop_price: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        if !self.get("has".into()).get(Value::from("createStopMarketOrder")).is_truthy() {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" createStopMarketOrder() is not supported yet"))"###);
        };
        let mut query: Value = extend_2(params.clone(), Value::Json(normalize(&Value::Json(json!({
            "stopPrice": stop_price
        }))).unwrap()));
        return Huobi::create_order(self, symbol.clone(), Value::from("market"), side.clone(), amount.clone(), Value::Undefined, query.clone()).await;
    }

    fn safe_currency_code(&self, mut currency_id: Value, mut currency: Value) -> Value {
        currency = Huobi::safe_currency(self, currency_id.clone(), currency.clone());
        return currency.get(Value::from("code"));
    }

    fn filter_by_symbol_since_limit(&self, mut array: Value, mut symbol: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("symbol"), symbol.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn filter_by_currency_since_limit(&self, mut array: Value, mut code: Value, mut since: Value, mut limit: Value, mut tail: Value) -> Value {
        tail = tail.or_default(false.into());
        return self.filter_by_value_since_limit(array.clone(), Value::from("currency"), code.clone(), since.clone(), limit.clone(), Value::from("timestamp"), tail.clone());
    }

    fn parse_tickers(&self, mut tickers: Value, mut symbols: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        let mut results: Value = Value::new_array();
        if Array::is_array(tickers.clone()).is_truthy() {
            let mut i: usize = 0;
            while i < tickers.len() {
                let mut ticker: Value = extend_2(Huobi::parse_ticker(self, tickers.get(i.into()), Value::Undefined), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        } else {
            let mut market_ids: Value = Object::keys(tickers.clone());
            let mut i: usize = 0;
            while i < market_ids.len() {
                let mut market_id: Value = market_ids.get(i.into());
                let mut market: Value = Huobi::safe_market(self, market_id.clone(), Value::Undefined, Value::Undefined);
                let mut ticker: Value = extend_2(Huobi::parse_ticker(self, tickers.get(market_id.clone()), market.clone()), params.clone());
                results.push(ticker.clone());
                i += 1;
            };
        };
        symbols = Huobi::market_symbols(self, symbols.clone());
        return Huobi::filter_by_array(self, results.clone(), Value::from("symbol"), symbols.clone(), Value::Undefined);
    }

    fn parse_deposit_addresses(&self, mut addresses: Value, mut codes: Value, mut indexed: Value, mut params: Value) -> Value {
        indexed = indexed.or_default(true.into());
        params = params.or_default(Value::new_object());
        let mut result: Value = Value::new_array();
        let mut i: usize = 0;
        while i < addresses.len() {
            let mut address: Value = extend_2(Huobi::parse_deposit_address(self, addresses.get(i.into()), Value::Undefined), params.clone());
            result.push(address.clone());
            i += 1;
        };
        if codes.clone().is_nonnullish() {
            result = Huobi::filter_by_array(self, result.clone(), Value::from("currency"), codes.clone(), false.into());
        };
        result = if indexed.is_truthy() { self.index_by(result.clone(), Value::from("currency"), Value::Undefined) } else { result.clone() };
        return result.clone();
    }

    fn parse_borrow_interests(&self, mut response: Value, mut market: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut row: Value = response.get(i.into());
            interests.push(Huobi::parse_borrow_interest(self, row.clone(), market.clone()));
            i += 1;
        };
        return interests.clone();
    }

    fn parse_funding_rate_histories(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut rates: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            rates.push(self.parse_funding_rate_history(entry.clone(), market.clone()));
            i += 1;
        };
        let mut sorted: Value = self.sort_by(rates.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = if market.clone().is_nullish() { Value::Undefined } else { market.get(Value::from("symbol")) };
        return Huobi::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    fn safe_symbol(&self, mut market_id: Value, mut market: Value, mut delimiter: Value) -> Value {
        market = Huobi::safe_market(self, market_id.clone(), market.clone(), delimiter.clone());
        return market.get(Value::from("symbol"));
    }

    fn parse_funding_rates(&self, mut response: Value, mut market: Value) -> Value {
        let mut result: Value = Value::new_object();
        let mut i: usize = 0;
        while i < response.len() {
            let mut parsed: Value = Huobi::parse_funding_rate(self, response.get(i.into()), market.clone());
            result.set(parsed.get(Value::from("symbol")), parsed.clone());
            i += 1;
        };
        return result.clone();
    }

    /// Returns true if a post only order, false otherwise
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `type` {string} - Order type
    /// * `exchangeSpecificParam` {boolean} - exchange specific postOnly
    /// * `params` {object} - exchange specific params
    fn is_post_only(&mut self, mut is_market_order: Value, mut exchange_specific_param: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        let mut post_only: Value = self.safe_value_2(params.clone(), Value::from("postOnly"), Value::from("post_only"), false.into());
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        let mut ioc: Value = (time_in_force.clone() == Value::from("IOC")).into();
        let mut fok: Value = (time_in_force.clone() == Value::from("FOK")).into();
        let mut time_in_force_post_only: Value = (time_in_force.clone() == Value::from("PO")).into();
        post_only = (post_only.is_truthy() || time_in_force_post_only.is_truthy() || exchange_specific_param.is_truthy()).into();
        if post_only.is_truthy() {
            if ioc.is_truthy() || fok.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" postOnly orders cannot have timeInForce equal to ") + time_in_force.clone())"###);
            } else if is_market_order.is_truthy() {
                panic!(r###"InvalidOrder::new(self.get("id".into()) + Value::from(" market orders cannot be postOnly"))"###);
            } else {
                return true.into();
            };
        } else {
            return false.into();
        };
        Value::Undefined
    }

    async fn fetch_trading_fees(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchTradingFees() is not supported yet"))"###);
        Value::Undefined
    }

    fn parse_open_interests(&self, mut response: Value, mut market: Value, mut since: Value, mut limit: Value) -> Value {
        let mut interests: Value = Value::new_array();
        let mut i: usize = 0;
        while i < response.len() {
            let mut entry: Value = response.get(i.into());
            let mut interest: Value = Huobi::parse_open_interest(self, entry.clone(), market.clone());
            interests.push(interest.clone());
            i += 1;
        };
        let mut sorted: Value = self.sort_by(interests.clone(), Value::from("timestamp"), Value::Undefined, Value::Undefined);
        let mut symbol: Value = self.safe_string(market.clone(), Value::from("symbol"), Value::Undefined);
        return Huobi::filter_by_symbol_since_limit(self, sorted.clone(), symbol.clone(), since.clone(), limit.clone(), Value::Undefined);
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_mark_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchMarkOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "mark"
            }))).unwrap());
            return Huobi::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchMarkOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "index"
            }))).unwrap());
            return Huobi::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns a list of candles ordered as timestamp, open, high, low, close, undefined
    ///
    /// Fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    ///
    /// # Arguments
    ///
    /// * `symbol` {string} - unified symbol of the market to fetch OHLCV data for
    /// * `timeframe` {string} - the length of time each candle represents
    /// * `since` {int|undefined} - timestamp in ms of the earliest candle to fetch
    /// * `limit` {int|undefined} - the maximum amount of candles to fetch
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    async fn fetch_premium_index_ohlcv(&mut self, mut symbol: Value, mut timeframe: Value, mut since: Value, mut limit: Value, mut params: Value) -> Value {
        timeframe = timeframe.or_default(Value::from("1m"));
        params = params.or_default(Value::new_object());
        if self.get("has".into()).get(Value::from("fetchPremiumIndexOHLCV")).is_truthy() {
            let mut request: Value = Value::Json(normalize(&Value::Json(json!({
                "price": "premiumIndex"
            }))).unwrap());
            return Huobi::fetch_ohlcv(self, symbol.clone(), timeframe.clone(), since.clone(), limit.clone(), extend_2(request.clone(), params.clone())).await;
        } else {
            panic!(r###"NotSupported::new(self.get("id".into()) + Value::from(" fetchPremiumIndexOHLCV () is not supported yet"))"###);
        };
        Value::Undefined
    }

    /// Returns returns the exchange specific value for timeInForce
    ///
    /// @ignore
    /// * Must add timeInForce to this.options to use this method
    fn handle_time_in_force(&mut self, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut time_in_force: Value = self.safe_string_upper(params.clone(), Value::from("timeInForce"), Value::Undefined);
        // supported values GTC, IOC, PO
        if time_in_force.clone().is_nonnullish() {
            let mut exchange_value: Value = self.safe_string(self.get("options".into()).get(Value::from("timeInForce")), time_in_force.clone(), Value::Undefined);
            if exchange_value.clone().is_nullish() {
                panic!(r###"ExchangeError::new(self.get("id".into()) + Value::from(r#" does not support timeInForce ""#) + time_in_force.clone() + Value::from(r#"""#))"###);
            };
            return exchange_value.clone();
        };
        return Value::Undefined;
    }

    /// Returns {[string|undefined, object]} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    ///
    /// @ignore
    ///
    /// # Arguments
    ///
    /// * `params` {object} - extra parameters specific to the exchange api endpoint
    fn handle_margin_mode_and_params(&mut self, mut method_name: Value, mut params: Value) -> Value {
        params = params.or_default(Value::new_object());
        let mut default_margin_mode: Value = self.safe_string_2(self.get("options".into()), Value::from("marginMode"), Value::from("defaultMarginMode"), Value::Undefined);
        let mut method_options: Value = self.safe_value(self.get("options".into()), method_name.clone(), Value::new_object());
        let mut method_margin_mode: Value = self.safe_string_2(method_options.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), default_margin_mode.clone());
        let mut margin_mode: Value = self.safe_string_lower_2(params.clone(), Value::from("marginMode"), Value::from("defaultMarginMode"), method_margin_mode.clone());
        if margin_mode.clone().is_nonnullish() {
            params = self.omit(params.clone(), Value::Json(serde_json::Value::Array(vec![Value::from("marginMode").into(), Value::from("defaultMarginMode").into()])));
        };
        return Value::Json(serde_json::Value::Array(vec![margin_mode.clone().into(), params.clone().into()]));
    }

    async fn load_markets_helper(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        if !reload.is_truthy() && self.get("markets".into()).is_truthy() {
            if !self.get("markets_by_id".into()).is_truthy() {
                return Huobi::set_markets(self, self.get("markets".into()), Value::Undefined);
            };
            return self.get("markets".into());
        };
        let mut currencies: Value = Value::Undefined;
        // only call if exchange API provides endpoint (true), thus avoid emulated versions ('emulated')
        if self.get("has".into()).get(Value::from("fetchCurrencies")) == true.into() {
            currencies = Huobi::fetch_currencies(self, Value::Undefined).await;
        };
        let mut markets: Value = Huobi::fetch_markets(self, params.clone()).await;
        return Huobi::set_markets(self, markets.clone(), currencies.clone());
    }

    async fn load_markets(&mut self, mut reload: Value, mut params: Value) -> Value {
        reload = reload.or_default(false.into());
        params = params.or_default(Value::new_object());
        // this method is async, it returns a promise
        if reload.is_truthy() && !self.get("reloading_markets".into()).is_truthy() || !self.get("markets_loading".into()).is_truthy() {
            self.set("reloading_markets".into(), true.into());
            // TODO This should use a finally block
            let mut markets_loading: Value = Huobi::load_markets_helper(self, reload.clone(), params.clone()).await;
            self.set("markets_loading".into(), markets_loading.clone());
            self.set("reloading_markets".into(), false.into());
            return self.get("markets_loading".into());
        };
        return self.get("markets_loading".into());
    }

    
    async fn dispatch(&mut self, method: Value, params: Value, context: Value) -> Value {
        match method {
            Value::Json(serde_json::Value::String(ref m)) => {
                match m.as_ref() {
                    "v2PublicGetReferenceCurrencies" => Huobi::request(self, "reference/currencies".into(), "v2Public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PublicGetMarketStatus" => Huobi::request(self, "market-status".into(), "v2Public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAccountLedger" => Huobi::request(self, "account/ledger".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAccountWithdrawQuota" => Huobi::request(self, "account/withdraw/quota".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAccountWithdrawAddress" => Huobi::request(self, "account/withdraw/address".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAccountDepositAddress" => Huobi::request(self, "account/deposit/address".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAccountRepayment" => Huobi::request(self, "account/repayment".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetReferenceTransactFeeRate" => Huobi::request(self, "reference/transact-fee-rate".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAccountAssetValuation" => Huobi::request(self, "account/asset-valuation".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetPointAccount" => Huobi::request(self, "point/account".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetSubUserUserList" => Huobi::request(self, "sub-user/user-list".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetSubUserUserState" => Huobi::request(self, "sub-user/user-state".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetSubUserAccountList" => Huobi::request(self, "sub-user/account-list".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetSubUserDepositAddress" => Huobi::request(self, "sub-user/deposit-address".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetSubUserQueryDeposit" => Huobi::request(self, "sub-user/query-deposit".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetUserApiKey" => Huobi::request(self, "user/api-key".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetUserUid" => Huobi::request(self, "user/uid".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAlgoOrdersOpening" => Huobi::request(self, "algo-orders/opening".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAlgoOrdersHistory" => Huobi::request(self, "algo-orders/history".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetAlgoOrdersSpecific" => Huobi::request(self, "algo-orders/specific".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetC2cOffers" => Huobi::request(self, "c2c/offers".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetC2cOffer" => Huobi::request(self, "c2c/offer".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetC2cTransactions" => Huobi::request(self, "c2c/transactions".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetC2cRepayment" => Huobi::request(self, "c2c/repayment".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetC2cAccount" => Huobi::request(self, "c2c/account".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetEtpReference" => Huobi::request(self, "etp/reference".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetEtpTransactions" => Huobi::request(self, "etp/transactions".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetEtpTransaction" => Huobi::request(self, "etp/transaction".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetEtpRebalance" => Huobi::request(self, "etp/rebalance".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivateGetEtpLimit" => Huobi::request(self, "etp/limit".into(), "v2Private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostAccountTransfer" => Huobi::request(self, "account/transfer".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostAccountRepayment" => Huobi::request(self, "account/repayment".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostPointTransfer" => Huobi::request(self, "point/transfer".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserManagement" => Huobi::request(self, "sub-user/management".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserCreation" => Huobi::request(self, "sub-user/creation".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserTradableMarket" => Huobi::request(self, "sub-user/tradable-market".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserTransferability" => Huobi::request(self, "sub-user/transferability".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserApiKeyGeneration" => Huobi::request(self, "sub-user/api-key-generation".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserApiKeyModification" => Huobi::request(self, "sub-user/api-key-modification".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserApiKeyDeletion" => Huobi::request(self, "sub-user/api-key-deletion".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostSubUserDeductMode" => Huobi::request(self, "sub-user/deduct-mode".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostAlgoOrders" => Huobi::request(self, "algo-orders".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostAlgoOrdersCancelAllAfter" => Huobi::request(self, "algo-orders/cancel-all-after".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostAlgoOrdersCancellation" => Huobi::request(self, "algo-orders/cancellation".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostC2cOffer" => Huobi::request(self, "c2c/offer".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostC2cCancellation" => Huobi::request(self, "c2c/cancellation".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostC2cCancelAll" => Huobi::request(self, "c2c/cancel-all".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostC2cRepayment" => Huobi::request(self, "c2c/repayment".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostC2cTransfer" => Huobi::request(self, "c2c/transfer".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostEtpCreation" => Huobi::request(self, "etp/creation".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostEtpRedemption" => Huobi::request(self, "etp/redemption".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostEtpTransactIdCancel" => Huobi::request(self, "etp/{transactId}/cancel".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "v2PrivatePostEtpBatchCancel" => Huobi::request(self, "etp/batch-cancel".into(), "v2Private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetHistoryKline" => Huobi::request(self, "history/kline".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetDetailMerged" => Huobi::request(self, "detail/merged".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetDepth" => Huobi::request(self, "depth".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetTrade" => Huobi::request(self, "trade".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetHistoryTrade" => Huobi::request(self, "history/trade".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetDetail" => Huobi::request(self, "detail".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetTickers" => Huobi::request(self, "tickers".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "marketGetEtp" => Huobi::request(self, "etp".into(), "market".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCommonSymbols" => Huobi::request(self, "common/symbols".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCommonCurrencys" => Huobi::request(self, "common/currencys".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCommonTimestamp" => Huobi::request(self, "common/timestamp".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetCommonExchange" => Huobi::request(self, "common/exchange".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "publicGetSettingsCurrencys" => Huobi::request(self, "settings/currencys".into(), "public".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountAccounts" => Huobi::request(self, "account/accounts".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountAccountsIdBalance" => Huobi::request(self, "account/accounts/{id}/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountAccountsSubUid" => Huobi::request(self, "account/accounts/{sub-uid}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetAccountHistory" => Huobi::request(self, "account/history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetCrossMarginLoanInfo" => Huobi::request(self, "cross-margin/loan-info".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginLoanInfo" => Huobi::request(self, "margin/loan-info".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetFeeFeeRateGet" => Huobi::request(self, "fee/fee-rate/get".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderOpenOrders" => Huobi::request(self, "order/openOrders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderOrders" => Huobi::request(self, "order/orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderOrdersId" => Huobi::request(self, "order/orders/{id}".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderOrdersIdMatchresults" => Huobi::request(self, "order/orders/{id}/matchresults".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderOrdersGetClientOrder" => Huobi::request(self, "order/orders/getClientOrder".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderHistory" => Huobi::request(self, "order/history".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetOrderMatchresults" => Huobi::request(self, "order/matchresults".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetQueryDepositWithdraw" => Huobi::request(self, "query/deposit-withdraw".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginLoanOrders" => Huobi::request(self, "margin/loan-orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetMarginAccountsBalance" => Huobi::request(self, "margin/accounts/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetCrossMarginLoanOrders" => Huobi::request(self, "cross-margin/loan-orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetCrossMarginAccountsBalance" => Huobi::request(self, "cross-margin/accounts/balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPointsActions" => Huobi::request(self, "points/actions".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetPointsOrders" => Huobi::request(self, "points/orders".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetSubuserAggregateBalance" => Huobi::request(self, "subuser/aggregate-balance".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetStableCoinExchangeRate" => Huobi::request(self, "stable-coin/exchange_rate".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privateGetStableCoinQuote" => Huobi::request(self, "stable-coin/quote".into(), "private".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostAccountTransfer" => Huobi::request(self, "account/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostFuturesTransfer" => Huobi::request(self, "futures/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderBatchOrders" => Huobi::request(self, "order/batch-orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderOrdersPlace" => Huobi::request(self, "order/orders/place".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderOrdersSubmitCancelClientOrder" => Huobi::request(self, "order/orders/submitCancelClientOrder".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderOrdersBatchCancelOpenOrders" => Huobi::request(self, "order/orders/batchCancelOpenOrders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderOrdersIdSubmitcancel" => Huobi::request(self, "order/orders/{id}/submitcancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostOrderOrdersBatchcancel" => Huobi::request(self, "order/orders/batchcancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostDwWithdrawApiCreate" => Huobi::request(self, "dw/withdraw/api/create".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostDwWithdrawVirtualIdCancel" => Huobi::request(self, "dw/withdraw-virtual/{id}/cancel".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostDwTransferInMargin" => Huobi::request(self, "dw/transfer-in/margin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostDwTransferOutMargin" => Huobi::request(self, "dw/transfer-out/margin".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginOrders" => Huobi::request(self, "margin/orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostMarginOrdersIdRepay" => Huobi::request(self, "margin/orders/{id}/repay".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCrossMarginTransferIn" => Huobi::request(self, "cross-margin/transfer-in".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCrossMarginTransferOut" => Huobi::request(self, "cross-margin/transfer-out".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCrossMarginOrders" => Huobi::request(self, "cross-margin/orders".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostCrossMarginOrdersIdRepay" => Huobi::request(self, "cross-margin/orders/{id}/repay".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostStableCoinExchange" => Huobi::request(self, "stable-coin/exchange".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "privatePostSubuserTransfer" => Huobi::request(self, "subuser/transfer".into(), "private".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "statusPublicSpotGetApiV2SummaryJson" => Huobi::request(self, "api/v2/summary.json".into(), "status".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "statusPublicFutureInverseGetApiV2SummaryJson" => Huobi::request(self, "api/v2/summary.json".into(), "status".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "statusPublicFutureLinearGetApiV2SummaryJson" => Huobi::request(self, "api/v2/summary.json".into(), "status".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "statusPublicSwapInverseGetApiV2SummaryJson" => Huobi::request(self, "api/v2/summary.json".into(), "status".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "statusPublicSwapLinearGetApiV2SummaryJson" => Huobi::request(self, "api/v2/summary.json".into(), "status".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV2MarketStatus" => Huobi::request(self, "v2/market-status".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV1CommonSymbols" => Huobi::request(self, "v1/common/symbols".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV1CommonCurrencys" => Huobi::request(self, "v1/common/currencys".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV2ReferenceCurrencies" => Huobi::request(self, "v2/reference/currencies".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV1CommonTimestamp" => Huobi::request(self, "v1/common/timestamp".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV1CommonExchange" => Huobi::request(self, "v1/common/exchange".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketHistoryCandles" => Huobi::request(self, "market/history/candles".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketHistoryKline" => Huobi::request(self, "market/history/kline".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketDetailMerged" => Huobi::request(self, "market/detail/merged".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketTickers" => Huobi::request(self, "market/tickers".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketDepth" => Huobi::request(self, "market/depth".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketTrade" => Huobi::request(self, "market/trade".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketHistoryTrade" => Huobi::request(self, "market/history/trade".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketDetail" => Huobi::request(self, "market/detail/".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetMarketEtp" => Huobi::request(self, "market/etp".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV2EtpReference" => Huobi::request(self, "v2/etp/reference".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPublicGetV2EtpRebalance" => Huobi::request(self, "v2/etp/rebalance".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1AccountAccounts" => Huobi::request(self, "v1/account/accounts".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1AccountAccountsAccountIdBalance" => Huobi::request(self, "v1/account/accounts/{account-id}/balance".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountValuation" => Huobi::request(self, "v2/account/valuation".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountAssetValuation" => Huobi::request(self, "v2/account/asset-valuation".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1AccountHistory" => Huobi::request(self, "v1/account/history".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountLedger" => Huobi::request(self, "v2/account/ledger".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2PointAccount" => Huobi::request(self, "v2/point/account".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountDepositAddress" => Huobi::request(self, "v2/account/deposit/address".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountWithdrawQuota" => Huobi::request(self, "v2/account/withdraw/quota".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountWithdrawAddress" => Huobi::request(self, "v2/account/withdraw/address".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2ReferenceCurrencies" => Huobi::request(self, "v2/reference/currencies".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1QueryDepositWithdraw" => Huobi::request(self, "v1/query/deposit-withdraw".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2UserApiKey" => Huobi::request(self, "v2/user/api-key".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2UserUid" => Huobi::request(self, "v2/user/uid".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2SubUserUserList" => Huobi::request(self, "v2/sub-user/user-list".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2SubUserUserState" => Huobi::request(self, "v2/sub-user/user-state".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2SubUserAccountList" => Huobi::request(self, "v2/sub-user/account-list".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2SubUserDepositAddress" => Huobi::request(self, "v2/sub-user/deposit-address".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2SubUserQueryDeposit" => Huobi::request(self, "v2/sub-user/query-deposit".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1SubuserAggregateBalance" => Huobi::request(self, "v1/subuser/aggregate-balance".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1AccountAccountsSubUid" => Huobi::request(self, "v1/account/accounts/{sub-uid}".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderOpenOrders" => Huobi::request(self, "v1/order/openOrders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderOrdersOrderId" => Huobi::request(self, "v1/order/orders/{order-id}".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderOrdersGetClientOrder" => Huobi::request(self, "v1/order/orders/getClientOrder".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderOrdersOrderIdMatchresults" => Huobi::request(self, "v1/order/orders/{order-id}/matchresults".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderOrders" => Huobi::request(self, "v1/order/orders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderHistory" => Huobi::request(self, "v1/order/history".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1OrderMatchresults" => Huobi::request(self, "v1/order/matchresults".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2ReferenceTransactFeeRate" => Huobi::request(self, "v2/reference/transact-fee-rate".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AlgoOrdersOpening" => Huobi::request(self, "v2/algo-orders/opening".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AlgoOrdersHistory" => Huobi::request(self, "v2/algo-orders/history".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AlgoOrdersSpecific" => Huobi::request(self, "v2/algo-orders/specific".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1MarginLoanInfo" => Huobi::request(self, "v1/margin/loan-info".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1MarginLoanOrders" => Huobi::request(self, "v1/margin/loan-orders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1MarginAccountsBalance" => Huobi::request(self, "v1/margin/accounts/balance".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1CrossMarginLoanInfo" => Huobi::request(self, "v1/cross-margin/loan-info".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1CrossMarginLoanOrders" => Huobi::request(self, "v1/cross-margin/loan-orders".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1CrossMarginAccountsBalance" => Huobi::request(self, "v1/cross-margin/accounts/balance".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2AccountRepayment" => Huobi::request(self, "v2/account/repayment".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV1StableCoinQuote" => Huobi::request(self, "v1/stable-coin/quote".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2EtpTransactions" => Huobi::request(self, "v2/etp/transactions".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2EtpTransaction" => Huobi::request(self, "v2/etp/transaction".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivateGetV2EtpLimit" => Huobi::request(self, "v2/etp/limit".into(), "spot".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1AccountTransfer" => Huobi::request(self, "v1/account/transfer".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1FuturesTransfer" => Huobi::request(self, "v1/futures/transfer".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2PointTransfer" => Huobi::request(self, "v2/point/transfer".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2AccountTransfer" => Huobi::request(self, "v2/account/transfer".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1DwWithdrawApiCreate" => Huobi::request(self, "v1/dw/withdraw/api/create".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1DwWithdrawVirtualWithdrawIdCancel" => Huobi::request(self, "v1/dw/withdraw-virtual/{withdraw-id}/cancel".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserDeductMode" => Huobi::request(self, "v2/sub-user/deduct-mode".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserCreation" => Huobi::request(self, "v2/sub-user/creation".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserManagement" => Huobi::request(self, "v2/sub-user/management".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserTradableMarket" => Huobi::request(self, "v2/sub-user/tradable-market".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserTransferability" => Huobi::request(self, "v2/sub-user/transferability".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserApiKeyGeneration" => Huobi::request(self, "v2/sub-user/api-key-generation".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserApiKeyModification" => Huobi::request(self, "v2/sub-user/api-key-modification".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2SubUserApiKeyDeletion" => Huobi::request(self, "v2/sub-user/api-key-deletion".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1SubuserTransfer" => Huobi::request(self, "v1/subuser/transfer".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1OrderOrdersPlace" => Huobi::request(self, "v1/order/orders/place".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1OrderBatchOrders" => Huobi::request(self, "v1/order/batch-orders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1OrderOrdersOrderIdSubmitcancel" => Huobi::request(self, "v1/order/orders/{order-id}/submitcancel".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1OrderOrdersSubmitCancelClientOrder" => Huobi::request(self, "v1/order/orders/submitCancelClientOrder".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1OrderOrdersBatchCancelOpenOrders" => Huobi::request(self, "v1/order/orders/batchCancelOpenOrders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1OrderOrdersBatchcancel" => Huobi::request(self, "v1/order/orders/batchcancel".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2AlgoOrdersCancelAllAfter" => Huobi::request(self, "v2/algo-orders/cancel-all-after".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2AlgoOrders" => Huobi::request(self, "v2/algo-orders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2AlgoOrdersCancellation" => Huobi::request(self, "v2/algo-orders/cancellation".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2AccountRepayment" => Huobi::request(self, "v2/account/repayment".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1DwTransferInMargin" => Huobi::request(self, "v1/dw/transfer-in/margin".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1DwTransferOutMargin" => Huobi::request(self, "v1/dw/transfer-out/margin".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1MarginOrders" => Huobi::request(self, "v1/margin/orders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1MarginOrdersOrderIdRepay" => Huobi::request(self, "v1/margin/orders/{order-id}/repay".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1CrossMarginTransferIn" => Huobi::request(self, "v1/cross-margin/transfer-in".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1CrossMarginTransferOut" => Huobi::request(self, "v1/cross-margin/transfer-out".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1CrossMarginOrders" => Huobi::request(self, "v1/cross-margin/orders".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1CrossMarginOrdersOrderIdRepay" => Huobi::request(self, "v1/cross-margin/orders/{order-id}/repay".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV1StableCoinExchange" => Huobi::request(self, "v1/stable-coin/exchange".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2EtpCreation" => Huobi::request(self, "v2/etp/creation".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2EtpRedemption" => Huobi::request(self, "v2/etp/redemption".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2EtpTransactIdCancel" => Huobi::request(self, "v2/etp/{transactId}/cancel".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "spotPrivatePostV2EtpBatchCancel" => Huobi::request(self, "v2/etp/batch-cancel".into(), "spot".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1Timestamp" => Huobi::request(self, "api/v1/timestamp".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetHeartbeat" => Huobi::request(self, "heartbeat/".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractContractInfo" => Huobi::request(self, "api/v1/contract_contract_info".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractIndex" => Huobi::request(self, "api/v1/contract_index".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractPriceLimit" => Huobi::request(self, "api/v1/contract_price_limit".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractOpenInterest" => Huobi::request(self, "api/v1/contract_open_interest".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractDeliveryPrice" => Huobi::request(self, "api/v1/contract_delivery_price".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketDepth" => Huobi::request(self, "market/depth".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketBbo" => Huobi::request(self, "market/bbo".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketHistoryKline" => Huobi::request(self, "market/history/kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryMarkPriceKline" => Huobi::request(self, "index/market/history/mark_price_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketDetailMerged" => Huobi::request(self, "market/detail/merged".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketDetailBatchMerged" => Huobi::request(self, "market/detail/batch_merged".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketTrade" => Huobi::request(self, "market/trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetMarketHistoryTrade" => Huobi::request(self, "market/history/trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractRiskInfo" => Huobi::request(self, "api/v1/contract_risk_info".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractInsuranceFund" => Huobi::request(self, "api/v1/contract_insurance_fund".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractAdjustfactor" => Huobi::request(self, "api/v1/contract_adjustfactor".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractHisOpenInterest" => Huobi::request(self, "api/v1/contract_his_open_interest".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractLadderMargin" => Huobi::request(self, "api/v1/contract_ladder_margin".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractApiState" => Huobi::request(self, "api/v1/contract_api_state".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractEliteAccountRatio" => Huobi::request(self, "api/v1/contract_elite_account_ratio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractElitePositionRatio" => Huobi::request(self, "api/v1/contract_elite_position_ratio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractLiquidationOrders" => Huobi::request(self, "api/v1/contract_liquidation_orders".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractSettlementRecords" => Huobi::request(self, "api/v1/contract_settlement_records".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryIndex" => Huobi::request(self, "index/market/history/index".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryBasis" => Huobi::request(self, "index/market/history/basis".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetApiV1ContractEstimatedSettlementPrice" => Huobi::request(self, "api/v1/contract_estimated_settlement_price".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapContractInfo" => Huobi::request(self, "swap-api/v1/swap_contract_info".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapIndex" => Huobi::request(self, "swap-api/v1/swap_index".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapPriceLimit" => Huobi::request(self, "swap-api/v1/swap_price_limit".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapOpenInterest" => Huobi::request(self, "swap-api/v1/swap_open_interest".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketDepth" => Huobi::request(self, "swap-ex/market/depth".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketBbo" => Huobi::request(self, "swap-ex/market/bbo".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketHistoryKline" => Huobi::request(self, "swap-ex/market/history/kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistorySwapMarkPriceKline" => Huobi::request(self, "index/market/history/swap_mark_price_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketDetailMerged" => Huobi::request(self, "swap-ex/market/detail/merged".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketDetailBatchMerged" => Huobi::request(self, "swap-ex/market/detail/batch_merged".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketTrade" => Huobi::request(self, "swap-ex/market/trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapExMarketHistoryTrade" => Huobi::request(self, "swap-ex/market/history/trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapRiskInfo" => Huobi::request(self, "swap-api/v1/swap_risk_info".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapInsuranceFund" => Huobi::request(self, "swap-api/v1/swap_insurance_fund".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapAdjustfactor" => Huobi::request(self, "swap-api/v1/swap_adjustfactor".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapHisOpenInterest" => Huobi::request(self, "swap-api/v1/swap_his_open_interest".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapLadderMargin" => Huobi::request(self, "swap-api/v1/swap_ladder_margin".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapApiState" => Huobi::request(self, "swap-api/v1/swap_api_state".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapEliteAccountRatio" => Huobi::request(self, "swap-api/v1/swap_elite_account_ratio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapElitePositionRatio" => Huobi::request(self, "swap-api/v1/swap_elite_position_ratio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapEstimatedSettlementPrice" => Huobi::request(self, "swap-api/v1/swap_estimated_settlement_price".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapLiquidationOrders" => Huobi::request(self, "swap-api/v1/swap_liquidation_orders".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapSettlementRecords" => Huobi::request(self, "swap-api/v1/swap_settlement_records".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapFundingRate" => Huobi::request(self, "swap-api/v1/swap_funding_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapBatchFundingRate" => Huobi::request(self, "swap-api/v1/swap_batch_funding_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1SwapHistoricalFundingRate" => Huobi::request(self, "swap-api/v1/swap_historical_funding_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistorySwapPremiumIndexKline" => Huobi::request(self, "index/market/history/swap_premium_index_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistorySwapEstimatedRateKline" => Huobi::request(self, "index/market/history/swap_estimated_rate_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistorySwapBasis" => Huobi::request(self, "index/market/history/swap_basis".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapContractInfo" => Huobi::request(self, "linear-swap-api/v1/swap_contract_info".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapIndex" => Huobi::request(self, "linear-swap-api/v1/swap_index".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapPriceLimit" => Huobi::request(self, "linear-swap-api/v1/swap_price_limit".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapOpenInterest" => Huobi::request(self, "linear-swap-api/v1/swap_open_interest".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketDepth" => Huobi::request(self, "linear-swap-ex/market/depth".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketBbo" => Huobi::request(self, "linear-swap-ex/market/bbo".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketHistoryKline" => Huobi::request(self, "linear-swap-ex/market/history/kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline" => Huobi::request(self, "index/market/history/linear_swap_mark_price_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketDetailMerged" => Huobi::request(self, "linear-swap-ex/market/detail/merged".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketDetailBatchMerged" => Huobi::request(self, "linear-swap-ex/market/detail/batch_merged".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketTrade" => Huobi::request(self, "linear-swap-ex/market/trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapExMarketHistoryTrade" => Huobi::request(self, "linear-swap-ex/market/history/trade".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapRiskInfo" => Huobi::request(self, "linear-swap-api/v1/swap_risk_info".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetSwapApiV1LinearSwapApiV1SwapInsuranceFund" => Huobi::request(self, "swap-api/v1/linear-swap-api/v1/swap_insurance_fund".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapAdjustfactor" => Huobi::request(self, "linear-swap-api/v1/swap_adjustfactor".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapCrossAdjustfactor" => Huobi::request(self, "linear-swap-api/v1/swap_cross_adjustfactor".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapHisOpenInterest" => Huobi::request(self, "linear-swap-api/v1/swap_his_open_interest".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapLadderMargin" => Huobi::request(self, "linear-swap-api/v1/swap_ladder_margin".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapCrossLadderMargin" => Huobi::request(self, "linear-swap-api/v1/swap_cross_ladder_margin".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapApiState" => Huobi::request(self, "linear-swap-api/v1/swap_api_state".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapCrossTransferState" => Huobi::request(self, "linear-swap-api/v1/swap_cross_transfer_state".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapCrossTradeState" => Huobi::request(self, "linear-swap-api/v1/swap_cross_trade_state".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapEliteAccountRatio" => Huobi::request(self, "linear-swap-api/v1/swap_elite_account_ratio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapElitePositionRatio" => Huobi::request(self, "linear-swap-api/v1/swap_elite_position_ratio".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapLiquidationOrders" => Huobi::request(self, "linear-swap-api/v1/swap_liquidation_orders".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapSettlementRecords" => Huobi::request(self, "linear-swap-api/v1/swap_settlement_records".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapFundingRate" => Huobi::request(self, "linear-swap-api/v1/swap_funding_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapBatchFundingRate" => Huobi::request(self, "linear-swap-api/v1/swap_batch_funding_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapHistoricalFundingRate" => Huobi::request(self, "linear-swap-api/v1/swap_historical_funding_rate".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline" => Huobi::request(self, "index/market/history/linear_swap_premium_index_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryLinearSwapEstimatedRateKline" => Huobi::request(self, "index/market/history/linear_swap_estimated_rate_kline".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetIndexMarketHistoryLinearSwapBasis" => Huobi::request(self, "index/market/history/linear_swap_basis".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPublicGetLinearSwapApiV1SwapEstimatedSettlementPrice" => Huobi::request(self, "linear-swap-api/v1/swap_estimated_settlement_price".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetApiV1ContractApiTradingStatus" => Huobi::request(self, "api/v1/contract_api_trading_status".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetSwapApiV1SwapApiTradingStatus" => Huobi::request(self, "swap-api/v1/swap_api_trading_status".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivateGetLinearSwapApiV1SwapApiTradingStatus" => Huobi::request(self, "linear-swap-api/v1/swap_api_trading_status".into(), "contract".into(), "GET".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractBalanceValuation" => Huobi::request(self, "api/v1/contract_balance_valuation".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractAccountInfo" => Huobi::request(self, "api/v1/contract_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractPositionInfo" => Huobi::request(self, "api/v1/contract_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractSubAuth" => Huobi::request(self, "api/v1/contract_sub_auth".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractSubAccountList" => Huobi::request(self, "api/v1/contract_sub_account_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractSubAccountInfoList" => Huobi::request(self, "api/v1/contract_sub_account_info_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractSubAccountInfo" => Huobi::request(self, "api/v1/contract_sub_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractSubPositionInfo" => Huobi::request(self, "api/v1/contract_sub_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractFinancialRecord" => Huobi::request(self, "api/v1/contract_financial_record".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractFinancialRecordExact" => Huobi::request(self, "api/v1/contract_financial_record_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractUserSettlementRecords" => Huobi::request(self, "api/v1/contract_user_settlement_records".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractOrderLimit" => Huobi::request(self, "api/v1/contract_order_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractFee" => Huobi::request(self, "api/v1/contract_fee".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTransferLimit" => Huobi::request(self, "api/v1/contract_transfer_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractPositionLimit" => Huobi::request(self, "api/v1/contract_position_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractAccountPositionInfo" => Huobi::request(self, "api/v1/contract_account_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractMasterSubTransfer" => Huobi::request(self, "api/v1/contract_master_sub_transfer".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractMasterSubTransferRecord" => Huobi::request(self, "api/v1/contract_master_sub_transfer_record".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractAvailableLevelRate" => Huobi::request(self, "api/v1/contract_available_level_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractOrder" => Huobi::request(self, "api/v1/contract_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostV1ContractBatchorder" => Huobi::request(self, "v1/contract_batchorder".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractCancel" => Huobi::request(self, "api/v1/contract_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractCancelall" => Huobi::request(self, "api/v1/contract_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractSwitchLeverRate" => Huobi::request(self, "api/v1/contract_switch_lever_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1LightningClosePosition" => Huobi::request(self, "api/v1/lightning_close_position".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractOrderInfo" => Huobi::request(self, "api/v1/contract_order_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractOrderDetail" => Huobi::request(self, "api/v1/contract_order_detail".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractOpenorders" => Huobi::request(self, "api/v1/contract_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractHisorders" => Huobi::request(self, "api/v1/contract_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractHisordersExact" => Huobi::request(self, "api/v1/contract_hisorders_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractMatchresults" => Huobi::request(self, "api/v1/contract_matchresults".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractMatchresultsExact" => Huobi::request(self, "api/v1/contract_matchresults_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTriggerOrder" => Huobi::request(self, "api/v1/contract_trigger_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTriggerCancel" => Huobi::request(self, "api/v1/contract_trigger_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTriggerCancelall" => Huobi::request(self, "api/v1/contract_trigger_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTriggerOpenorders" => Huobi::request(self, "api/v1/contract_trigger_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTriggerHisorders" => Huobi::request(self, "api/v1/contract_trigger_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTpslOrder" => Huobi::request(self, "api/v1/contract_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTpslCancel" => Huobi::request(self, "api/v1/contract_tpsl_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTpslCancelall" => Huobi::request(self, "api/v1/contract_tpsl_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTpslOpenorders" => Huobi::request(self, "api/v1/contract_tpsl_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTpslHisorders" => Huobi::request(self, "api/v1/contract_tpsl_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractRelationTpslOrder" => Huobi::request(self, "api/v1/contract_relation_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTrackOrder" => Huobi::request(self, "api/v1/contract_track_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTrackCancel" => Huobi::request(self, "api/v1/contract_track_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTrackCancelall" => Huobi::request(self, "api/v1/contract_track_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTrackOpenorders" => Huobi::request(self, "api/v1/contract_track_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostApiV1ContractTrackHisorders" => Huobi::request(self, "api/v1/contract_track_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapBalanceValuation" => Huobi::request(self, "swap-api/v1/swap_balance_valuation".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapAccountInfo" => Huobi::request(self, "swap-api/v1/swap_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapPositionInfo" => Huobi::request(self, "swap-api/v1/swap_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapAccountPositionInfo" => Huobi::request(self, "swap-api/v1/swap_account_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapSubAuth" => Huobi::request(self, "swap-api/v1/swap_sub_auth".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapSubAccountList" => Huobi::request(self, "swap-api/v1/swap_sub_account_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapSubAccountInfoList" => Huobi::request(self, "swap-api/v1/swap_sub_account_info_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapSubAccountInfo" => Huobi::request(self, "swap-api/v1/swap_sub_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapSubPositionInfo" => Huobi::request(self, "swap-api/v1/swap_sub_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapFinancialRecord" => Huobi::request(self, "swap-api/v1/swap_financial_record".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapFinancialRecordExact" => Huobi::request(self, "swap-api/v1/swap_financial_record_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapUserSettlementRecords" => Huobi::request(self, "swap-api/v1/swap_user_settlement_records".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapAvailableLevelRate" => Huobi::request(self, "swap-api/v1/swap_available_level_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapOrderLimit" => Huobi::request(self, "swap-api/v1/swap_order_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapFee" => Huobi::request(self, "swap-api/v1/swap_fee".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTransferLimit" => Huobi::request(self, "swap-api/v1/swap_transfer_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapPositionLimit" => Huobi::request(self, "swap-api/v1/swap_position_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapMasterSubTransfer" => Huobi::request(self, "swap-api/v1/swap_master_sub_transfer".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapMasterSubTransferRecord" => Huobi::request(self, "swap-api/v1/swap_master_sub_transfer_record".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapOrder" => Huobi::request(self, "swap-api/v1/swap_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapBatchorder" => Huobi::request(self, "swap-api/v1/swap_batchorder".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapCancel" => Huobi::request(self, "swap-api/v1/swap_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapCancelall" => Huobi::request(self, "swap-api/v1/swap_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapLightningClosePosition" => Huobi::request(self, "swap-api/v1/swap_lightning_close_position".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapSwitchLeverRate" => Huobi::request(self, "swap-api/v1/swap_switch_lever_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapOrderInfo" => Huobi::request(self, "swap-api/v1/swap_order_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapOrderDetail" => Huobi::request(self, "swap-api/v1/swap_order_detail".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapOpenorders" => Huobi::request(self, "swap-api/v1/swap_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapHisorders" => Huobi::request(self, "swap-api/v1/swap_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapHisordersExact" => Huobi::request(self, "swap-api/v1/swap_hisorders_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapMatchresults" => Huobi::request(self, "swap-api/v1/swap_matchresults".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapMatchresultsExact" => Huobi::request(self, "swap-api/v1/swap_matchresults_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTriggerOrder" => Huobi::request(self, "swap-api/v1/swap_trigger_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTriggerCancel" => Huobi::request(self, "swap-api/v1/swap_trigger_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTriggerCancelall" => Huobi::request(self, "swap-api/v1/swap_trigger_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTriggerOpenorders" => Huobi::request(self, "swap-api/v1/swap_trigger_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTriggerHisorders" => Huobi::request(self, "swap-api/v1/swap_trigger_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTpslOrder" => Huobi::request(self, "swap-api/v1/swap_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTpslCancel" => Huobi::request(self, "swap-api/v1/swap_tpsl_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTpslCancelall" => Huobi::request(self, "swap-api/v1/swap_tpsl_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTpslOpenorders" => Huobi::request(self, "swap-api/v1/swap_tpsl_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTpslHisorders" => Huobi::request(self, "swap-api/v1/swap_tpsl_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapRelationTpslOrder" => Huobi::request(self, "swap-api/v1/swap_relation_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTrackOrder" => Huobi::request(self, "swap-api/v1/swap_track_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTrackCancel" => Huobi::request(self, "swap-api/v1/swap_track_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTrackCancelall" => Huobi::request(self, "swap-api/v1/swap_track_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTrackOpenorders" => Huobi::request(self, "swap-api/v1/swap_track_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostSwapApiV1SwapTrackHisorders" => Huobi::request(self, "swap-api/v1/swap_track_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapLeverPositionLimit" => Huobi::request(self, "linear-swap-api/v1/swap_lever_position_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossLeverPositionLimit" => Huobi::request(self, "linear-swap-api/v1/swap_cross_lever_position_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapBalanceValuation" => Huobi::request(self, "linear-swap-api/v1/swap_balance_valuation".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapAccountInfo" => Huobi::request(self, "linear-swap-api/v1/swap_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossAccountInfo" => Huobi::request(self, "linear-swap-api/v1/swap_cross_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapPositionInfo" => Huobi::request(self, "linear-swap-api/v1/swap_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossPositionInfo" => Huobi::request(self, "linear-swap-api/v1/swap_cross_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapAccountPositionInfo" => Huobi::request(self, "linear-swap-api/v1/swap_account_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossAccountPositionInfo" => Huobi::request(self, "linear-swap-api/v1/swap_cross_account_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSubAuth" => Huobi::request(self, "linear-swap-api/v1/swap_sub_auth".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSubAccountList" => Huobi::request(self, "linear-swap-api/v1/swap_sub_account_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossSubAccountList" => Huobi::request(self, "linear-swap-api/v1/swap_cross_sub_account_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSubAccountInfoList" => Huobi::request(self, "linear-swap-api/v1/swap_sub_account_info_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossSubAccountInfoList" => Huobi::request(self, "linear-swap-api/v1/swap_cross_sub_account_info_list".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSubAccountInfo" => Huobi::request(self, "linear-swap-api/v1/swap_sub_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossSubAccountInfo" => Huobi::request(self, "linear-swap-api/v1/swap_cross_sub_account_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSubPositionInfo" => Huobi::request(self, "linear-swap-api/v1/swap_sub_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossSubPositionInfo" => Huobi::request(self, "linear-swap-api/v1/swap_cross_sub_position_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapFinancialRecord" => Huobi::request(self, "linear-swap-api/v1/swap_financial_record".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapFinancialRecordExact" => Huobi::request(self, "linear-swap-api/v1/swap_financial_record_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapUserSettlementRecords" => Huobi::request(self, "linear-swap-api/v1/swap_user_settlement_records".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossUserSettlementRecords" => Huobi::request(self, "linear-swap-api/v1/swap_cross_user_settlement_records".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapAvailableLevelRate" => Huobi::request(self, "linear-swap-api/v1/swap_available_level_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossAvailableLevelRate" => Huobi::request(self, "linear-swap-api/v1/swap_cross_available_level_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapOrderLimit" => Huobi::request(self, "linear-swap-api/v1/swap_order_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapFee" => Huobi::request(self, "linear-swap-api/v1/swap_fee".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTransferLimit" => Huobi::request(self, "linear-swap-api/v1/swap_transfer_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTransferLimit" => Huobi::request(self, "linear-swap-api/v1/swap_cross_transfer_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapPositionLimit" => Huobi::request(self, "linear-swap-api/v1/swap_position_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossPositionLimit" => Huobi::request(self, "linear-swap-api/v1/swap_cross_position_limit".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapMasterSubTransfer" => Huobi::request(self, "linear-swap-api/v1/swap_master_sub_transfer".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapMasterSubTransferRecord" => Huobi::request(self, "linear-swap-api/v1/swap_master_sub_transfer_record".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTransferInner" => Huobi::request(self, "linear-swap-api/v1/swap_transfer_inner".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapOrder" => Huobi::request(self, "linear-swap-api/v1/swap_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossOrder" => Huobi::request(self, "linear-swap-api/v1/swap_cross_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapBatchorder" => Huobi::request(self, "linear-swap-api/v1/swap_batchorder".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossBatchorder" => Huobi::request(self, "linear-swap-api/v1/swap_cross_batchorder".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCancel" => Huobi::request(self, "linear-swap-api/v1/swap_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossCancel" => Huobi::request(self, "linear-swap-api/v1/swap_cross_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCancelall" => Huobi::request(self, "linear-swap-api/v1/swap_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossCancelall" => Huobi::request(self, "linear-swap-api/v1/swap_cross_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSwitchLeverRate" => Huobi::request(self, "linear-swap-api/v1/swap_switch_lever_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossSwitchLeverRate" => Huobi::request(self, "linear-swap-api/v1/swap_cross_switch_lever_rate".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapLightningClosePosition" => Huobi::request(self, "linear-swap-api/v1/swap_lightning_close_position".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossLightningClosePosition" => Huobi::request(self, "linear-swap-api/v1/swap_cross_lightning_close_position".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapOrderInfo" => Huobi::request(self, "linear-swap-api/v1/swap_order_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossOrderInfo" => Huobi::request(self, "linear-swap-api/v1/swap_cross_order_info".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapOrderDetail" => Huobi::request(self, "linear-swap-api/v1/swap_order_detail".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossOrderDetail" => Huobi::request(self, "linear-swap-api/v1/swap_cross_order_detail".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapOpenorders" => Huobi::request(self, "linear-swap-api/v1/swap_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossOpenorders" => Huobi::request(self, "linear-swap-api/v1/swap_cross_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapHisorders" => Huobi::request(self, "linear-swap-api/v1/swap_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossHisorders" => Huobi::request(self, "linear-swap-api/v1/swap_cross_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapHisordersExact" => Huobi::request(self, "linear-swap-api/v1/swap_hisorders_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossHisordersExact" => Huobi::request(self, "linear-swap-api/v1/swap_cross_hisorders_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapMatchresults" => Huobi::request(self, "linear-swap-api/v1/swap_matchresults".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossMatchresults" => Huobi::request(self, "linear-swap-api/v1/swap_cross_matchresults".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapMatchresultsExact" => Huobi::request(self, "linear-swap-api/v1/swap_matchresults_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossMatchresultsExact" => Huobi::request(self, "linear-swap-api/v1/swap_cross_matchresults_exact".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapSwitchPositionMode" => Huobi::request(self, "linear-swap-api/v1/swap_switch_position_mode".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossSwitchPositionMode" => Huobi::request(self, "linear-swap-api/v1/swap_cross_switch_position_mode".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTriggerOrder" => Huobi::request(self, "linear-swap-api/v1/swap_trigger_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTriggerOrder" => Huobi::request(self, "linear-swap-api/v1/swap_cross_trigger_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTriggerCancel" => Huobi::request(self, "linear-swap-api/v1/swap_trigger_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTriggerCancel" => Huobi::request(self, "linear-swap-api/v1/swap_cross_trigger_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTriggerCancelall" => Huobi::request(self, "linear-swap-api/v1/swap_trigger_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTriggerCancelall" => Huobi::request(self, "linear-swap-api/v1/swap_cross_trigger_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTriggerOpenorders" => Huobi::request(self, "linear-swap-api/v1/swap_trigger_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTriggerOpenorders" => Huobi::request(self, "linear-swap-api/v1/swap_cross_trigger_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTriggerHisorders" => Huobi::request(self, "linear-swap-api/v1/swap_trigger_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTriggerHisorders" => Huobi::request(self, "linear-swap-api/v1/swap_cross_trigger_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTpslOrder" => Huobi::request(self, "linear-swap-api/v1/swap_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTpslOrder" => Huobi::request(self, "linear-swap-api/v1/swap_cross_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTpslCancel" => Huobi::request(self, "linear-swap-api/v1/swap_tpsl_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTpslCancel" => Huobi::request(self, "linear-swap-api/v1/swap_cross_tpsl_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTpslCancelall" => Huobi::request(self, "linear-swap-api/v1/swap_tpsl_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTpslCancelall" => Huobi::request(self, "linear-swap-api/v1/swap_cross_tpsl_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTpslOpenorders" => Huobi::request(self, "linear-swap-api/v1/swap_tpsl_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTpslOpenorders" => Huobi::request(self, "linear-swap-api/v1/swap_cross_tpsl_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTpslHisorders" => Huobi::request(self, "linear-swap-api/v1/swap_tpsl_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTpslHisorders" => Huobi::request(self, "linear-swap-api/v1/swap_cross_tpsl_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapRelationTpslOrder" => Huobi::request(self, "linear-swap-api/v1/swap_relation_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossRelationTpslOrder" => Huobi::request(self, "linear-swap-api/v1/swap_cross_relation_tpsl_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTrackOrder" => Huobi::request(self, "linear-swap-api/v1/swap_track_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTrackOrder" => Huobi::request(self, "linear-swap-api/v1/swap_cross_track_order".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTrackCancel" => Huobi::request(self, "linear-swap-api/v1/swap_track_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTrackCancel" => Huobi::request(self, "linear-swap-api/v1/swap_cross_track_cancel".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTrackCancelall" => Huobi::request(self, "linear-swap-api/v1/swap_track_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTrackCancelall" => Huobi::request(self, "linear-swap-api/v1/swap_cross_track_cancelall".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTrackOpenorders" => Huobi::request(self, "linear-swap-api/v1/swap_track_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTrackOpenorders" => Huobi::request(self, "linear-swap-api/v1/swap_cross_track_openorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapTrackHisorders" => Huobi::request(self, "linear-swap-api/v1/swap_track_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    "contractPrivatePostLinearSwapApiV1SwapCrossTrackHisorders" => Huobi::request(self, "linear-swap-api/v1/swap_cross_track_hisorders".into(), "contract".into(), "POST".into(), params, Value::Undefined, Value::Undefined, Value::Undefined, context).await,
                    _ => unimplemented!(),
                }
            },
            _ => unimplemented!()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct HuobiImpl(Value);
impl Exchange for HuobiImpl {}
impl Huobi for HuobiImpl {}
impl ValueTrait for HuobiImpl {
    fn is_undefined(&self) -> bool { self.0.is_undefined() }
    fn is_nullish(&self) -> bool { self.0.is_nullish() }
    fn is_nonnullish(&self) -> bool { self.0.is_nonnullish() }
    fn is_truthy(&self) -> bool { self.0.is_truthy() }
    fn or_default(&self, default: Value) -> Value { self.0.or_default(default) }
    fn is_number(&self) -> bool { self.0.is_number() }
    fn is_string(&self) -> bool { self.0.is_string() }
    fn is_object(&self) -> bool { self.0.is_object() }
    fn is_falsy(&self) -> bool { self.0.is_falsy() }
    fn to_upper_case(&self) -> Value { self.0.to_upper_case() }
    fn unwrap_str(&self) -> &str { self.0.unwrap_str() }
    fn unwrap_usize(&self) -> usize { self.0.unwrap_usize() }
    fn unwrap_bool(&self) -> bool { self.0.unwrap_bool() }
    fn unwrap_precise(&self) -> &Precise { self.0.unwrap_precise() }
    fn unwrap_json(&self) -> &serde_json::Value { self.0.unwrap_json() }
    fn unwrap_json_mut(&mut self) -> &mut serde_json::Value { self.0.unwrap_json_mut() }
    fn unwrap_precise_mut(&mut self) -> &mut Precise { self.0.unwrap_precise_mut() }
    fn len(&self) -> usize { self.0.len() }
    fn get(&self, key: Value) -> Value { self.0.get(key) }
    fn set(&mut self, key: Value, value: Value) { self.0.set(key, value) }
    fn push(&mut self, value: Value) { self.0.push(value) }
    fn split(&self, separator: Value) -> Value { self.0.split(separator) }
    fn contains_key(&self, key: Value) -> bool { self.0.contains_key(key) }
    fn keys(&self) -> Vec<Value> { self.0.keys() }
    fn values(&self) -> Vec<Value> { self.0.values() }
    fn to_array(&self, x: Value) -> Value { self.0.to_array(x) }
    fn index_of(&self, x: Value) -> Value { self.0.index_of(x) }
    fn join(&self, glue: Value) -> Value { self.0.join(glue) }
    fn to_string(&self) -> Value { self.0.to_string() }
    fn typeof_(&self) -> Value { self.0.typeof_() }
    fn slice(&self, start: Value) -> Value { self.0.slice(start) }
}

impl HuobiImpl {
    pub fn new(params: Value) -> Self {
        let mut rv = HuobiImpl(match params {
            Value::Json(_) => params,
            _ => Value::new_object()
        });
        ExchangeImpl::init(&mut rv.0);

        let config_entries = Huobi::describe(&rv);
        for k in config_entries.keys() {
            rv.set(k.clone(), config_entries.get(k).clone());
        }
        rv
    }
}

